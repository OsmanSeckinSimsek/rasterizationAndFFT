<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rasterizationAndFFT + Cornerstone API: cstone Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">rasterizationAndFFT + Cornerstone API
   </div>
   <div id="projectbrief">Distributed octree domain, rasterization, and FFT utilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespacecstone.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">cstone Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacecstone_1_1aux__traits" id="r_namespacecstone_1_1aux__traits"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone_1_1aux__traits.html">aux_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecstone_1_1detail" id="r_namespacecstone_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacecstone_1_1domain__exchange" id="r_namespacecstone_1_1domain__exchange"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone_1_1domain__exchange.html">domain_exchange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1AccelSwitchType.html">AccelSwitchType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type member of this trait evaluates to CpuCaseType if Accelerator == <a class="el" href="structcstone_1_1CpuTag.html">CpuTag</a> and GpuCaseType otherwise.  <a href="structcstone_1_1AccelSwitchType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1AccelSwitchType_3_01Accelerator_00_01CpuCaseType_00_01GpuCaseType_00_01std_1_1enad0343bc173fc55b8f912aec63bc1209.html">AccelSwitchType&lt; Accelerator, CpuCaseType, GpuCaseType, std::enable_if_t&lt; HaveGpu&lt; Accelerator &gt;{}&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1AccelSwitchType_3_01Accelerator_00_01CpuCaseType_00_01GpuCaseType_00_01std_1_1en59916ef03c9f5989605d47e631a74ff8.html">AccelSwitchType&lt; Accelerator, CpuCaseType, GpuCaseType, std::enable_if_t&lt;!HaveGpu&lt; Accelerator &gt;{}&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1BinaryNode.html">BinaryNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">binary radix tree node  <a href="structcstone_1_1BinaryNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcstone_1_1Box.html">Box</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores the coordinate bounds  <a href="classcstone_1_1Box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1BufferDescription.html">BufferDescription</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Layout description for particle buffers.  <a href="structcstone_1_1BufferDescription.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1CombinedUpdate.html">CombinedUpdate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulation to allow making this a friend of Octree&lt;KeyType&gt;  <a href="structcstone_1_1CombinedUpdate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1CombineSourceCenter.html">CombineSourceCenter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute a mass center from other mass centers for use in tree upsweep  <a href="structcstone_1_1CombineSourceCenter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1CpuTag.html">CpuTag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcstone_1_1Domain.html">Domain</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcstone_1_1FieldStates.html">FieldStates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to keep track of field states.  <a href="classcstone_1_1FieldStates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcstone_1_1FocusedOctree.html">FocusedOctree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fully traversable octree with a local focus.  <a href="classcstone_1_1FocusedOctree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcstone_1_1FocusedOctreeSingleNode.html">FocusedOctreeSingleNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A fully traversable octree, locally focused w.r.t a MinMac criterion.  <a href="classcstone_1_1FocusedOctreeSingleNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcstone_1_1GlobalAssignment.html">GlobalAssignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for global domain assignment and distribution.  <a href="classcstone_1_1GlobalAssignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcstone_1_1GlobalAssignmentGpu.html">GlobalAssignmentGpu</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcstone_1_1GpuSfcSorter.html">GpuSfcSorter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1GpuTag.html">GpuTag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcstone_1_1Halos.html">Halos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1HaveGpu.html">HaveGpu</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1IndexPair.html">IndexPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcstone_1_1IndexRanges.html">IndexRanges</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores ranges of local particles to be sent to another rank.  <a href="classcstone_1_1IndexRanges.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1IsHilbert.html">IsHilbert</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function to detect Hilbert key types.  <a href="structcstone_1_1IsHilbert.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1IsMorton.html">IsMorton</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function to detect Morton key types.  <a href="structcstone_1_1IsMorton.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1maxCoord.html">maxCoord</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum integer coordinate  <a href="structcstone_1_1maxCoord.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1maxTreeLevel.html">maxTreeLevel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1maxTreeLevel_3_01HilbertKey_3_01unsigned_01_4_01_4.html">maxTreeLevel&lt; HilbertKey&lt; unsigned &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1maxTreeLevel_3_01HilbertKey_3_01unsigned_01long_01_4_01_4.html">maxTreeLevel&lt; HilbertKey&lt; unsigned long &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1maxTreeLevel_3_01HilbertKey_3_01unsigned_01long_01long_01_4_01_4.html">maxTreeLevel&lt; HilbertKey&lt; unsigned long long &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1maxTreeLevel_3_01MortonKey_3_01unsigned_01_4_01_4.html">maxTreeLevel&lt; MortonKey&lt; unsigned &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1maxTreeLevel_3_01MortonKey_3_01unsigned_01long_01_4_01_4.html">maxTreeLevel&lt; MortonKey&lt; unsigned long &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1maxTreeLevel_3_01MortonKey_3_01unsigned_01long_01long_01_4_01_4.html">maxTreeLevel&lt; MortonKey&lt; unsigned long long &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1maxTreeLevel_3_01unsigned_01_4.html">maxTreeLevel&lt; unsigned &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1maxTreeLevel_3_01unsigned_01long_01_4.html">maxTreeLevel&lt; unsigned long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1maxTreeLevel_3_01unsigned_01long_01long_01_4.html">maxTreeLevel&lt; unsigned long long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1MinMax.html">MinMax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute minimum and maximum of an array range with an OpenMP reduction  <a href="structcstone_1_1MinMax.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1MinMaxGpu.html">MinMaxGpu</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1NodeCount.html">NodeCount</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcstone_1_1Octree.html">Octree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcstone_1_1OctreeData.html">OctreeData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcstone_1_1OctreeMaker.html">OctreeMaker</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate example cornerstone octrees for testing  <a href="classcstone_1_1OctreeMaker.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1OctreeNsView.html">OctreeNsView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcstone_1_1Octree.html">Octree</a> data and properties needed for neighbor search traversal.  <a href="structcstone_1_1OctreeNsView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1OctreeProperties.html">OctreeProperties</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contains a view to octree data as well as associated node properties.  <a href="structcstone_1_1OctreeProperties.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1OctreeView.html">OctreeView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcstone_1_1Octree.html">Octree</a> data view, compatible with GPU data.  <a href="structcstone_1_1OctreeView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcstone_1_1SendList.html">SendList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classcstone_1_1SendList.html" title="SendList contains one manifest per rank.">SendList</a> contains one manifest per rank.  <a href="classcstone_1_1SendList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcstone_1_1SendRanges.html">SendRanges</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcstone_1_1SfcSorter.html">SfcSorter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcstone_1_1SimpleBox.html">SimpleBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores octree index integer bounds  <a href="classcstone_1_1SimpleBox.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcstone_1_1SpaceCurveAssignment.html">SpaceCurveAssignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores which parts of the SFC belong to which rank, on a per-rank basis  <a href="classcstone_1_1SpaceCurveAssignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1SumCombination.html">SumCombination</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1unusedBits.html">unusedBits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1unusedBits_3_01HilbertKey_3_01unsigned_01_4_01_4.html">unusedBits&lt; HilbertKey&lt; unsigned &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1unusedBits_3_01HilbertKey_3_01unsigned_01long_01_4_01_4.html">unusedBits&lt; HilbertKey&lt; unsigned long &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1unusedBits_3_01HilbertKey_3_01unsigned_01long_01long_01_4_01_4.html">unusedBits&lt; HilbertKey&lt; unsigned long long &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1unusedBits_3_01MortonKey_3_01unsigned_01_4_01_4.html">unusedBits&lt; MortonKey&lt; unsigned &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1unusedBits_3_01MortonKey_3_01unsigned_01long_01_4_01_4.html">unusedBits&lt; MortonKey&lt; unsigned long &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1unusedBits_3_01MortonKey_3_01unsigned_01long_01long_01_4_01_4.html">unusedBits&lt; MortonKey&lt; unsigned long long &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1unusedBits_3_01unsigned_01_4.html">unusedBits&lt; unsigned &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of unused leading zeros in a 32-bit SFC code  <a href="structcstone_1_1unusedBits_3_01unsigned_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1unusedBits_3_01unsigned_01long_01_4.html">unusedBits&lt; unsigned long &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcstone_1_1unusedBits_3_01unsigned_01long_01long_01_4.html">unusedBits&lt; unsigned long long &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of unused leading zeros in a 64-bit SFC code  <a href="structcstone_1_1unusedBits_3_01unsigned_01long_01long_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab92e8dfcff11066ac75330812a896de9" id="r_ab92e8dfcff11066ac75330812a896de9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ab92e8dfcff11066ac75330812a896de9">TreeIndexPair</a> = <a class="el" href="structcstone_1_1IndexPair.html">IndexPair</a>&lt; <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt;</td></tr>
<tr class="separator:ab92e8dfcff11066ac75330812a896de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ab04d838fb61ba643368b6419793df" id="r_a91ab04d838fb61ba643368b6419793df"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a91ab04d838fb61ba643368b6419793df">SendManifest</a> = <a class="el" href="classcstone_1_1IndexRanges.html">IndexRanges</a>&lt; <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> &gt;</td></tr>
<tr class="memdesc:a91ab04d838fb61ba643368b6419793df"><td class="mdescLeft">&#160;</td><td class="mdescRight">stores one or multiple index ranges of local particles to send out to another rank  <br /></td></tr>
<tr class="separator:a91ab04d838fb61ba643368b6419793df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3767e831204a1a7e180456eced6d15e5" id="r_a3767e831204a1a7e180456eced6d15e5"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3767e831204a1a7e180456eced6d15e5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a3767e831204a1a7e180456eced6d15e5">SourceCenterType</a> = <a class="el" href="structutil_1_1array.html">util::array</a>&lt; T, 4 &gt;</td></tr>
<tr class="separator:a3767e831204a1a7e180456eced6d15e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f04118d59095aa5ac36e505d445d0b" id="r_a72f04118d59095aa5ac36e505d445d0b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> = <a class="el" href="classcstone_1_1SimpleBox.html">SimpleBox</a>&lt; int &gt;</td></tr>
<tr class="separator:a72f04118d59095aa5ac36e505d445d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17864a21bbfcf1e20ef7c834edae7cf3" id="r_a17864a21bbfcf1e20ef7c834edae7cf3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a17864a21bbfcf1e20ef7c834edae7cf3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a17864a21bbfcf1e20ef7c834edae7cf3">FBox</a> = <a class="el" href="classcstone_1_1SimpleBox.html">SimpleBox</a>&lt; T &gt;</td></tr>
<tr class="separator:a17864a21bbfcf1e20ef7c834edae7cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3aaa9bdf295f6d863bd8af0b9c95b38" id="r_ac3aaa9bdf295f6d863bd8af0b9c95b38"><td class="memTemplParams" colspan="2">template&lt;class IntegerType &gt; </td></tr>
<tr class="memitem:ac3aaa9bdf295f6d863bd8af0b9c95b38"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ac3aaa9bdf295f6d863bd8af0b9c95b38">MortonKey</a> = <a class="el" href="structStrongType.html">StrongType</a>&lt; IntegerType, struct MortonKeyTag &gt;</td></tr>
<tr class="memdesc:ac3aaa9bdf295f6d863bd8af0b9c95b38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strong type for Morton keys.  <br /></td></tr>
<tr class="separator:ac3aaa9bdf295f6d863bd8af0b9c95b38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6d0a9f945916bff359b92736f003c4" id="r_a6c6d0a9f945916bff359b92736f003c4"><td class="memTemplParams" colspan="2">template&lt;class IntegerType &gt; </td></tr>
<tr class="memitem:a6c6d0a9f945916bff359b92736f003c4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a6c6d0a9f945916bff359b92736f003c4">HilbertKey</a> = <a class="el" href="structStrongType.html">StrongType</a>&lt; IntegerType, struct HilbertKeyTag &gt;</td></tr>
<tr class="memdesc:a6c6d0a9f945916bff359b92736f003c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strong type for Hilbert keys.  <br /></td></tr>
<tr class="separator:a6c6d0a9f945916bff359b92736f003c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d054fd740773a4ffbaecadfb6cecf92" id="r_a4d054fd740773a4ffbaecadfb6cecf92"><td class="memTemplParams" colspan="2">template&lt;class IntegerType &gt; </td></tr>
<tr class="memitem:a4d054fd740773a4ffbaecadfb6cecf92"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a4d054fd740773a4ffbaecadfb6cecf92">SfcKind</a> = <a class="el" href="namespacecstone.html#a6c6d0a9f945916bff359b92736f003c4">HilbertKey</a>&lt; IntegerType &gt;</td></tr>
<tr class="memdesc:a4d054fd740773a4ffbaecadfb6cecf92"><td class="mdescLeft">&#160;</td><td class="mdescRight">use this definition to select the kind of space filling curve to use  <br /></td></tr>
<tr class="separator:a4d054fd740773a4ffbaecadfb6cecf92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ddbbe0e6bf938c6b5675d15fd3ced3" id="r_a02ddbbe0e6bf938c6b5675d15fd3ced3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> = int</td></tr>
<tr class="memdesc:a02ddbbe0e6bf938c6b5675d15fd3ced3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the node index type, has to be signed. Change to 64-bit if more than 2 billion tree nodes are required.  <br /></td></tr>
<tr class="separator:a02ddbbe0e6bf938c6b5675d15fd3ced3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e01a219224a6310ad91973dbcaf1b1e" id="r_a4e01a219224a6310ad91973dbcaf1b1e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> = unsigned</td></tr>
<tr class="memdesc:a4e01a219224a6310ad91973dbcaf1b1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">index type of local particle arrays  <br /></td></tr>
<tr class="separator:a4e01a219224a6310ad91973dbcaf1b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1dfa0259eedf8f87f334dab04e92da" id="r_a7e1dfa0259eedf8f87f334dab04e92da"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7e1dfa0259eedf8f87f334dab04e92da"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a> = <a class="el" href="structutil_1_1array.html">util::array</a>&lt; T, 3 &gt;</td></tr>
<tr class="separator:a7e1dfa0259eedf8f87f334dab04e92da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2b5abd635257ad027f958158d2ae21" id="r_a3c2b5abd635257ad027f958158d2ae21"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a3c2b5abd635257ad027f958158d2ae21"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a3c2b5abd635257ad027f958158d2ae21">Vec4</a> = <a class="el" href="structutil_1_1array.html">util::array</a>&lt; T, 4 &gt;</td></tr>
<tr class="separator:a3c2b5abd635257ad027f958158d2ae21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a388434742a2abebe943b6f5445e6732b" id="r_a388434742a2abebe943b6f5445e6732b"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a388434742a2abebe943b6f5445e6732b">ResolutionStatus</a> : int { <a class="el" href="namespacecstone.html#a388434742a2abebe943b6f5445e6732ba7de33615d7fbc1cb7bc608d12f1993d2">converged</a>
, <a class="el" href="namespacecstone.html#a388434742a2abebe943b6f5445e6732ba6c15ee6418136c7d340274db7d302858">cancelMerge</a>
, <a class="el" href="namespacecstone.html#a388434742a2abebe943b6f5445e6732ba2971b584d3673ffb4dbcf822a50ee91e">rebalance</a>
, <a class="el" href="namespacecstone.html#a388434742a2abebe943b6f5445e6732ba26934eb377001f66e37289a5c93fe284">failed</a>
 }</td></tr>
<tr class="separator:a388434742a2abebe943b6f5445e6732b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0e1a8a75927421e319d5474fc7b816" id="r_a2a0e1a8a75927421e319d5474fc7b816"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a2a0e1a8a75927421e319d5474fc7b816">BoundaryType</a> : char { <a class="el" href="namespacecstone.html#a2a0e1a8a75927421e319d5474fc7b816a7cef8a734855777c2a9d0caf42666e69">open</a> = 0
, <a class="el" href="namespacecstone.html#a2a0e1a8a75927421e319d5474fc7b816ae6ffdec5e14fce371eb7ae99edebbbee">periodic</a> = 1
, <a class="el" href="namespacecstone.html#a2a0e1a8a75927421e319d5474fc7b816acec315e3d0975e5cc2811d5d8725f149">fixed</a> = 2
 }</td></tr>
<tr class="separator:a2a0e1a8a75927421e319d5474fc7b816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31981fd8652f4ff13624cecdd1bbce07" id="r_a31981fd8652f4ff13624cecdd1bbce07"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a31981fd8652f4ff13624cecdd1bbce07">P2pTags</a> : int { <br />
&#160;&#160;<a class="el" href="namespacecstone.html#a31981fd8652f4ff13624cecdd1bbce07a7d2e7649b3ff02477d72c6ee3f2bf866">focusTransfer</a> = 1000
, <a class="el" href="namespacecstone.html#a31981fd8652f4ff13624cecdd1bbce07abd5e7e1f0f5a0ba0b0e03e6193c35449">focusPeerCounts</a> = 2000
, <a class="el" href="namespacecstone.html#a31981fd8652f4ff13624cecdd1bbce07a77a0dbbc4e6b9d704e43ebda2cc9161f">focusPeerCenters</a> = 3000
, <a class="el" href="namespacecstone.html#a31981fd8652f4ff13624cecdd1bbce07a3bb747f80b8cf5e6a366bb5c3f5fbbab">haloRequestKeys</a> = 4000
, <br />
&#160;&#160;<a class="el" href="namespacecstone.html#a31981fd8652f4ff13624cecdd1bbce07aa2ae917ea9ba07793448fb827b899ac9">domainExchange</a> = 5000
, <a class="el" href="namespacecstone.html#a31981fd8652f4ff13624cecdd1bbce07a78664471a35a2ecded9c082a4a31ae0e">haloExchange</a> = 6000
<br />
 }</td></tr>
<tr class="separator:a31981fd8652f4ff13624cecdd1bbce07"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8e67b0f98874eda3f3bc50c49d79e5a2" id="r_a8e67b0f98874eda3f3bc50c49d79e5a2"><td class="memTemplParams" colspan="2">template&lt;class... Arrays&gt; </td></tr>
<tr class="memitem:a8e67b0f98874eda3f3bc50c49d79e5a2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a8e67b0f98874eda3f3bc50c49d79e5a2">computeByteOffsets</a> (size_t count, int alignment, Arrays... arrays)</td></tr>
<tr class="separator:a8e67b0f98874eda3f3bc50c49d79e5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68f9bf47f0afed62abeb3333352f668" id="r_aa68f9bf47f0afed62abeb3333352f668"><td class="memTemplParams" colspan="2">template&lt;int alignment, class... Arrays&gt; </td></tr>
<tr class="memitem:aa68f9bf47f0afed62abeb3333352f668"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aa68f9bf47f0afed62abeb3333352f668">computeTotalSendBytes</a> (const <a class="el" href="classcstone_1_1SendList.html">SendList</a> &amp;sendList, int thisRank, size_t numBytesHeader, Arrays... arrays)</td></tr>
<tr class="separator:aa68f9bf47f0afed62abeb3333352f668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbde3b7e05ff14f26d3ca47ddc367f9" id="r_a1cbde3b7e05ff14f26d3ca47ddc367f9"><td class="memTemplParams" colspan="2">template&lt;int alignment, class... Arrays&gt; </td></tr>
<tr class="memitem:a1cbde3b7e05ff14f26d3ca47ddc367f9"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a1cbde3b7e05ff14f26d3ca47ddc367f9">computeTotalSendBytes</a> (const <a class="el" href="classcstone_1_1SendRanges.html">SendRanges</a> &amp;sends, int thisRank, size_t numBytesHeader, Arrays... arrays)</td></tr>
<tr class="separator:a1cbde3b7e05ff14f26d3ca47ddc367f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888644d7cc3080934ff932ecf4e6fef2" id="r_a888644d7cc3080934ff932ecf4e6fef2"><td class="memTemplParams" colspan="2">template&lt;int alignment, class... Arrays&gt; </td></tr>
<tr class="memitem:a888644d7cc3080934ff932ecf4e6fef2"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a888644d7cc3080934ff932ecf4e6fef2">packBufferPtrs</a> (char *packedBufferBase, size_t arraySize, Arrays... arrays)</td></tr>
<tr class="memdesc:a888644d7cc3080934ff932ecf4e6fef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute multiple pointers such that the argument <code>arrays</code> can be mapped into a single buffer.  <br /></td></tr>
<tr class="separator:a888644d7cc3080934ff932ecf4e6fef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c438ae28e65cd6d9c2f73610e45fcee" id="r_a6c438ae28e65cd6d9c2f73610e45fcee"><td class="memTemplParams" colspan="2">template&lt;int alignment, class F , class... Arrays&gt; </td></tr>
<tr class="memitem:a6c438ae28e65cd6d9c2f73610e45fcee"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a6c438ae28e65cd6d9c2f73610e45fcee">packArrays</a> (F &amp;&amp;<a class="el" href="namespacecstone.html#a6fc44a01e05969aefa3493a1cc38755f">gather</a>, const <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> *ordering, <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> numElements, char *buffer, Arrays... arrays)</td></tr>
<tr class="memdesc:a6c438ae28e65cd6d9c2f73610e45fcee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gather <code>numElements</code> of each array accessed through <code>ordering</code> into <code>buffer</code>. CPU and GPU.  <br /></td></tr>
<tr class="separator:a6c438ae28e65cd6d9c2f73610e45fcee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db9706ccab0a9816d5a59d6b3c0d046" id="r_a3db9706ccab0a9816d5a59d6b3c0d046"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcstone_1_1SpaceCurveAssignment.html">SpaceCurveAssignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a3db9706ccab0a9816d5a59d6b3c0d046">singleRangeSfcSplit</a> (const std::vector&lt; unsigned &gt; &amp;globalCounts, int nSplits)</td></tr>
<tr class="memdesc:a3db9706ccab0a9816d5a59d6b3c0d046"><td class="mdescLeft">&#160;</td><td class="mdescRight">assign the global tree/SFC to nSplits ranks, assigning to each rank only a single Morton code range  <br /></td></tr>
<tr class="separator:a3db9706ccab0a9816d5a59d6b3c0d046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058de6b372d77881570754bbb339a240" id="r_a058de6b372d77881570754bbb339a240"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a058de6b372d77881570754bbb339a240"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a058de6b372d77881570754bbb339a240">limitBoundaryShifts</a> (gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; oldBoundaries, gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; newTree, gsl::span&lt; const unsigned &gt; counts, <a class="el" href="classcstone_1_1SpaceCurveAssignment.html">SpaceCurveAssignment</a> &amp;newAssignment)</td></tr>
<tr class="memdesc:a058de6b372d77881570754bbb339a240"><td class="mdescLeft">&#160;</td><td class="mdescRight">limit SFC range assignment transfer to the domain of the rank above or below  <br /></td></tr>
<tr class="separator:a058de6b372d77881570754bbb339a240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f396c695e26b7edb950e4e9b8a8c71" id="r_aa1f396c695e26b7edb950e4e9b8a8c71"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:aa1f396c695e26b7edb950e4e9b8a8c71"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aa1f396c695e26b7edb950e4e9b8a8c71">translateAssignment</a> (const <a class="el" href="classcstone_1_1SpaceCurveAssignment.html">SpaceCurveAssignment</a> &amp;assignment, gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; domainTree, gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; focusTree, gsl::span&lt; const int &gt; peerRanks, int myRank, std::vector&lt; <a class="el" href="namespacecstone.html#ab92e8dfcff11066ac75330812a896de9">TreeIndexPair</a> &gt; &amp;focusAssignment)</td></tr>
<tr class="memdesc:aa1f396c695e26b7edb950e4e9b8a8c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">translates an assignment of a given tree to a new tree  <br /></td></tr>
<tr class="separator:aa1f396c695e26b7edb950e4e9b8a8c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1d20c97356ea707766c593d4556bf5" id="r_a9e1d20c97356ea707766c593d4556bf5"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a9e1d20c97356ea707766c593d4556bf5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcstone_1_1SendRanges.html">SendRanges</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a9e1d20c97356ea707766c593d4556bf5">createSendRanges</a> (const <a class="el" href="classcstone_1_1SpaceCurveAssignment.html">SpaceCurveAssignment</a> &amp;assignment, gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; treeLeaves, gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; particleKeys)</td></tr>
<tr class="memdesc:a9e1d20c97356ea707766c593d4556bf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Based on global assignment, create the list of local particle index ranges to send to each rank.  <br /></td></tr>
<tr class="separator:a9e1d20c97356ea707766c593d4556bf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb7e55212d2cf4f6037cc3789314ec9" id="r_a3fb7e55212d2cf4f6037cc3789314ec9"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a3fb7e55212d2cf4f6037cc3789314ec9"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a3fb7e55212d2cf4f6037cc3789314ec9">initialDomainSplits</a> (int numRanks, int level)</td></tr>
<tr class="memdesc:a3fb7e55212d2cf4f6037cc3789314ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight">return <code>numRanks</code> equal length SFC segments for initial domain decomposition  <br /></td></tr>
<tr class="separator:a3fb7e55212d2cf4f6037cc3789314ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d961aca810f7e594ae23c83407b24fe" id="r_a0d961aca810f7e594ae23c83407b24fe"><td class="memTemplParams" colspan="2">template&lt;size_t Alignment, class... Arrays&gt; </td></tr>
<tr class="memitem:a0d961aca810f7e594ae23c83407b24fe"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a0d961aca810f7e594ae23c83407b24fe">numElementsFit</a> (size_t numBytesAvail, Arrays... arrays)</td></tr>
<tr class="memdesc:a0d961aca810f7e594ae23c83407b24fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of elements of all <code>arrays</code> that fit into <code>numBytesAvail</code>  <br /></td></tr>
<tr class="separator:a0d961aca810f7e594ae23c83407b24fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6aaf222db0e48d8c2a6160e2cc434f7" id="r_af6aaf222db0e48d8c2a6160e2cc434f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#af6aaf222db0e48d8c2a6160e2cc434f7">encodeSendCountCpu</a> (uint64_t count, char *sendPtr)</td></tr>
<tr class="separator:af6aaf222db0e48d8c2a6160e2cc434f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09be5264e068c0b1d4056c4ebacdad55" id="r_a09be5264e068c0b1d4056c4ebacdad55"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a09be5264e068c0b1d4056c4ebacdad55"><td class="memTemplItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a09be5264e068c0b1d4056c4ebacdad55">decodeSendCountCpu</a> (T *recvPtr)</td></tr>
<tr class="separator:a09be5264e068c0b1d4056c4ebacdad55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178146e60b42107a4114bf81a9f3b126" id="r_a178146e60b42107a4114bf81a9f3b126"><td class="memTemplParams" colspan="2">template&lt;class... Arrays&gt; </td></tr>
<tr class="memitem:a178146e60b42107a4114bf81a9f3b126"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a178146e60b42107a4114bf81a9f3b126">exchangeParticles</a> (const <a class="el" href="classcstone_1_1SendRanges.html">SendRanges</a> &amp;sends, int thisRank, <a class="el" href="structcstone_1_1BufferDescription.html">BufferDescription</a> bufDesc, <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> numParticlesAssigned, const <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> *ordering, std::vector&lt; std::tuple&lt; int, <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> &gt; &gt; &amp;receiveLog, Arrays... arrays)</td></tr>
<tr class="memdesc:a178146e60b42107a4114bf81a9f3b126"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchange array elements with other ranks according to the specified ranges  <br /></td></tr>
<tr class="separator:a178146e60b42107a4114bf81a9f3b126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a968270cec25b6a39e8c67b262e9e0" id="r_a00a968270cec25b6a39e8c67b262e9e0"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a00a968270cec25b6a39e8c67b262e9e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcstone_1_1SendList.html">SendList</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a00a968270cec25b6a39e8c67b262e9e0">exchangeRequestKeys</a> (gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; treeLeaves, gsl::span&lt; const int &gt; haloFlags, gsl::span&lt; const <a class="el" href="namespacecstone.html#ab92e8dfcff11066ac75330812a896de9">TreeIndexPair</a> &gt; assignment, gsl::span&lt; const int &gt; peerRanks, gsl::span&lt; const <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> &gt; layout)</td></tr>
<tr class="memdesc:a00a968270cec25b6a39e8c67b262e9e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchange halo request keys, establish particle indices to send  <br /></td></tr>
<tr class="separator:a00a968270cec25b6a39e8c67b262e9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd1154189698f17192551fe9dc9ea20" id="r_a1bd1154189698f17192551fe9dc9ea20"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a1bd1154189698f17192551fe9dc9ea20">maxNumRanges</a> (const <a class="el" href="classcstone_1_1SendList.html">SendList</a> &amp;sendList)</td></tr>
<tr class="separator:a1bd1154189698f17192551fe9dc9ea20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a0aff1cf6863f5d6a6f32ebe071cde7" id="r_a9a0aff1cf6863f5d6a6f32ebe071cde7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structcstone_1_1IndexPair.html">IndexPair</a>&lt; <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a9a0aff1cf6863f5d6a6f32ebe071cde7">invertRanges</a> (<a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> first, gsl::span&lt; const <a class="el" href="structcstone_1_1IndexPair.html">IndexPair</a>&lt; <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt; &gt; ranges, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> last)</td></tr>
<tr class="memdesc:a9a0aff1cf6863f5d6a6f32ebe071cde7"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the complementary range of the input ranges  <br /></td></tr>
<tr class="separator:a9a0aff1cf6863f5d6a6f32ebe071cde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b792ce0fb408c428d0a85ff18450faa" id="r_a9b792ce0fb408c428d0a85ff18450faa"><td class="memTemplParams" colspan="2">template&lt;class IntegralType &gt; </td></tr>
<tr class="memitem:a9b792ce0fb408c428d0a85ff18450faa"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; IntegralType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a9b792ce0fb408c428d0a85ff18450faa">extractMarkedElements</a> (gsl::span&lt; const IntegralType &gt; source, gsl::span&lt; const int &gt; flags, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> firstReqIdx, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> secondReqIdx)</td></tr>
<tr class="memdesc:a9b792ce0fb408c428d0a85ff18450faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract ranges of marked indices from a source array  <br /></td></tr>
<tr class="separator:a9b792ce0fb408c428d0a85ff18450faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd9a12b3c41b32a4e7c33b380e821f6" id="r_a9fd9a12b3c41b32a4e7c33b380e821f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a9fd9a12b3c41b32a4e7c33b380e821f6">computeNodeLayout</a> (gsl::span&lt; const unsigned &gt; focusLeafCounts, gsl::span&lt; const int &gt; haloFlags, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> firstAssignedIdx, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> lastAssignedIdx, gsl::span&lt; <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> &gt; layout)</td></tr>
<tr class="memdesc:a9fd9a12b3c41b32a4e7c33b380e821f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the location (offset) of each focus tree leaf node in the particle arrays  <br /></td></tr>
<tr class="separator:a9fd9a12b3c41b32a4e7c33b380e821f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cde21101a4ca77d3499955752cf891" id="r_a40cde21101a4ca77d3499955752cf891"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcstone_1_1SendList.html">SendList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a40cde21101a4ca77d3499955752cf891">computeHaloReceiveList</a> (gsl::span&lt; const <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> &gt; layout, gsl::span&lt; const int &gt; haloFlags, gsl::span&lt; const <a class="el" href="namespacecstone.html#ab92e8dfcff11066ac75330812a896de9">TreeIndexPair</a> &gt; assignment, gsl::span&lt; const int &gt; peerRanks)</td></tr>
<tr class="memdesc:a40cde21101a4ca77d3499955752cf891"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes a list which local array ranges are going to be filled with halo particles  <br /></td></tr>
<tr class="separator:a40cde21101a4ca77d3499955752cf891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce198b4b6ced8fd1a9f4344cc1a4bd5" id="r_afce198b4b6ced8fd1a9f4344cc1a4bd5"><td class="memTemplParams" colspan="2">template&lt;class Gather , class... Arrays1, class... Arrays2&gt; </td></tr>
<tr class="memitem:afce198b4b6ced8fd1a9f4344cc1a4bd5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#afce198b4b6ced8fd1a9f4344cc1a4bd5">gatherArrays</a> (Gather &amp;&amp;gatherFunc, const <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> *ordering, <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> numElements, <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> inputOffset, <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> outputOffset, std::tuple&lt; Arrays1 &amp;... &gt; arrays, std::tuple&lt; Arrays2 &amp;... &gt; scratchBuffers)</td></tr>
<tr class="memdesc:afce198b4b6ced8fd1a9f4344cc1a4bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">reorder with state-less function object  <br /></td></tr>
<tr class="separator:afce198b4b6ced8fd1a9f4344cc1a4bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6a279c9f3ff35f7e544e43df2fbecc" id="r_a5e6a279c9f3ff35f7e544e43df2fbecc"><td class="memTemplParams" colspan="2">template&lt;class Array &gt; </td></tr>
<tr class="memitem:a5e6a279c9f3ff35f7e544e43df2fbecc"><td class="memTemplItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a5e6a279c9f3ff35f7e544e43df2fbecc">getFieldIndex</a> (std::string_view field, const Array &amp;fieldNames)</td></tr>
<tr class="memdesc:a5e6a279c9f3ff35f7e544e43df2fbecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">compile-time index look-up of a string literal in a list of strings  <br /></td></tr>
<tr class="separator:a5e6a279c9f3ff35f7e544e43df2fbecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227df32554320b609359fbbc4929461d" id="r_a227df32554320b609359fbbc4929461d"><td class="memTemplParams" colspan="2">template&lt;class Array &gt; </td></tr>
<tr class="memitem:a227df32554320b609359fbbc4929461d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a227df32554320b609359fbbc4929461d">fieldStringsToInt</a> (const std::vector&lt; std::string &gt; &amp;subsetNames, const Array &amp;allNames)</td></tr>
<tr class="memdesc:a227df32554320b609359fbbc4929461d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up indices of a (runtime-variable) number of field names.  <br /></td></tr>
<tr class="separator:a227df32554320b609359fbbc4929461d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6363d74bcfa471820a465ae60754ffe" id="r_ad6363d74bcfa471820a465ae60754ffe"><td class="memTemplParams" colspan="2">template&lt;class Dataset , class Tuple , util::StructuralString... Fields&gt; </td></tr>
<tr class="memitem:ad6363d74bcfa471820a465ae60754ffe"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ad6363d74bcfa471820a465ae60754ffe">getFields</a> (Tuple &amp;&amp;tuple, <a class="el" href="structutil_1_1FieldList.html">util::FieldList</a>&lt; Fields... &gt;)</td></tr>
<tr class="separator:ad6363d74bcfa471820a465ae60754ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25df0d24626d6a364cadd70014387b4" id="r_ab25df0d24626d6a364cadd70014387b4"><td class="memTemplParams" colspan="2">template&lt;util::StructuralString... Fields, class Dataset &gt; </td></tr>
<tr class="memitem:ab25df0d24626d6a364cadd70014387b4"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ab25df0d24626d6a364cadd70014387b4">getHost</a> (Dataset &amp;d)</td></tr>
<tr class="separator:ab25df0d24626d6a364cadd70014387b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1770c737077f5f1c3d66ed6e4e62a63" id="r_ab1770c737077f5f1c3d66ed6e4e62a63"><td class="memTemplParams" colspan="2">template&lt;util::StructuralString... Fields, class Dataset &gt; </td></tr>
<tr class="memitem:ab1770c737077f5f1c3d66ed6e4e62a63"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ab1770c737077f5f1c3d66ed6e4e62a63">getDevice</a> (Dataset &amp;d)</td></tr>
<tr class="separator:ab1770c737077f5f1c3d66ed6e4e62a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93b0f927e7ec08b1d4df35c12a3c5c37" id="r_a93b0f927e7ec08b1d4df35c12a3c5c37"><td class="memTemplParams" colspan="2">template&lt;class FL , class Dataset &gt; </td></tr>
<tr class="memitem:a93b0f927e7ec08b1d4df35c12a3c5c37"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a93b0f927e7ec08b1d4df35c12a3c5c37">get</a> (Dataset &amp;d)</td></tr>
<tr class="memdesc:a93b0f927e7ec08b1d4df35c12a3c5c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a tuple of references to the specified particle field indices, to GPU fields if GPU is enabled.  <br /></td></tr>
<tr class="separator:a93b0f927e7ec08b1d4df35c12a3c5c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b29471446ed343fcb2545e6aa4f1d3" id="r_ad8b29471446ed343fcb2545e6aa4f1d3"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structutil_1_1StructuralString.html">util::StructuralString</a> F, class Dataset , class Tuple , std::enable_if_t&lt; std::is_same_v&lt; void, <a class="el" href="namespaceutil.html#a3673b879f42d462272525a91b4eec1e2">util::void_value_t</a>&lt; Dataset::fieldNames.size()&gt; &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ad8b29471446ed343fcb2545e6aa4f1d3"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ad8b29471446ed343fcb2545e6aa4f1d3">get</a> (Tuple &amp;&amp;tup)</td></tr>
<tr class="memdesc:ad8b29471446ed343fcb2545e6aa4f1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a reference to the named field F from a tuple  <br /></td></tr>
<tr class="separator:ad8b29471446ed343fcb2545e6aa4f1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6435851940ec611425cb49b4d59960df" id="r_a6435851940ec611425cb49b4d59960df"><td class="memTemplParams" colspan="2">template&lt;class Tuple &gt; </td></tr>
<tr class="memitem:a6435851940ec611425cb49b4d59960df"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a6435851940ec611425cb49b4d59960df">getPointers</a> (Tuple &amp;&amp;tup, size_t i)</td></tr>
<tr class="memdesc:a6435851940ec611425cb49b4d59960df"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a tuple of pointers to element i of <code>tup</code> = tuple of vector-like containers  <br /></td></tr>
<tr class="separator:a6435851940ec611425cb49b4d59960df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40382c3f221c9b3c95c2604104530260" id="r_a40382c3f221c9b3c95c2604104530260"><td class="memTemplParams" colspan="2">template&lt;bool Pbc, class T , std::enable_if_t&lt; Pbc, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a40382c3f221c9b3c95c2604104530260"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a40382c3f221c9b3c95c2604104530260">distanceSq</a> (T x1, T y1, T z1, T x2, T y2, T z2, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box)</td></tr>
<tr class="memdesc:a40382c3f221c9b3c95c2604104530260"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute squared distance, taking PBC into account  <br /></td></tr>
<tr class="separator:a40382c3f221c9b3c95c2604104530260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188c5f6ee7d9d5fb7a3ad4e7e77b05a7" id="r_a188c5f6ee7d9d5fb7a3ad4e7e77b05a7"><td class="memTemplParams" colspan="2">template&lt;class Tc , class Th , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a188c5f6ee7d9d5fb7a3ad4e7e77b05a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a188c5f6ee7d9d5fb7a3ad4e7e77b05a7">findNeighbors</a> (<a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> i, const Tc *x, const Tc *y, const Tc *z, const Th *h, const <a class="el" href="structcstone_1_1OctreeNsView.html">OctreeNsView</a>&lt; Tc, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;tree, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; Tc &gt; &amp;box, unsigned ngmax, <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> *neighbors)</td></tr>
<tr class="memdesc:a188c5f6ee7d9d5fb7a3ad4e7e77b05a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">findNeighbors of particle number <code>id</code> within radius  <br /></td></tr>
<tr class="separator:a188c5f6ee7d9d5fb7a3ad4e7e77b05a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a70d2575b3198947f078dd92be37c20" id="r_a3a70d2575b3198947f078dd92be37c20"><td class="memTemplParams" colspan="2">template&lt;class T , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a3a70d2575b3198947f078dd92be37c20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a3a70d2575b3198947f078dd92be37c20">findNeighbors</a> (const T *x, const T *y, const T *z, const T *h, <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> firstId, <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> lastId, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box, const <a class="el" href="structcstone_1_1OctreeNsView.html">OctreeNsView</a>&lt; T, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;treeView, unsigned ngmax, <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> *neighbors, unsigned *neighborsCount)</td></tr>
<tr class="separator:a3a70d2575b3198947f078dd92be37c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f91481f971476236c3b2f21291daf0e" id="r_a9f91481f971476236c3b2f21291daf0e"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a9f91481f971476236c3b2f21291daf0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a9f91481f971476236c3b2f21291daf0e">countRequestParticles</a> (gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; leaves, gsl::span&lt; const unsigned &gt; counts, gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; requestLeaves, gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; prefixes, gsl::span&lt; const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt; levelRange, gsl::span&lt; unsigned &gt; requestCounts)</td></tr>
<tr class="memdesc:a9f91481f971476236c3b2f21291daf0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">count particles inside specified ranges of a cornerstone leaf tree  <br /></td></tr>
<tr class="separator:a9f91481f971476236c3b2f21291daf0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30449c51e61189b86fb0d2b5ee578c0" id="r_aa30449c51e61189b86fb0d2b5ee578c0"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:aa30449c51e61189b86fb0d2b5ee578c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aa30449c51e61189b86fb0d2b5ee578c0">exchangeTreelets</a> (gsl::span&lt; const int &gt; peerRanks, gsl::span&lt; const <a class="el" href="structcstone_1_1IndexPair.html">IndexPair</a>&lt; <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt; &gt; focusAssignment, gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; localLeaves, std::vector&lt; std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &gt; &amp;peerTrees, std::vector&lt; MPI_Request &gt; &amp;receiveRequests)</td></tr>
<tr class="memdesc:aa30449c51e61189b86fb0d2b5ee578c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchange subtree structures with peers  <br /></td></tr>
<tr class="separator:aa30449c51e61189b86fb0d2b5ee578c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f767b85fd6efedc6e75ba442a22eb3a" id="r_a5f767b85fd6efedc6e75ba442a22eb3a"><td class="memTemplParams" colspan="2">template&lt;class T , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a5f767b85fd6efedc6e75ba442a22eb3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a5f767b85fd6efedc6e75ba442a22eb3a">exchangeTreeletGeneral</a> (gsl::span&lt; const int &gt; peerRanks, const std::vector&lt; std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &gt; &amp;peerTrees, gsl::span&lt; const <a class="el" href="structcstone_1_1IndexPair.html">IndexPair</a>&lt; <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt; &gt; focusAssignment, gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; prefixes, gsl::span&lt; const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt; levelRange, gsl::span&lt; const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt; csToInternalMap, gsl::span&lt; T &gt; quantities, int commTag)</td></tr>
<tr class="separator:a5f767b85fd6efedc6e75ba442a22eb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a612f0b7ed2351d01753c64255f5bc" id="r_ae8a612f0b7ed2351d01753c64255f5bc"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:ae8a612f0b7ed2351d01753c64255f5bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ae8a612f0b7ed2351d01753c64255f5bc">focusTransfer</a> (gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; cstree, gsl::span&lt; const unsigned &gt; counts, unsigned bucketSize, int myRank, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> oldFocusStart, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> oldFocusEnd, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> newFocusStart, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> newFocusEnd, std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;buffer)</td></tr>
<tr class="memdesc:ae8a612f0b7ed2351d01753c64255f5bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass on focus tree parts from old owners to new owners.  <br /></td></tr>
<tr class="separator:ae8a612f0b7ed2351d01753c64255f5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b72eeeddc9b4ff6d9e66b5551d93a4" id="r_a26b72eeeddc9b4ff6d9e66b5551d93a4"><td class="memTemplParams" colspan="2">template&lt;class Q , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T , class F , class Accelerator , class... UArgs&gt; </td></tr>
<tr class="memitem:a26b72eeeddc9b4ff6d9e66b5551d93a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a26b72eeeddc9b4ff6d9e66b5551d93a4">globalFocusExchange</a> (const <a class="el" href="classcstone_1_1Octree.html">Octree</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;globalOctree, const <a class="el" href="classcstone_1_1FocusedOctree.html">FocusedOctree</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>, T, Accelerator &gt; &amp;focusTree, gsl::span&lt; Q &gt; quantities, F &amp;&amp;upsweepFunction, UArgs &amp;&amp;... upsweepArgs)</td></tr>
<tr class="memdesc:a26b72eeeddc9b4ff6d9e66b5551d93a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">exchange data of non-peer (beyond focus) tree cells  <br /></td></tr>
<tr class="separator:a26b72eeeddc9b4ff6d9e66b5551d93a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7d6cc236e3956657901f7485eaa804" id="r_a6a7d6cc236e3956657901f7485eaa804"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a6a7d6cc236e3956657901f7485eaa804"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a6a7d6cc236e3956657901f7485eaa804">mergeCountAndMacOp</a> (<a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> nodeIdx, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *nodeKeys, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *childOffsets, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *parents, const unsigned *counts, const char *macs, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> focusStart, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> focusEnd, unsigned bucketSize)</td></tr>
<tr class="memdesc:a6a7d6cc236e3956657901f7485eaa804"><td class="mdescLeft">&#160;</td><td class="mdescRight">combines the particle count and multipole criteria for rebalancing  <br /></td></tr>
<tr class="separator:a6a7d6cc236e3956657901f7485eaa804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f257ac711f6ef81c1dfe2107cbf4ff2" id="r_a4f257ac711f6ef81c1dfe2107cbf4ff2"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a4f257ac711f6ef81c1dfe2107cbf4ff2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a4f257ac711f6ef81c1dfe2107cbf4ff2">nzAncestorOp</a> (<a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> nodeIdx, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *prefixes, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *parents, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *nodeOps)</td></tr>
<tr class="memdesc:a4f257ac711f6ef81c1dfe2107cbf4ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overrides a 0-value of nodeOps[nodeIdx] if <code>nodeIdx</code> is the left-most descendant of a non-zero ancestor.  <br /></td></tr>
<tr class="separator:a4f257ac711f6ef81c1dfe2107cbf4ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa714a728fc64746d0b4258a372aee6e9" id="r_aa714a728fc64746d0b4258a372aee6e9"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:aa714a728fc64746d0b4258a372aee6e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aa714a728fc64746d0b4258a372aee6e9">rebalanceDecisionEssential</a> (gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; nodeKeys, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *childOffsets, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *parents, const unsigned *counts, const char *macs, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> focusStart, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> focusEnd, unsigned bucketSize, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *nodeOps)</td></tr>
<tr class="memdesc:aa714a728fc64746d0b4258a372aee6e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute locally essential split or fuse decision for each octree node in parallel.  <br /></td></tr>
<tr class="separator:aa714a728fc64746d0b4258a372aee6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2b4ac1679226c9f319e0856f165d90" id="r_a6c2b4ac1679226c9f319e0856f165d90"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a6c2b4ac1679226c9f319e0856f165d90"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a6c2b4ac1679226c9f319e0856f165d90">protectAncestors</a> (gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; nodeKeys, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *parents, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *nodeOps)</td></tr>
<tr class="separator:a6c2b4ac1679226c9f319e0856f165d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af89f00e258c0348bcc7df1ad1c664d17" id="r_af89f00e258c0348bcc7df1ad1c664d17"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:af89f00e258c0348bcc7df1ad1c664d17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a388434742a2abebe943b6f5445e6732b">ResolutionStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#af89f00e258c0348bcc7df1ad1c664d17">enforceKeySingle</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> key, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *nodeKeys, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *childOffsets, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *parents, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *nodeOps)</td></tr>
<tr class="separator:af89f00e258c0348bcc7df1ad1c664d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cdd497661db752b18566752aeaf781" id="r_ab3cdd497661db752b18566752aeaf781"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:ab3cdd497661db752b18566752aeaf781"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecstone.html#a388434742a2abebe943b6f5445e6732b">ResolutionStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ab3cdd497661db752b18566752aeaf781">enforceKeys</a> (gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; mandatoryKeys, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *nodeKeys, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *childOffsets, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *parents, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *nodeOps)</td></tr>
<tr class="separator:ab3cdd497661db752b18566752aeaf781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67378828dfbab190ed20b44b4951d7f1" id="r_a67378828dfbab190ed20b44b4951d7f1"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class Alloc &gt; </td></tr>
<tr class="memitem:a67378828dfbab190ed20b44b4951d7f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a67378828dfbab190ed20b44b4951d7f1">injectKeys</a> (std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>, Alloc &gt; &amp;tree, gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; keys)</td></tr>
<tr class="memdesc:a67378828dfbab190ed20b44b4951d7f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">inject specified keys into a cornerstone leaf tree  <br /></td></tr>
<tr class="separator:a67378828dfbab190ed20b44b4951d7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3449f787ec814ea5b9313f2dd74de7" id="r_adb3449f787ec814ea5b9313f2dd74de7"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:adb3449f787ec814ea5b9313f2dd74de7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#adb3449f787ec814ea5b9313f2dd74de7">rebalanceDecisionEssentialGpu</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *prefixes, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *childOffsets, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *parents, const unsigned *counts, const char *macs, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> focusStart, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> focusEnd, unsigned bucketSize, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *nodeOps, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> numNodes)</td></tr>
<tr class="separator:adb3449f787ec814ea5b9313f2dd74de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef64cd9d40e71e96389fd38df2a624b" id="r_a9ef64cd9d40e71e96389fd38df2a624b"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a9ef64cd9d40e71e96389fd38df2a624b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a9ef64cd9d40e71e96389fd38df2a624b">protectAncestorsGpu</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>)</td></tr>
<tr class="separator:a9ef64cd9d40e71e96389fd38df2a624b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93a49739c3550acda549f8711319add" id="r_aa93a49739c3550acda549f8711319add"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:aa93a49739c3550acda549f8711319add"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecstone.html#a388434742a2abebe943b6f5445e6732b">ResolutionStatus</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aa93a49739c3550acda549f8711319add">enforceKeysGpu</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *forcedKeys, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> numForcedKeys, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *nodeKeys, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *childOffsets, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *parents, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *nodeOps)</td></tr>
<tr class="separator:aa93a49739c3550acda549f8711319add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb12a092d7e1b2024a8a952922e3ff29" id="r_acb12a092d7e1b2024a8a952922e3ff29"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acb12a092d7e1b2024a8a952922e3ff29"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#acb12a092d7e1b2024a8a952922e3ff29">addBody</a> (<a class="el" href="namespacecstone.html#a3767e831204a1a7e180456eced6d15e5">SourceCenterType</a>&lt; T &gt; &amp;center, const <a class="el" href="namespacecstone.html#a3767e831204a1a7e180456eced6d15e5">SourceCenterType</a>&lt; T &gt; &amp;source)</td></tr>
<tr class="memdesc:acb12a092d7e1b2024a8a952922e3ff29"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a single body contribution to a mass center  <br /></td></tr>
<tr class="separator:acb12a092d7e1b2024a8a952922e3ff29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb66a196d6e8bb727fd847dd1aff9b7a" id="r_acb66a196d6e8bb727fd847dd1aff9b7a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:acb66a196d6e8bb727fd847dd1aff9b7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a3767e831204a1a7e180456eced6d15e5">SourceCenterType</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#acb66a196d6e8bb727fd847dd1aff9b7a">normalizeMass</a> (<a class="el" href="namespacecstone.html#a3767e831204a1a7e180456eced6d15e5">SourceCenterType</a>&lt; T &gt; center)</td></tr>
<tr class="memdesc:acb66a196d6e8bb727fd847dd1aff9b7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">finish mass center computation by diving coordinates by total mass  <br /></td></tr>
<tr class="separator:acb66a196d6e8bb727fd847dd1aff9b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff03f64859fe8445a281bc6a7d7d0e70" id="r_aff03f64859fe8445a281bc6a7d7d0e70"><td class="memTemplParams" colspan="2">template&lt;class Ts , class Tc , class Tm &gt; </td></tr>
<tr class="memitem:aff03f64859fe8445a281bc6a7d7d0e70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a3767e831204a1a7e180456eced6d15e5">SourceCenterType</a>&lt; Ts &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aff03f64859fe8445a281bc6a7d7d0e70">massCenter</a> (const Tc *x, const Tc *y, const Tc *z, const Tm *m, <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> first, <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> last)</td></tr>
<tr class="memdesc:aff03f64859fe8445a281bc6a7d7d0e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute a mass center from particles  <br /></td></tr>
<tr class="separator:aff03f64859fe8445a281bc6a7d7d0e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3e9f74e4a895b164eb4fc56d67548a" id="r_a5a3e9f74e4a895b164eb4fc56d67548a"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class T3 &gt; </td></tr>
<tr class="memitem:a5a3e9f74e4a895b164eb4fc56d67548a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a5a3e9f74e4a895b164eb4fc56d67548a">computeLeafMassCenter</a> (gsl::span&lt; const T1 &gt; x, gsl::span&lt; const T1 &gt; y, gsl::span&lt; const T1 &gt; z, gsl::span&lt; const T2 &gt; m, gsl::span&lt; const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt; <a class="el" href="namespacecstone.html#a9c12e16cab4a89d81bc2e07ac2c2f9f3">leafToInternal</a>, const <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> *layout, <a class="el" href="namespacecstone.html#a3767e831204a1a7e180456eced6d15e5">SourceCenterType</a>&lt; T3 &gt; *sourceCenter)</td></tr>
<tr class="memdesc:a5a3e9f74e4a895b164eb4fc56d67548a"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute mass center coordinates for leaf nodes  <br /></td></tr>
<tr class="separator:a5a3e9f74e4a895b164eb4fc56d67548a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2de04bb3f7d8aa6876a84711d8476e" id="r_a1f2de04bb3f7d8aa6876a84711d8476e"><td class="memTemplParams" colspan="2">template&lt;class T , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a1f2de04bb3f7d8aa6876a84711d8476e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a1f2de04bb3f7d8aa6876a84711d8476e">setMac</a> (gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; nodeKeys, gsl::span&lt; <a class="el" href="namespacecstone.html#a3767e831204a1a7e180456eced6d15e5">SourceCenterType</a>&lt; T &gt; &gt; centers, float invTheta, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box)</td></tr>
<tr class="memdesc:a1f2de04bb3f7d8aa6876a84711d8476e"><td class="mdescLeft">&#160;</td><td class="mdescRight">replace the last center element (mass) with the squared mac radius  <br /></td></tr>
<tr class="separator:a1f2de04bb3f7d8aa6876a84711d8476e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7368a509c88737ec8a557403c1fdec" id="r_abe7368a509c88737ec8a557403c1fdec"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </td></tr>
<tr class="memitem:abe7368a509c88737ec8a557403c1fdec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#abe7368a509c88737ec8a557403c1fdec">nodeFpCenters</a> (gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; prefixes, <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; *centers, <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; *sizes, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box)</td></tr>
<tr class="memdesc:abe7368a509c88737ec8a557403c1fdec"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute geometric node centers based on node SFC keys and the global bounding box  <br /></td></tr>
<tr class="separator:abe7368a509c88737ec8a557403c1fdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f786caffb83a2c5348c9f98a8290e6c" id="r_a7f786caffb83a2c5348c9f98a8290e6c"><td class="memTemplParams" colspan="2">template&lt;class Tc , class Tm , class Tf &gt; </td></tr>
<tr class="memitem:a7f786caffb83a2c5348c9f98a8290e6c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a7f786caffb83a2c5348c9f98a8290e6c">computeLeafSourceCenterGpu</a> (const Tc *x, const Tc *y, const Tc *z, const Tm *m, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *<a class="el" href="namespacecstone.html#a9c12e16cab4a89d81bc2e07ac2c2f9f3">leafToInternal</a>, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> numLeaves, const <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> *layout, <a class="el" href="namespacecstone.html#a3c2b5abd635257ad027f958158d2ae21">Vec4</a>&lt; Tf &gt; *centers)</td></tr>
<tr class="memdesc:a7f786caffb83a2c5348c9f98a8290e6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute mass centers of leaf cells  <br /></td></tr>
<tr class="separator:a7f786caffb83a2c5348c9f98a8290e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12e79798529918fb410f00377196713" id="r_ae12e79798529918fb410f00377196713"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ae12e79798529918fb410f00377196713"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ae12e79798529918fb410f00377196713">upsweepCentersGpu</a> (int numLevels, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *levelRange, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *childOffsets, <a class="el" href="namespacecstone.html#a3767e831204a1a7e180456eced6d15e5">SourceCenterType</a>&lt; T &gt; *centers)</td></tr>
<tr class="memdesc:ae12e79798529918fb410f00377196713"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute center of gravity for internal nodes with an upsweep  <br /></td></tr>
<tr class="separator:ae12e79798529918fb410f00377196713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8165efc91b4a594d357eb3ef12702de6" id="r_a8165efc91b4a594d357eb3ef12702de6"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </td></tr>
<tr class="memitem:a8165efc91b4a594d357eb3ef12702de6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a8165efc91b4a594d357eb3ef12702de6">computeGeoCentersGpu</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *prefixes, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> numNodes, <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; *centers, <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; *sizes, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box)</td></tr>
<tr class="memdesc:a8165efc91b4a594d357eb3ef12702de6"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute geometric node center and sizes based on node SFC keys  <br /></td></tr>
<tr class="separator:a8165efc91b4a594d357eb3ef12702de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0122e33f79e345ef446fa458c7f223b9" id="r_a0122e33f79e345ef446fa458c7f223b9"><td class="memTemplParams" colspan="2">template&lt;class... Arrays&gt; </td></tr>
<tr class="memitem:a0122e33f79e345ef446fa458c7f223b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a0122e33f79e345ef446fa458c7f223b9">haloexchange</a> (int epoch, const <a class="el" href="classcstone_1_1SendList.html">SendList</a> &amp;incomingHalos, const <a class="el" href="classcstone_1_1SendList.html">SendList</a> &amp;outgoingHalos, Arrays... arrays)</td></tr>
<tr class="separator:a0122e33f79e345ef446fa458c7f223b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab864d92d59ef7c63c43621a4817fa427" id="r_ab864d92d59ef7c63c43621a4817fa427"><td class="memTemplParams" colspan="2">template&lt;class T , class IndexType &gt; </td></tr>
<tr class="memitem:ab864d92d59ef7c63c43621a4817fa427"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ab864d92d59ef7c63c43621a4817fa427">gatherRanges</a> (const IndexType *rangeScan, const IndexType *rangeOffsets, int numRanges, const T *src, T *buffer, size_t bufferSize)</td></tr>
<tr class="separator:ab864d92d59ef7c63c43621a4817fa427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192615b23fc8f7f187589b44bef872b8" id="r_a192615b23fc8f7f187589b44bef872b8"><td class="memTemplParams" colspan="2">template&lt;class T , class IndexType &gt; </td></tr>
<tr class="memitem:a192615b23fc8f7f187589b44bef872b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a192615b23fc8f7f187589b44bef872b8">scatterRanges</a> (const IndexType *rangeScan, const IndexType *rangeOffsets, int numRanges, T *dest, const T *buffer, size_t bufferSize)</td></tr>
<tr class="separator:a192615b23fc8f7f187589b44bef872b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc95690c1f0df3bc885c46a5ac068311" id="r_abc95690c1f0df3bc885c46a5ac068311"><td class="memTemplParams" colspan="2">template&lt;class DevVec1 , class DevVec2 , class... Arrays&gt; </td></tr>
<tr class="memitem:abc95690c1f0df3bc885c46a5ac068311"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#abc95690c1f0df3bc885c46a5ac068311">haloExchangeGpu</a> (int epoch, const <a class="el" href="classcstone_1_1SendList.html">SendList</a> &amp;incomingHalos, const <a class="el" href="classcstone_1_1SendList.html">SendList</a> &amp;outgoingHalos, DevVec1 &amp;sendScratchBuffer, DevVec2 &amp;receiveScratchBuffer, Arrays... arrays)</td></tr>
<tr class="separator:abc95690c1f0df3bc885c46a5ac068311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af265e7e15a2ec8efa2e0c003acaac616" id="r_af265e7e15a2ec8efa2e0c003acaac616"><td class="memTemplParams" colspan="2">template&lt;class InoutIterator , class OutputIterator , class Compare &gt; </td></tr>
<tr class="memitem:af265e7e15a2ec8efa2e0c003acaac616"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#af265e7e15a2ec8efa2e0c003acaac616">sort_by_key</a> (InoutIterator keyBegin, InoutIterator keyEnd, OutputIterator valueBegin, Compare compare)</td></tr>
<tr class="memdesc:af265e7e15a2ec8efa2e0c003acaac616"><td class="mdescLeft">&#160;</td><td class="mdescRight">sort values according to a key  <br /></td></tr>
<tr class="separator:af265e7e15a2ec8efa2e0c003acaac616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87dac531bf09977046c7e254522e3250" id="r_a87dac531bf09977046c7e254522e3250"><td class="memTemplParams" colspan="2">template&lt;class InoutIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:a87dac531bf09977046c7e254522e3250"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a87dac531bf09977046c7e254522e3250">sort_by_key</a> (InoutIterator inBegin, InoutIterator inEnd, OutputIterator outBegin)</td></tr>
<tr class="memdesc:a87dac531bf09977046c7e254522e3250"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the sortKey that sorts the input sequence, default ascending order  <br /></td></tr>
<tr class="separator:a87dac531bf09977046c7e254522e3250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc6a11f3c77f13d55976dacaf86862b" id="r_aedc6a11f3c77f13d55976dacaf86862b"><td class="memTemplParams" colspan="2">template&lt;class InputIterator , class OutputIterator &gt; </td></tr>
<tr class="memitem:aedc6a11f3c77f13d55976dacaf86862b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aedc6a11f3c77f13d55976dacaf86862b">omp_copy</a> (InputIterator first, InputIterator last, OutputIterator out)</td></tr>
<tr class="memdesc:aedc6a11f3c77f13d55976dacaf86862b"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy with multiple OpenMP threads  <br /></td></tr>
<tr class="separator:aedc6a11f3c77f13d55976dacaf86862b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc44a01e05969aefa3493a1cc38755f" id="r_a6fc44a01e05969aefa3493a1cc38755f"><td class="memTemplParams" colspan="2">template&lt;class IndexType , class ValueType &gt; </td></tr>
<tr class="memitem:a6fc44a01e05969aefa3493a1cc38755f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a6fc44a01e05969aefa3493a1cc38755f">gather</a> (gsl::span&lt; const IndexType &gt; ordering, const ValueType *source, ValueType *destination)</td></tr>
<tr class="memdesc:a6fc44a01e05969aefa3493a1cc38755f"><td class="mdescLeft">&#160;</td><td class="mdescRight">gather reorder  <br /></td></tr>
<tr class="separator:a6fc44a01e05969aefa3493a1cc38755f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a936a255f2dc7870c011b659cc5e0b1ec" id="r_a936a255f2dc7870c011b659cc5e0b1ec"><td class="memTemplParams" colspan="2">template&lt;class IndexType , class ValueType &gt; </td></tr>
<tr class="memitem:a936a255f2dc7870c011b659cc5e0b1ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a936a255f2dc7870c011b659cc5e0b1ec">scatter</a> (gsl::span&lt; const IndexType &gt; ordering, const ValueType *source, ValueType *destination)</td></tr>
<tr class="memdesc:a936a255f2dc7870c011b659cc5e0b1ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">scatter reorder  <br /></td></tr>
<tr class="separator:a936a255f2dc7870c011b659cc5e0b1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a572ff0054fe71fa407673f3eab291a" id="r_a4a572ff0054fe71fa407673f3eab291a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a4a572ff0054fe71fa407673f3eab291a">iceil</a> (size_t dividend, unsigned divisor)</td></tr>
<tr class="memdesc:a4a572ff0054fe71fa407673f3eab291a"><td class="mdescLeft">&#160;</td><td class="mdescRight">ceil(dividend/divisor) for unsigned integers  <br /></td></tr>
<tr class="separator:a4a572ff0054fe71fa407673f3eab291a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8903485c9d64446ad1959c2babeb8085" id="r_a8903485c9d64446ad1959c2babeb8085"><td class="memItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a8903485c9d64446ad1959c2babeb8085">round_up</a> (size_t n, unsigned m)</td></tr>
<tr class="memdesc:a8903485c9d64446ad1959c2babeb8085"><td class="mdescLeft">&#160;</td><td class="mdescRight">round up <code>n</code> to multiple of <code>m</code>  <br /></td></tr>
<tr class="separator:a8903485c9d64446ad1959c2babeb8085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698640650664806a4e1cb8c953715fc2" id="r_a698640650664806a4e1cb8c953715fc2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a698640650664806a4e1cb8c953715fc2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a698640650664806a4e1cb8c953715fc2">fillGpu</a> (T *first, T *last, T value)</td></tr>
<tr class="separator:a698640650664806a4e1cb8c953715fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b486f0ab3931822b00ae976aadb932e" id="r_a7b486f0ab3931822b00ae976aadb932e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7b486f0ab3931822b00ae976aadb932e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a7b486f0ab3931822b00ae976aadb932e">scaleGpu</a> (T *first, T *last, T value)</td></tr>
<tr class="separator:a7b486f0ab3931822b00ae976aadb932e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297a9d4fedfb90e8f3e614a666fb2fb0" id="r_a297a9d4fedfb90e8f3e614a666fb2fb0"><td class="memTemplParams" colspan="2">template&lt;class T , class IndexType &gt; </td></tr>
<tr class="memitem:a297a9d4fedfb90e8f3e614a666fb2fb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a297a9d4fedfb90e8f3e614a666fb2fb0">gatherGpu</a> (const IndexType *ordering, size_t numElements, const T *src, T *buffer)</td></tr>
<tr class="separator:a297a9d4fedfb90e8f3e614a666fb2fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6c5d79a62a2faece2dfd25ecff4123" id="r_a7a6c5d79a62a2faece2dfd25ecff4123"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7a6c5d79a62a2faece2dfd25ecff4123"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a7a6c5d79a62a2faece2dfd25ecff4123">maxNormSquareGpu</a> (const T *x, const T *y, const T *z, size_t numElements)</td></tr>
<tr class="separator:a7a6c5d79a62a2faece2dfd25ecff4123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27585a7935f94c50cc6741628054ffc8" id="r_a27585a7935f94c50cc6741628054ffc8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a27585a7935f94c50cc6741628054ffc8"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a27585a7935f94c50cc6741628054ffc8">lowerBoundGpu</a> (const T *first, const T *last, T value)</td></tr>
<tr class="separator:a27585a7935f94c50cc6741628054ffc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c05889c82ed9b4f99fc8652ec4e92a8" id="r_a2c05889c82ed9b4f99fc8652ec4e92a8"><td class="memTemplParams" colspan="2">template&lt;class T , class IndexType &gt; </td></tr>
<tr class="memitem:a2c05889c82ed9b4f99fc8652ec4e92a8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a2c05889c82ed9b4f99fc8652ec4e92a8">lowerBoundGpu</a> (const T *first, const T *last, const T *valueFirst, const T *valueLast, IndexType *result)</td></tr>
<tr class="separator:a2c05889c82ed9b4f99fc8652ec4e92a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0cc274b41e52039951d6ade0fd9ef5" id="r_a4d0cc274b41e52039951d6ade0fd9ef5"><td class="memTemplParams" colspan="2">template&lt;class Tin , class Tout , class IndexType &gt; </td></tr>
<tr class="memitem:a4d0cc274b41e52039951d6ade0fd9ef5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a4d0cc274b41e52039951d6ade0fd9ef5">segmentMax</a> (const Tin *input, const IndexType *segments, size_t numSegments, Tout *output)</td></tr>
<tr class="memdesc:a4d0cc274b41e52039951d6ade0fd9ef5"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine maximum elements in an array divided into multiple segments  <br /></td></tr>
<tr class="separator:a4d0cc274b41e52039951d6ade0fd9ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17dd0c7ff6a33d06e97f40ea93de14df" id="r_a17dd0c7ff6a33d06e97f40ea93de14df"><td class="memTemplParams" colspan="2">template&lt;class Tin , class Tout &gt; </td></tr>
<tr class="memitem:a17dd0c7ff6a33d06e97f40ea93de14df"><td class="memTemplItemLeft" align="right" valign="top">Tout&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a17dd0c7ff6a33d06e97f40ea93de14df">reduceGpu</a> (const Tin *input, size_t numElements, Tout init)</td></tr>
<tr class="separator:a17dd0c7ff6a33d06e97f40ea93de14df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5f3165630928bf87004240cfd521d3" id="r_a1e5f3165630928bf87004240cfd521d3"><td class="memTemplParams" colspan="2">template&lt;class IndexType &gt; </td></tr>
<tr class="memitem:a1e5f3165630928bf87004240cfd521d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a1e5f3165630928bf87004240cfd521d3">sequenceGpu</a> (IndexType *input, size_t numElements, IndexType init)</td></tr>
<tr class="separator:a1e5f3165630928bf87004240cfd521d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837a7f0c8f24b32e041018d43116d724" id="r_a837a7f0c8f24b32e041018d43116d724"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class ValueType &gt; </td></tr>
<tr class="memitem:a837a7f0c8f24b32e041018d43116d724"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a837a7f0c8f24b32e041018d43116d724">sortByKeyGpu</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *first, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *last, ValueType *values, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *keyBuf, ValueType *valueBuf)</td></tr>
<tr class="separator:a837a7f0c8f24b32e041018d43116d724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad732f7405445b02189e1104fa17690b1" id="r_ad732f7405445b02189e1104fa17690b1"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class ValueType &gt; </td></tr>
<tr class="memitem:ad732f7405445b02189e1104fa17690b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ad732f7405445b02189e1104fa17690b1">sortByKeyGpu</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *first, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *last, ValueType *values)</td></tr>
<tr class="separator:ad732f7405445b02189e1104fa17690b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ca39fb979e388c402811cde2907386" id="r_a63ca39fb979e388c402811cde2907386"><td class="memTemplParams" colspan="2">template&lt;class IndexType , class SumType &gt; </td></tr>
<tr class="memitem:a63ca39fb979e388c402811cde2907386"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a63ca39fb979e388c402811cde2907386">exclusiveScanGpu</a> (const IndexType *first, const IndexType *last, SumType *output, SumType init)</td></tr>
<tr class="separator:a63ca39fb979e388c402811cde2907386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a121ee051352297c57210243f4a9cc68f" id="r_a121ee051352297c57210243f4a9cc68f"><td class="memTemplParams" colspan="2">template&lt;class IndexType , class SumType &gt; </td></tr>
<tr class="memitem:a121ee051352297c57210243f4a9cc68f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a121ee051352297c57210243f4a9cc68f">exclusiveScanGpu</a> (const IndexType *first, const IndexType *last, SumType *output)</td></tr>
<tr class="separator:a121ee051352297c57210243f4a9cc68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2538a5139580d11da28a522a00231453" id="r_a2538a5139580d11da28a522a00231453"><td class="memTemplParams" colspan="2">template&lt;class ValueType &gt; </td></tr>
<tr class="memitem:a2538a5139580d11da28a522a00231453"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a2538a5139580d11da28a522a00231453">countGpu</a> (const ValueType *first, const ValueType *last, ValueType v)</td></tr>
<tr class="separator:a2538a5139580d11da28a522a00231453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb4e95e663e6c702975822c043c8bd0" id="r_acdb4e95e663e6c702975822c043c8bd0"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:acdb4e95e663e6c702975822c043c8bd0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#acdb4e95e663e6c702975822c043c8bd0">exclusiveScan</a> (const T1 *in, T2 *out, size_t numElements)</td></tr>
<tr class="memdesc:acdb4e95e663e6c702975822c043c8bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">multi-threaded exclusive scan (prefix sum) implementation  <br /></td></tr>
<tr class="separator:acdb4e95e663e6c702975822c043c8bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b09b85b484553f55da84e024e413389" id="r_a7b09b85b484553f55da84e024e413389"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7b09b85b484553f55da84e024e413389"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a7b09b85b484553f55da84e024e413389">exclusiveScanSerialInplace</a> (T *out, size_t num_elements, T init)</td></tr>
<tr class="separator:a7b09b85b484553f55da84e024e413389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30135a440b8f0b44257a76002137041" id="r_aa30135a440b8f0b44257a76002137041"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa30135a440b8f0b44257a76002137041"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aa30135a440b8f0b44257a76002137041">exclusiveScan</a> (T *out, size_t numElements)</td></tr>
<tr class="separator:aa30135a440b8f0b44257a76002137041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac095f0a0465d7704f9837a6d8d00e2bf" id="r_ac095f0a0465d7704f9837a6d8d00e2bf"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac095f0a0465d7704f9837a6d8d00e2bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ac095f0a0465d7704f9837a6d8d00e2bf">normalize</a> (T d, T min, T max)</td></tr>
<tr class="memdesc:ac095f0a0465d7704f9837a6d8d00e2bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">normalize a spatial length w.r.t. to a min/max range  <br /></td></tr>
<tr class="separator:ac095f0a0465d7704f9837a6d8d00e2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a2dce1b58e7b191458e54c806104633" id="r_a8a2dce1b58e7b191458e54c806104633"><td class="memTemplParams" colspan="2">template&lt;int R&gt; </td></tr>
<tr class="memitem:a8a2dce1b58e7b191458e54c806104633"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a8a2dce1b58e7b191458e54c806104633">pbcAdjust</a> (int x)</td></tr>
<tr class="memdesc:a8a2dce1b58e7b191458e54c806104633"><td class="mdescLeft">&#160;</td><td class="mdescRight">map x into periodic range 0...R-1  <br /></td></tr>
<tr class="separator:a8a2dce1b58e7b191458e54c806104633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba18e6aab18c5f0526b4ac1d8a362071" id="r_aba18e6aab18c5f0526b4ac1d8a362071"><td class="memTemplParams" colspan="2">template&lt;int R&gt; </td></tr>
<tr class="memitem:aba18e6aab18c5f0526b4ac1d8a362071"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aba18e6aab18c5f0526b4ac1d8a362071">pbcDistance</a> (int x)</td></tr>
<tr class="memdesc:aba18e6aab18c5f0526b4ac1d8a362071"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps x into the range [-R/2+1: R/2+1] (-511 to 512 with R = 1024)  <br /></td></tr>
<tr class="separator:aba18e6aab18c5f0526b4ac1d8a362071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d48aeeaa166d7d207d93e702cd67736" id="r_a5d48aeeaa166d7d207d93e702cd67736"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5d48aeeaa166d7d207d93e702cd67736"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a5d48aeeaa166d7d207d93e702cd67736">applyPbc</a> (<a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; dX, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box)</td></tr>
<tr class="memdesc:a5d48aeeaa166d7d207d93e702cd67736"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the shortest periodic distance dX = A - B between two points,.  <br /></td></tr>
<tr class="separator:a5d48aeeaa166d7d207d93e702cd67736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c66fac2dfa8a2f60a9a8717039c573" id="r_a36c66fac2dfa8a2f60a9a8717039c573"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a36c66fac2dfa8a2f60a9a8717039c573"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a36c66fac2dfa8a2f60a9a8717039c573">putInBox</a> (<a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; X, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box)</td></tr>
<tr class="memdesc:a36c66fac2dfa8a2f60a9a8717039c573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fold X into a periodic image that lies inside <em>box</em>.  <br /></td></tr>
<tr class="separator:a36c66fac2dfa8a2f60a9a8717039c573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf6861918ed045b01aed162da49c0ca" id="r_a3bf6861918ed045b01aed162da49c0ca"><td class="memTemplParams" colspan="2">template&lt;class Tc , class T &gt; </td></tr>
<tr class="memitem:a3bf6861918ed045b01aed162da49c0ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a3bf6861918ed045b01aed162da49c0ca">applyPBC</a> (const <a class="el" href="classcstone_1_1Box.html">cstone::Box</a>&lt; Tc &gt; &amp;box, T r, T &amp;xx, T &amp;yy, T &amp;zz)</td></tr>
<tr class="memdesc:a3bf6861918ed045b01aed162da49c0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legacy PBC.  <br /></td></tr>
<tr class="separator:a3bf6861918ed045b01aed162da49c0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f584269a1300d63b860188b4e08d20" id="r_a47f584269a1300d63b860188b4e08d20"><td class="memTemplParams" colspan="2">template&lt;class Tc , class T &gt; </td></tr>
<tr class="memitem:a47f584269a1300d63b860188b4e08d20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a47f584269a1300d63b860188b4e08d20">distancePBC</a> (const <a class="el" href="classcstone_1_1Box.html">cstone::Box</a>&lt; Tc &gt; &amp;box, T hi, Tc x1, Tc y1, Tc z1, Tc x2, Tc y2, Tc z2)</td></tr>
<tr class="separator:a47f584269a1300d63b860188b4e08d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c911adec30af9bcf3f090a02967c1b" id="r_ab0c911adec30af9bcf3f090a02967c1b"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </td></tr>
<tr class="memitem:ab0c911adec30af9bcf3f090a02967c1b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">util::tuple</a>&lt; <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt;, <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ab0c911adec30af9bcf3f090a02967c1b">centerAndSize</a> (const <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> &amp;ibox, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box)</td></tr>
<tr class="memdesc:ab0c911adec30af9bcf3f090a02967c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate floating point 3D center and radius of a and integer box and bounding box pair  <br /></td></tr>
<tr class="separator:ab0c911adec30af9bcf3f090a02967c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83b1d50b08bf5c589d6bce93b2dabba" id="r_ad83b1d50b08bf5c589d6bce93b2dabba"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </td></tr>
<tr class="memitem:ad83b1d50b08bf5c589d6bce93b2dabba"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a17864a21bbfcf1e20ef7c834edae7cf3">FBox</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ad83b1d50b08bf5c589d6bce93b2dabba">createFpBox</a> (const <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> &amp;ibox, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box)</td></tr>
<tr class="memdesc:ad83b1d50b08bf5c589d6bce93b2dabba"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a floating point box from and integer box  <br /></td></tr>
<tr class="separator:ad83b1d50b08bf5c589d6bce93b2dabba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f1e806067f32870433b12cd3339a77" id="r_ac3f1e806067f32870433b12cd3339a77"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </td></tr>
<tr class="memitem:ac3f1e806067f32870433b12cd3339a77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ac3f1e806067f32870433b12cd3339a77">createIBox</a> (const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; center, const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;size, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box)</td></tr>
<tr class="memdesc:ac3f1e806067f32870433b12cd3339a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a floating point box to an IBox with a volume not smaller than the input box  <br /></td></tr>
<tr class="separator:ac3f1e806067f32870433b12cd3339a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e1980bc3b020c7c78fe8fba8ea90d6" id="r_a93e1980bc3b020c7c78fe8fba8ea90d6"><td class="memTemplParams" colspan="2">template&lt;class T , class Op  = MinMax&lt;T&gt;&gt; </td></tr>
<tr class="memitem:a93e1980bc3b020c7c78fe8fba8ea90d6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a93e1980bc3b020c7c78fe8fba8ea90d6">makeGlobalBox</a> (const T *x, const T *y, const T *z, size_t numElements, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;previousBox=<a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt;(0, 1))</td></tr>
<tr class="memdesc:a93e1980bc3b020c7c78fe8fba8ea90d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute global bounding box for local x,y,z arrays  <br /></td></tr>
<tr class="separator:a93e1980bc3b020c7c78fe8fba8ea90d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcbc01b2db139fd7f8c07503ea4555a" id="r_aafcbc01b2db139fd7f8c07503ea4555a"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </td></tr>
<tr class="memitem:aafcbc01b2db139fd7f8c07503ea4555a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aafcbc01b2db139fd7f8c07503ea4555a">toNBitInt</a> (T x)</td></tr>
<tr class="memdesc:aafcbc01b2db139fd7f8c07503ea4555a"><td class="mdescLeft">&#160;</td><td class="mdescRight">normalize a floating point number in [0,1] to an integer in [0 : 2^(10 or 21)]  <br /></td></tr>
<tr class="separator:aafcbc01b2db139fd7f8c07503ea4555a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb204b9aa10b513f13fca2242eda85a9" id="r_abb204b9aa10b513f13fca2242eda85a9"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </td></tr>
<tr class="memitem:abb204b9aa10b513f13fca2242eda85a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#abb204b9aa10b513f13fca2242eda85a9">toNBitIntCeil</a> (T x)</td></tr>
<tr class="memdesc:abb204b9aa10b513f13fca2242eda85a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">normalize a floating point number in [0,1] to an integer in [0 : 2^(10 or 21)]  <br /></td></tr>
<tr class="separator:abb204b9aa10b513f13fca2242eda85a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e7cf1f2fbfdead5327f969077f8e96" id="r_a88e7cf1f2fbfdead5327f969077f8e96"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a88e7cf1f2fbfdead5327f969077f8e96"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a88e7cf1f2fbfdead5327f969077f8e96">pad</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> prefix, int length)</td></tr>
<tr class="memdesc:a88e7cf1f2fbfdead5327f969077f8e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">add (binary) zeros behind a prefix  <br /></td></tr>
<tr class="separator:a88e7cf1f2fbfdead5327f969077f8e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2eb2287ba506a5fe544bf2627b4977b" id="r_ad2eb2287ba506a5fe544bf2627b4977b"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:ad2eb2287ba506a5fe544bf2627b4977b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ad2eb2287ba506a5fe544bf2627b4977b">nodeRange</a> (unsigned <a class="el" href="namespacecstone.html#a3180e184261c7da178feb8f1cdd07c9f">treeLevel</a>)</td></tr>
<tr class="memdesc:ad2eb2287ba506a5fe544bf2627b4977b"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the maximum range of an octree node at a given subdivision level  <br /></td></tr>
<tr class="separator:ad2eb2287ba506a5fe544bf2627b4977b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366f08c027ae6bcd8afdbf873f2cd948" id="r_a366f08c027ae6bcd8afdbf873f2cd948"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a366f08c027ae6bcd8afdbf873f2cd948"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a366f08c027ae6bcd8afdbf873f2cd948">log8ceil</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> n)</td></tr>
<tr class="memdesc:a366f08c027ae6bcd8afdbf873f2cd948"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute ceil(log8(n))  <br /></td></tr>
<tr class="separator:a366f08c027ae6bcd8afdbf873f2cd948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd74e2142c82f18659c4778f030a3e15" id="r_acd74e2142c82f18659c4778f030a3e15"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:acd74e2142c82f18659c4778f030a3e15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#acd74e2142c82f18659c4778f030a3e15">isPowerOf8</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> n)</td></tr>
<tr class="memdesc:acd74e2142c82f18659c4778f030a3e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether n is a power of 8  <br /></td></tr>
<tr class="separator:acd74e2142c82f18659c4778f030a3e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f509b9fb275cb8bf0d540681174822" id="r_a78f509b9fb275cb8bf0d540681174822"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a78f509b9fb275cb8bf0d540681174822"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a78f509b9fb275cb8bf0d540681174822">commonPrefix</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> key1, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> key2)</td></tr>
<tr class="memdesc:a78f509b9fb275cb8bf0d540681174822"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate common prefix (cpr) of two SFC keys  <br /></td></tr>
<tr class="separator:a78f509b9fb275cb8bf0d540681174822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3180e184261c7da178feb8f1cdd07c9f" id="r_a3180e184261c7da178feb8f1cdd07c9f"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a3180e184261c7da178feb8f1cdd07c9f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a3180e184261c7da178feb8f1cdd07c9f">treeLevel</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> codeRange)</td></tr>
<tr class="memdesc:a3180e184261c7da178feb8f1cdd07c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return octree subdivision level corresponding to codeRange  <br /></td></tr>
<tr class="separator:a3180e184261c7da178feb8f1cdd07c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe358bb531bd012cf6bd426cc6f236a4" id="r_abe358bb531bd012cf6bd426cc6f236a4"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:abe358bb531bd012cf6bd426cc6f236a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#abe358bb531bd012cf6bd426cc6f236a4">encodePlaceholderBit</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> code, int prefixLength)</td></tr>
<tr class="memdesc:abe358bb531bd012cf6bd426cc6f236a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a plain SFC key into the placeholder bit format (Warren-Salmon 1993)  <br /></td></tr>
<tr class="separator:abe358bb531bd012cf6bd426cc6f236a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb049aaa3103bdd79f42fb329a88639" id="r_a4bb049aaa3103bdd79f42fb329a88639"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a4bb049aaa3103bdd79f42fb329a88639"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a4bb049aaa3103bdd79f42fb329a88639">decodePrefixLength</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> code)</td></tr>
<tr class="memdesc:a4bb049aaa3103bdd79f42fb329a88639"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of key-bits in the input <code>code</code>  <br /></td></tr>
<tr class="separator:a4bb049aaa3103bdd79f42fb329a88639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03c2fc3addf2158300b5e1c17df3684" id="r_aa03c2fc3addf2158300b5e1c17df3684"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:aa03c2fc3addf2158300b5e1c17df3684"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aa03c2fc3addf2158300b5e1c17df3684">decodePlaceholderBit</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> code)</td></tr>
<tr class="memdesc:aa03c2fc3addf2158300b5e1c17df3684"><td class="mdescLeft">&#160;</td><td class="mdescRight">decode an SFC key in Warren-Salmon placeholder bit format  <br /></td></tr>
<tr class="separator:aa03c2fc3addf2158300b5e1c17df3684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dcbc63abef4bbbac0fde10cbc77ea00" id="r_a1dcbc63abef4bbbac0fde10cbc77ea00"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a1dcbc63abef4bbbac0fde10cbc77ea00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a1dcbc63abef4bbbac0fde10cbc77ea00">octalDigit</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> code, unsigned position)</td></tr>
<tr class="memdesc:a1dcbc63abef4bbbac0fde10cbc77ea00"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract the n-th octal digit from an SFC key, starting from the most significant  <br /></td></tr>
<tr class="separator:a1dcbc63abef4bbbac0fde10cbc77ea00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e7a2cadb54fca11090363230c8e092" id="r_aa2e7a2cadb54fca11090363230c8e092"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:aa2e7a2cadb54fca11090363230c8e092"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aa2e7a2cadb54fca11090363230c8e092">isAncestor</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> a, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> b)</td></tr>
<tr class="memdesc:aa2e7a2cadb54fca11090363230c8e092"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if a is an ancestor of b or if a is a sibling of an ancestor of b  <br /></td></tr>
<tr class="separator:aa2e7a2cadb54fca11090363230c8e092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb36224fc3057d03fb74b4c88739b632" id="r_acb36224fc3057d03fb74b4c88739b632"><td class="memItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#acb36224fc3057d03fb74b4c88739b632">digitWeight</a> (int digit)</td></tr>
<tr class="memdesc:acb36224fc3057d03fb74b4c88739b632"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the offset octal digit weight for binary tree &lt;-&gt; octree index correspondence  <br /></td></tr>
<tr class="separator:acb36224fc3057d03fb74b4c88739b632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af86e6fc94838cadc77f9c359cafbf3ec" id="r_af86e6fc94838cadc77f9c359cafbf3ec"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:af86e6fc94838cadc77f9c359cafbf3ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#af86e6fc94838cadc77f9c359cafbf3ec">enclosingBoxCode</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> key, unsigned <a class="el" href="namespacecstone.html#a3180e184261c7da178feb8f1cdd07c9f">treeLevel</a>)</td></tr>
<tr class="memdesc:af86e6fc94838cadc77f9c359cafbf3ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">cut down the input SFC code to the start code of the enclosing box at &lt;treeLevel&gt;  <br /></td></tr>
<tr class="separator:af86e6fc94838cadc77f9c359cafbf3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c515535a3dc4da80b36efad0209c6f" id="r_a32c515535a3dc4da80b36efad0209c6f"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a32c515535a3dc4da80b36efad0209c6f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">util::tuple</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a32c515535a3dc4da80b36efad0209c6f">smallestCommonBox</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> firstKey, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> secondKey)</td></tr>
<tr class="memdesc:a32c515535a3dc4da80b36efad0209c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute an enclosing envelope corresponding to the smallest possible octree node for two input SFC codes  <br /></td></tr>
<tr class="separator:a32c515535a3dc4da80b36efad0209c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491da2b745e89f2f955aa26504452bf0" id="r_a491da2b745e89f2f955aa26504452bf0"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a491da2b745e89f2f955aa26504452bf0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a491da2b745e89f2f955aa26504452bf0">zeroLowBits</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> code, unsigned nBits)</td></tr>
<tr class="memdesc:a491da2b745e89f2f955aa26504452bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">zero all but the highest nBits in a SFC code  <br /></td></tr>
<tr class="separator:a491da2b745e89f2f955aa26504452bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f987f0a7b7cb62e98a43012b94fa2f" id="r_ad6f987f0a7b7cb62e98a43012b94fa2f"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:ad6f987f0a7b7cb62e98a43012b94fa2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ad6f987f0a7b7cb62e98a43012b94fa2f">lastNzPlace</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> x)</td></tr>
<tr class="memdesc:ad6f987f0a7b7cb62e98a43012b94fa2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return position of last non-zero octal digit place in x  <br /></td></tr>
<tr class="separator:ad6f987f0a7b7cb62e98a43012b94fa2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7692fb6ab797e4c497fc69b7f4afe52f" id="r_a7692fb6ab797e4c497fc69b7f4afe52f"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a7692fb6ab797e4c497fc69b7f4afe52f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a7692fb6ab797e4c497fc69b7f4afe52f">makePrefix</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> a)</td></tr>
<tr class="memdesc:a7692fb6ab797e4c497fc69b7f4afe52f"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the placeholder-bit prefix for the biggest possible node that starts at <code>a</code>  <br /></td></tr>
<tr class="separator:a7692fb6ab797e4c497fc69b7f4afe52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffea930222fd56e27345f02dd181544" id="r_aeffea930222fd56e27345f02dd181544"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:aeffea930222fd56e27345f02dd181544"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aeffea930222fd56e27345f02dd181544">octalPower</a> (int pos)</td></tr>
<tr class="memdesc:aeffea930222fd56e27345f02dd181544"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the power of 8 for the octal place at position <code>pos</code>  <br /></td></tr>
<tr class="separator:aeffea930222fd56e27345f02dd181544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441f5658d946885a1528d4ed214339f5" id="r_a441f5658d946885a1528d4ed214339f5"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class Store &gt; </td></tr>
<tr class="memitem:a441f5658d946885a1528d4ed214339f5"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_same_v&lt; Store, std::nullptr_t &gt;||std::is_same_v&lt; Store, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> * &gt;, int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a441f5658d946885a1528d4ed214339f5">spanSfcRange</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> a, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> b, Store output)</td></tr>
<tr class="memdesc:a441f5658d946885a1528d4ed214339f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">generate SFC codes to cover the range [a:b] with a valid cornerstone sub-octree  <br /></td></tr>
<tr class="separator:a441f5658d946885a1528d4ed214339f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b2a553fd9770d6a014a8b6b3165730" id="r_a07b2a553fd9770d6a014a8b6b3165730"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a07b2a553fd9770d6a014a8b6b3165730"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a07b2a553fd9770d6a014a8b6b3165730">spanSfcRange</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> a, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> b)</td></tr>
<tr class="memdesc:a07b2a553fd9770d6a014a8b6b3165730"><td class="mdescLeft">&#160;</td><td class="mdescRight">overload to skip storage and just compute number of values, see spanSfcRange(KeyType a, KeyType b, KeyType*
output) above  <br /></td></tr>
<tr class="separator:a07b2a553fd9770d6a014a8b6b3165730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bd5946e8e61320adfcd45c3f4971cc" id="r_a52bd5946e8e61320adfcd45c3f4971cc"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a52bd5946e8e61320adfcd45c3f4971cc"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; std::is_unsigned_v&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a52bd5946e8e61320adfcd45c3f4971cc">iHilbert</a> (unsigned px, unsigned py, unsigned pz) noexcept</td></tr>
<tr class="memdesc:a52bd5946e8e61320adfcd45c3f4971cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the Hilbert key for a 3D point of integer coordinates  <br /></td></tr>
<tr class="separator:a52bd5946e8e61320adfcd45c3f4971cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd10a5de70ff3ed14b1a99991179ad1" id="r_a6cd10a5de70ff3ed14b1a99991179ad1"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a6cd10a5de70ff3ed14b1a99991179ad1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; std::is_unsigned_v&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a6cd10a5de70ff3ed14b1a99991179ad1">iHilbert2D</a> (unsigned px, unsigned py) noexcept</td></tr>
<tr class="memdesc:a6cd10a5de70ff3ed14b1a99991179ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the Hilbert key for a 2D point of integer coordinates  <br /></td></tr>
<tr class="separator:a6cd10a5de70ff3ed14b1a99991179ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a0069a226f71950884bdbce365aef3" id="r_af7a0069a226f71950884bdbce365aef3"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:af7a0069a226f71950884bdbce365aef3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">util::tuple</a>&lt; unsigned, unsigned, unsigned &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#af7a0069a226f71950884bdbce365aef3">decodeHilbert</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> key) noexcept</td></tr>
<tr class="memdesc:af7a0069a226f71950884bdbce365aef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverse function of iHilbert  <br /></td></tr>
<tr class="separator:af7a0069a226f71950884bdbce365aef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862268d9c2f782effdd90cc578e2274b" id="r_a862268d9c2f782effdd90cc578e2274b"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a862268d9c2f782effdd90cc578e2274b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">util::tuple</a>&lt; unsigned, unsigned &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a862268d9c2f782effdd90cc578e2274b">decodeHilbert2D</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> key) noexcept</td></tr>
<tr class="separator:a862268d9c2f782effdd90cc578e2274b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0fc40b5985e5508fd1d9a4e013a0ddb" id="r_ae0fc40b5985e5508fd1d9a4e013a0ddb"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:ae0fc40b5985e5508fd1d9a4e013a0ddb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">util::tuple</a>&lt; unsigned, unsigned &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ae0fc40b5985e5508fd1d9a4e013a0ddb">decodeHilbert2DConstant</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> key) noexcept</td></tr>
<tr class="memdesc:ae0fc40b5985e5508fd1d9a4e013a0ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">inverse function of iHilbert 32 bit only up to oder 16 but works at constant time.  <br /></td></tr>
<tr class="separator:ae0fc40b5985e5508fd1d9a4e013a0ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9eab950b9acb82f20f12541c3464c35" id="r_ac9eab950b9acb82f20f12541c3464c35"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:ac9eab950b9acb82f20f12541c3464c35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ac9eab950b9acb82f20f12541c3464c35">hilbertIBox</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> keyStart, unsigned level) noexcept</td></tr>
<tr class="memdesc:ac9eab950b9acb82f20f12541c3464c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the 3D integer coordinate box that contains the key range  <br /></td></tr>
<tr class="separator:ac9eab950b9acb82f20f12541c3464c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7f860eefca16f0b7242e15e1b022fe" id="r_a4f7f860eefca16f0b7242e15e1b022fe"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a4f7f860eefca16f0b7242e15e1b022fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a4f7f860eefca16f0b7242e15e1b022fe">hilbertIBoxKeys</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> keyStart, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> keyEnd) noexcept</td></tr>
<tr class="memdesc:a4f7f860eefca16f0b7242e15e1b022fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience wrapper  <br /></td></tr>
<tr class="separator:a4f7f860eefca16f0b7242e15e1b022fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7fb4903e25f925e03ba06febfaf3d2" id="r_aca7fb4903e25f925e03ba06febfaf3d2"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:aca7fb4903e25f925e03ba06febfaf3d2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; std::is_unsigned&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;{}, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aca7fb4903e25f925e03ba06febfaf3d2">iMorton</a> (unsigned ix, unsigned iy, unsigned iz) noexcept</td></tr>
<tr class="memdesc:aca7fb4903e25f925e03ba06febfaf3d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a Morton code for a 3D point in integer coordinates.  <br /></td></tr>
<tr class="separator:aca7fb4903e25f925e03ba06febfaf3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01db86768abd4018d795355d13b1fc75" id="r_a01db86768abd4018d795355d13b1fc75"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a01db86768abd4018d795355d13b1fc75"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a01db86768abd4018d795355d13b1fc75">iMorton</a> (unsigned ix, unsigned iy, unsigned iz, unsigned <a class="el" href="namespacecstone.html#a3180e184261c7da178feb8f1cdd07c9f">treeLevel</a>)</td></tr>
<tr class="memdesc:a01db86768abd4018d795355d13b1fc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate morton code from n-level integer 3D coordinates.  <br /></td></tr>
<tr class="separator:a01db86768abd4018d795355d13b1fc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4dcb84daaec6536e0aaa988668c16eb" id="r_aa4dcb84daaec6536e0aaa988668c16eb"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:aa4dcb84daaec6536e0aaa988668c16eb"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; std::is_unsigned&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;{}, unsigned &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aa4dcb84daaec6536e0aaa988668c16eb">idecodeMortonX</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> code)</td></tr>
<tr class="memdesc:aa4dcb84daaec6536e0aaa988668c16eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract X component from a morton code  <br /></td></tr>
<tr class="separator:aa4dcb84daaec6536e0aaa988668c16eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75767b0ac157bf8808a7a24a0f2da2fd" id="r_a75767b0ac157bf8808a7a24a0f2da2fd"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a75767b0ac157bf8808a7a24a0f2da2fd"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; std::is_unsigned&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;{}, unsigned &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a75767b0ac157bf8808a7a24a0f2da2fd">idecodeMortonY</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> code)</td></tr>
<tr class="memdesc:a75767b0ac157bf8808a7a24a0f2da2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract Y component from a morton code  <br /></td></tr>
<tr class="separator:a75767b0ac157bf8808a7a24a0f2da2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb0d8dc950035be984093e6e10376394" id="r_acb0d8dc950035be984093e6e10376394"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:acb0d8dc950035be984093e6e10376394"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; std::is_unsigned&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;{}, unsigned &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#acb0d8dc950035be984093e6e10376394">idecodeMortonZ</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> code)</td></tr>
<tr class="memdesc:acb0d8dc950035be984093e6e10376394"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract Z component from a morton code  <br /></td></tr>
<tr class="separator:acb0d8dc950035be984093e6e10376394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b208333a41d773b6ac6106aaf625d64" id="r_a9b208333a41d773b6ac6106aaf625d64"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a9b208333a41d773b6ac6106aaf625d64"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">util::tuple</a>&lt; unsigned, unsigned, unsigned &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a9b208333a41d773b6ac6106aaf625d64">decodeMorton</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> code) noexcept</td></tr>
<tr class="memdesc:a9b208333a41d773b6ac6106aaf625d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">decode X,Y,Z components of a Morton key into a tuple  <br /></td></tr>
<tr class="separator:a9b208333a41d773b6ac6106aaf625d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3f9c38718cf35b2601a4b970da82bc" id="r_a1b3f9c38718cf35b2601a4b970da82bc"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a1b3f9c38718cf35b2601a4b970da82bc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a1b3f9c38718cf35b2601a4b970da82bc">mortonIBox</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> keyStart, unsigned level) noexcept</td></tr>
<tr class="memdesc:a1b3f9c38718cf35b2601a4b970da82bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the 3D integer coordinate box that contains the key range  <br /></td></tr>
<tr class="separator:a1b3f9c38718cf35b2601a4b970da82bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b3736ffa6b65d0c54c9e05d1ab06ce" id="r_a89b3736ffa6b65d0c54c9e05d1ab06ce"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a89b3736ffa6b65d0c54c9e05d1ab06ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a89b3736ffa6b65d0c54c9e05d1ab06ce">mortonIBoxKeys</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> keyStart, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> keyEnd) noexcept</td></tr>
<tr class="separator:a89b3736ffa6b65d0c54c9e05d1ab06ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f5b958a480e3cdd096655e062b4ba7" id="r_a74f5b958a480e3cdd096655e062b4ba7"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a74f5b958a480e3cdd096655e062b4ba7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a4d054fd740773a4ffbaecadfb6cecf92">SfcKind</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a74f5b958a480e3cdd096655e062b4ba7">sfcKey</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> key)</td></tr>
<tr class="separator:a74f5b958a480e3cdd096655e062b4ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9fd895eb19ec2ea4ed7c7277144bc44" id="r_af9fd895eb19ec2ea4ed7c7277144bc44"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:af9fd895eb19ec2ea4ed7c7277144bc44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a4d054fd740773a4ffbaecadfb6cecf92">SfcKind</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#af9fd895eb19ec2ea4ed7c7277144bc44">sfcKindPointer</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *ptr)</td></tr>
<tr class="memdesc:af9fd895eb19ec2ea4ed7c7277144bc44"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert an integer pointer to the corresponding strongly typed SFC key pointer  <br /></td></tr>
<tr class="separator:af9fd895eb19ec2ea4ed7c7277144bc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1384393b71ef54fe312b1dc87612c5" id="r_a6b1384393b71ef54fe312b1dc87612c5"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a6b1384393b71ef54fe312b1dc87612c5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> const <a class="el" href="namespacecstone.html#a4d054fd740773a4ffbaecadfb6cecf92">SfcKind</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a6b1384393b71ef54fe312b1dc87612c5">sfcKindPointer</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *ptr)</td></tr>
<tr class="memdesc:a6b1384393b71ef54fe312b1dc87612c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a integer pointer to the corresponding strongly typed SFC key pointer  <br /></td></tr>
<tr class="separator:a6b1384393b71ef54fe312b1dc87612c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74c05ec93266d68239eedea007d51d2" id="r_af74c05ec93266d68239eedea007d51d2"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:af74c05ec93266d68239eedea007d51d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; <a class="el" href="structcstone_1_1IsMorton.html">IsMorton</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;{}, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#af74c05ec93266d68239eedea007d51d2">iSfcKey</a> (unsigned ix, unsigned iy, unsigned iz)</td></tr>
<tr class="memdesc:af74c05ec93266d68239eedea007d51d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key encode overload for Morton keys.  <br /></td></tr>
<tr class="separator:af74c05ec93266d68239eedea007d51d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20db4c89bb64c02b6100f834cf44189" id="r_ae20db4c89bb64c02b6100f834cf44189"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:ae20db4c89bb64c02b6100f834cf44189"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; <a class="el" href="structcstone_1_1IsHilbert.html">IsHilbert</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;{}, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ae20db4c89bb64c02b6100f834cf44189">iSfcKey</a> (unsigned ix, unsigned iy, unsigned iz)</td></tr>
<tr class="memdesc:ae20db4c89bb64c02b6100f834cf44189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Key encode overload for Hilbert keys.  <br /></td></tr>
<tr class="separator:ae20db4c89bb64c02b6100f834cf44189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00769dd2c65537a35757eb88b787d6fb" id="r_a00769dd2c65537a35757eb88b787d6fb"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </td></tr>
<tr class="memitem:a00769dd2c65537a35757eb88b787d6fb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a00769dd2c65537a35757eb88b787d6fb">sfc3D</a> (T x, T y, T z, T xmin, T ymin, T zmin, T mx, T my, T mz)</td></tr>
<tr class="separator:a00769dd2c65537a35757eb88b787d6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a655cdac9558c2b1d5735efdb837fc3" id="r_a8a655cdac9558c2b1d5735efdb837fc3"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </td></tr>
<tr class="memitem:a8a655cdac9558c2b1d5735efdb837fc3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a8a655cdac9558c2b1d5735efdb837fc3">sfc3D</a> (T x, T y, T z, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box)</td></tr>
<tr class="memdesc:a8a655cdac9558c2b1d5735efdb837fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a Hilbert key for a 3D point within the specified box.  <br /></td></tr>
<tr class="separator:a8a655cdac9558c2b1d5735efdb837fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ba890fd3fc397dfd56619fbfee6e3a" id="r_a55ba890fd3fc397dfd56619fbfee6e3a"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a55ba890fd3fc397dfd56619fbfee6e3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; <a class="el" href="structcstone_1_1IsMorton.html">IsMorton</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;{}, <a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">util::tuple</a>&lt; unsigned, unsigned, unsigned &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a55ba890fd3fc397dfd56619fbfee6e3a">decodeSfc</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> key)</td></tr>
<tr class="memdesc:a55ba890fd3fc397dfd56619fbfee6e3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">decode a Morton key  <br /></td></tr>
<tr class="separator:a55ba890fd3fc397dfd56619fbfee6e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595434f3bdf01b9ccdb62921e1ccdbbb" id="r_a595434f3bdf01b9ccdb62921e1ccdbbb"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a595434f3bdf01b9ccdb62921e1ccdbbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; <a class="el" href="structcstone_1_1IsHilbert.html">IsHilbert</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;{}, <a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">util::tuple</a>&lt; unsigned, unsigned, unsigned &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a595434f3bdf01b9ccdb62921e1ccdbbb">decodeSfc</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> key)</td></tr>
<tr class="memdesc:a595434f3bdf01b9ccdb62921e1ccdbbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">decode a Hilbert key  <br /></td></tr>
<tr class="separator:a595434f3bdf01b9ccdb62921e1ccdbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b874e24bd703a1fc7cece9dff7319b2" id="r_a7b874e24bd703a1fc7cece9dff7319b2"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a7b874e24bd703a1fc7cece9dff7319b2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; <a class="el" href="structcstone_1_1IsMorton.html">IsMorton</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;{}, <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a7b874e24bd703a1fc7cece9dff7319b2">sfcIBox</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> keyStart, unsigned level) noexcept</td></tr>
<tr class="memdesc:a7b874e24bd703a1fc7cece9dff7319b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">create and integer box from Morton keys  <br /></td></tr>
<tr class="separator:a7b874e24bd703a1fc7cece9dff7319b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ce41855c1576305d3d4c2ba8c6888f" id="r_a87ce41855c1576305d3d4c2ba8c6888f"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a87ce41855c1576305d3d4c2ba8c6888f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; <a class="el" href="structcstone_1_1IsHilbert.html">IsHilbert</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;{}, <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a87ce41855c1576305d3d4c2ba8c6888f">sfcIBox</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> keyStart, unsigned level) noexcept</td></tr>
<tr class="memdesc:a87ce41855c1576305d3d4c2ba8c6888f"><td class="mdescLeft">&#160;</td><td class="mdescRight">create and integer box from Hilbert keys  <br /></td></tr>
<tr class="separator:a87ce41855c1576305d3d4c2ba8c6888f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbf5fb6b1b594658cf28e9fb01a7e0f" id="r_a6fbf5fb6b1b594658cf28e9fb01a7e0f"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a6fbf5fb6b1b594658cf28e9fb01a7e0f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a6fbf5fb6b1b594658cf28e9fb01a7e0f">sfcIBox</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> keyStart, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> keyEnd) noexcept</td></tr>
<tr class="memdesc:a6fbf5fb6b1b594658cf28e9fb01a7e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience overload  <br /></td></tr>
<tr class="separator:a6fbf5fb6b1b594658cf28e9fb01a7e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95cbcfe710369f388a0229b85bef0ffa" id="r_a95cbcfe710369f388a0229b85bef0ffa"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </td></tr>
<tr class="memitem:a95cbcfe710369f388a0229b85bef0ffa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a95cbcfe710369f388a0229b85bef0ffa">commonNodePrefix</a> (<a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; center, <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; size, const <a class="el" href="classcstone_1_1Box.html">cstone::Box</a>&lt; T &gt; &amp;box)</td></tr>
<tr class="memdesc:a95cbcfe710369f388a0229b85bef0ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the smallest octree node in placeholder-bit format that contains the given floating point box.  <br /></td></tr>
<tr class="separator:a95cbcfe710369f388a0229b85bef0ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9e16c392e9194a8ad7db68e3b6c884" id="r_abb9e16c392e9194a8ad7db68e3b6c884"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:abb9e16c392e9194a8ad7db68e3b6c884"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#abb9e16c392e9194a8ad7db68e3b6c884">sfcNeighbor</a> (const <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> &amp;ibox, unsigned level, int dx, int dy, int dz)</td></tr>
<tr class="memdesc:abb9e16c392e9194a8ad7db68e3b6c884"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the smallest Hilbert key contained in the shifted box  <br /></td></tr>
<tr class="separator:abb9e16c392e9194a8ad7db68e3b6c884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf448edc66cef42f59f85e742e4df114" id="r_aaf448edc66cef42f59f85e742e4df114"><td class="memTemplParams" colspan="2">template&lt;class T , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:aaf448edc66cef42f59f85e742e4df114"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aaf448edc66cef42f59f85e742e4df114">computeSfcKeys</a> (const T *x, const T *y, const T *z, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *particleKeys, size_t n, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box)</td></tr>
<tr class="memdesc:aaf448edc66cef42f59f85e742e4df114"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute the SFC keys for the input coordinate arrays  <br /></td></tr>
<tr class="separator:aaf448edc66cef42f59f85e742e4df114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e9e74ae1bced8d15efa7ebae52c2e2" id="r_ad3e9e74ae1bced8d15efa7ebae52c2e2"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </td></tr>
<tr class="memitem:ad3e9e74ae1bced8d15efa7ebae52c2e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ad3e9e74ae1bced8d15efa7ebae52c2e2">computeSfcKeysGpu</a> (const T *x, const T *y, const T *z, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *keys, size_t numKeys, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box)</td></tr>
<tr class="separator:ad3e9e74ae1bced8d15efa7ebae52c2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af31c5d2856b4995d020b1c999f8007" id="r_a5af31c5d2856b4995d020b1c999f8007"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5af31c5d2856b4995d020b1c999f8007"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a5af31c5d2856b4995d020b1c999f8007">overlapTwoRanges</a> (T a, T b, T c, T d)</td></tr>
<tr class="memdesc:a5af31c5d2856b4995d020b1c999f8007"><td class="mdescLeft">&#160;</td><td class="mdescRight">standard criterion for two ranges a-b and c-d to overlap, a&lt;b and c&lt;d  <br /></td></tr>
<tr class="separator:a5af31c5d2856b4995d020b1c999f8007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63eaf497749b63b3348ef8233e3acdf2" id="r_a63eaf497749b63b3348ef8233e3acdf2"><td class="memTemplParams" colspan="2">template&lt;int R&gt; </td></tr>
<tr class="memitem:a63eaf497749b63b3348ef8233e3acdf2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a63eaf497749b63b3348ef8233e3acdf2">overlapRange</a> (int a, int b, int c, int d)</td></tr>
<tr class="memdesc:a63eaf497749b63b3348ef8233e3acdf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine whether two ranges ab and cd overlap  <br /></td></tr>
<tr class="separator:a63eaf497749b63b3348ef8233e3acdf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf53e91f88a6f7c9b738bbb2c2485e32" id="r_acf53e91f88a6f7c9b738bbb2c2485e32"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:acf53e91f88a6f7c9b738bbb2c2485e32"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#acf53e91f88a6f7c9b738bbb2c2485e32">overlap</a> (const <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> &amp;a, const <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> &amp;b)</td></tr>
<tr class="memdesc:acf53e91f88a6f7c9b738bbb2c2485e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether two boxes overlap. takes PBC into account, boxes can wrap around  <br /></td></tr>
<tr class="separator:acf53e91f88a6f7c9b738bbb2c2485e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49458052e6817b7a5e01de1beeca693" id="r_ab49458052e6817b7a5e01de1beeca693"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:ab49458052e6817b7a5e01de1beeca693"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; std::is_unsigned_v&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ab49458052e6817b7a5e01de1beeca693">containedIn</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> codeStart, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> codeEnd, const <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> &amp;box)</td></tr>
<tr class="memdesc:ab49458052e6817b7a5e01de1beeca693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a coordinate box is fully contained in a Morton code range.  <br /></td></tr>
<tr class="separator:ab49458052e6817b7a5e01de1beeca693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16383bf043362449171b90353b9d1c3b" id="r_a16383bf043362449171b90353b9d1c3b"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a16383bf043362449171b90353b9d1c3b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; std::is_unsigned_v&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a16383bf043362449171b90353b9d1c3b">containedIn</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> nodeStart, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> nodeEnd, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> codeStart, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> codeEnd)</td></tr>
<tr class="memdesc:a16383bf043362449171b90353b9d1c3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine whether a binary/octree node (prefix, prefixLength) is fully contained in an SFC range  <br /></td></tr>
<tr class="separator:a16383bf043362449171b90353b9d1c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa7d9370b5c932ca1a89c0b9781594e" id="r_a4fa7d9370b5c932ca1a89c0b9781594e"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a4fa7d9370b5c932ca1a89c0b9781594e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; std::is_unsigned_v&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a4fa7d9370b5c932ca1a89c0b9781594e">containedIn</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> prefixBitKey, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> codeStart, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> codeEnd)</td></tr>
<tr class="separator:a4fa7d9370b5c932ca1a89c0b9781594e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db476068a87e55ae7c268cfccd958fe" id="r_a9db476068a87e55ae7c268cfccd958fe"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a9db476068a87e55ae7c268cfccd958fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a9db476068a87e55ae7c268cfccd958fe">addDelta</a> (int value, int delta, bool pbc)</td></tr>
<tr class="separator:a9db476068a87e55ae7c268cfccd958fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ad9d460d331348d451f336e4d70d9c" id="r_a73ad9d460d331348d451f336e4d70d9c"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class CoordinateType , class RadiusType &gt; </td></tr>
<tr class="memitem:a73ad9d460d331348d451f336e4d70d9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a73ad9d460d331348d451f336e4d70d9c">makeHaloBox</a> (const <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> &amp;nodeBox, RadiusType radius, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; CoordinateType &gt; &amp;box)</td></tr>
<tr class="memdesc:a73ad9d460d331348d451f336e4d70d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a box with specified radius around node delineated by codeStart/End  <br /></td></tr>
<tr class="separator:a73ad9d460d331348d451f336e4d70d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84601c8dc86babee053dd371eb3a1acb" id="r_a84601c8dc86babee053dd371eb3a1acb"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class CoordinateType , class RadiusType &gt; </td></tr>
<tr class="memitem:a84601c8dc86babee053dd371eb3a1acb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a84601c8dc86babee053dd371eb3a1acb">makeHaloBox</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> codeStart, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> codeEnd, RadiusType radius, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; CoordinateType &gt; &amp;box)</td></tr>
<tr class="memdesc:a84601c8dc86babee053dd371eb3a1acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a box with specified radius around node delineated by codeStart/End  <br /></td></tr>
<tr class="separator:a84601c8dc86babee053dd371eb3a1acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b8be6d3ec450bf99f6c2ec89d759c3" id="r_a92b8be6d3ec450bf99f6c2ec89d759c3"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a92b8be6d3ec450bf99f6c2ec89d759c3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a92b8be6d3ec450bf99f6c2ec89d759c3">insideBox</a> (const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;center, const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;size, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box)</td></tr>
<tr class="memdesc:a92b8be6d3ec450bf99f6c2ec89d759c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the cuboid defined by center and size is contained within the bounding box  <br /></td></tr>
<tr class="separator:a92b8be6d3ec450bf99f6c2ec89d759c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a969cdbe72b38a77605c75863652e2f" id="r_a9a969cdbe72b38a77605c75863652e2f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9a969cdbe72b38a77605c75863652e2f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a9a969cdbe72b38a77605c75863652e2f">minDistance</a> (const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;X, const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;bCenter, const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;bSize)</td></tr>
<tr class="memdesc:a9a969cdbe72b38a77605c75863652e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the smallest distance vector of point X to box b, 0 if X is in b  <br /></td></tr>
<tr class="separator:a9a969cdbe72b38a77605c75863652e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af79c464a99e13af9d60f56afb680a221" id="r_af79c464a99e13af9d60f56afb680a221"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:af79c464a99e13af9d60f56afb680a221"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#af79c464a99e13af9d60f56afb680a221">minDistance</a> (const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;X, const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;bCenter, const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;bSize, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box)</td></tr>
<tr class="memdesc:af79c464a99e13af9d60f56afb680a221"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the smallest periodic distance vector of point X to box b, 0 if X is in b  <br /></td></tr>
<tr class="separator:af79c464a99e13af9d60f56afb680a221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe97e73f0e56eb55c5ec1421188ba07" id="r_aebe97e73f0e56eb55c5ec1421188ba07"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aebe97e73f0e56eb55c5ec1421188ba07"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aebe97e73f0e56eb55c5ec1421188ba07">minDistance</a> (const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;aCenter, const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;aSize, const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;bCenter, const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;bSize)</td></tr>
<tr class="memdesc:aebe97e73f0e56eb55c5ec1421188ba07"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the smallest distance vector between two boxes, 0 if they overlap  <br /></td></tr>
<tr class="separator:aebe97e73f0e56eb55c5ec1421188ba07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2926ebebbbd59dd875d1b76ce284780" id="r_ad2926ebebbbd59dd875d1b76ce284780"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ad2926ebebbbd59dd875d1b76ce284780"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ad2926ebebbbd59dd875d1b76ce284780">minDistance</a> (const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;aCenter, const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;aSize, const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;bCenter, const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;bSize, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box)</td></tr>
<tr class="memdesc:ad2926ebebbbd59dd875d1b76ce284780"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the smallest periodic distance vector between two boxes, 0 if they overlap  <br /></td></tr>
<tr class="separator:ad2926ebebbbd59dd875d1b76ce284780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1e5c5dee8fbe4f7cfe98057de2064f" id="r_abb1e5c5dee8fbe4f7cfe98057de2064f"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </td></tr>
<tr class="memitem:abb1e5c5dee8fbe4f7cfe98057de2064f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#abb1e5c5dee8fbe4f7cfe98057de2064f">minDistanceSq</a> (<a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> a, <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> b, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box)</td></tr>
<tr class="memdesc:abb1e5c5dee8fbe4f7cfe98057de2064f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper to minDistance. This should only be used for testing.  <br /></td></tr>
<tr class="separator:abb1e5c5dee8fbe4f7cfe98057de2064f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac48b2aa8c60c863f1dfa5fcce50a4c" id="r_acac48b2aa8c60c863f1dfa5fcce50a4c"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class F &gt; </td></tr>
<tr class="memitem:acac48b2aa8c60c863f1dfa5fcce50a4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#acac48b2aa8c60c863f1dfa5fcce50a4c">findCollisions</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *nodePrefixes, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *childOffsets, F &amp;&amp;endpointAction, const <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> &amp;target, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> excludeStart, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> excludeEnd)</td></tr>
<tr class="separator:acac48b2aa8c60c863f1dfa5fcce50a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda4494b138e3604cec6ac2152122ee2" id="r_afda4494b138e3604cec6ac2152122ee2"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class RadiusType , class CoordinateType &gt; </td></tr>
<tr class="memitem:afda4494b138e3604cec6ac2152122ee2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#afda4494b138e3604cec6ac2152122ee2">findHalos</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *prefixes, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *childOffsets, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *internalToLeaf, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *leaves, const RadiusType *interactionRadii, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; CoordinateType &gt; &amp;box, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> firstNode, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> lastNode, int *collisionFlags)</td></tr>
<tr class="memdesc:afda4494b138e3604cec6ac2152122ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">mark halo nodes with flags  <br /></td></tr>
<tr class="separator:afda4494b138e3604cec6ac2152122ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9448f6719204b82ae70bacfbadcea84" id="r_ad9448f6719204b82ae70bacfbadcea84"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class RadiusType , class T &gt; </td></tr>
<tr class="memitem:ad9448f6719204b82ae70bacfbadcea84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ad9448f6719204b82ae70bacfbadcea84">findHalosGpu</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *prefixes, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *childOffsets, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *internalToLeaf, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *leaves, const RadiusType *interactionRadii, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> firstNode, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> lastNode, int *collisionFlags)</td></tr>
<tr class="memdesc:ad9448f6719204b82ae70bacfbadcea84"><td class="mdescLeft">&#160;</td><td class="mdescRight">mark halo nodes with flags  <br /></td></tr>
<tr class="separator:ad9448f6719204b82ae70bacfbadcea84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92963f07615ad16e265a0c525750eb85" id="r_a92963f07615ad16e265a0c525750eb85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a92963f07615ad16e265a0c525750eb85">invThetaMinMac</a> (float theta)</td></tr>
<tr class="memdesc:a92963f07615ad16e265a0c525750eb85"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute 1/theta + s for the minimum distance MAC  <br /></td></tr>
<tr class="separator:a92963f07615ad16e265a0c525750eb85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3153af86effca88169036a024d4d37c" id="r_aa3153af86effca88169036a024d4d37c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aa3153af86effca88169036a024d4d37c">invThetaVecMac</a> (float theta)</td></tr>
<tr class="memdesc:aa3153af86effca88169036a024d4d37c"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute 1/theta + s for the worst-case vector MAC  <br /></td></tr>
<tr class="separator:aa3153af86effca88169036a024d4d37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2943d299973f8dea28eb12cb4bfd05b1" id="r_a2943d299973f8dea28eb12cb4bfd05b1"><td class="memTemplParams" colspan="2">template&lt;class T , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a2943d299973f8dea28eb12cb4bfd05b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a3c2b5abd635257ad027f958158d2ae21">Vec4</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a2943d299973f8dea28eb12cb4bfd05b1">computeMinMacR2</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> prefix, float invThetaEff, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box)</td></tr>
<tr class="memdesc:a2943d299973f8dea28eb12cb4bfd05b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute square of the acceptance radius for the minimum distance MAC.  <br /></td></tr>
<tr class="separator:a2943d299973f8dea28eb12cb4bfd05b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00710c213ab0c946ca126490d9144bca" id="r_a00710c213ab0c946ca126490d9144bca"><td class="memTemplParams" colspan="2">template&lt;class T , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a00710c213ab0c946ca126490d9144bca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a00710c213ab0c946ca126490d9144bca">computeVecMacR2</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> prefix, <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; expCenter, float invTheta, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box)</td></tr>
<tr class="memdesc:a00710c213ab0c946ca126490d9144bca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute square of the acceptance radius for the vector MAC.  <br /></td></tr>
<tr class="separator:a00710c213ab0c946ca126490d9144bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a34ab7a976a76180ebc58c4439f202c" id="r_a5a34ab7a976a76180ebc58c4439f202c"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a5a34ab7a976a76180ebc58c4439f202c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a5a34ab7a976a76180ebc58c4439f202c">evaluateMac</a> (<a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; sourceCenter, T macSq, <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; targetCenter, <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; targetSize)</td></tr>
<tr class="memdesc:a5a34ab7a976a76180ebc58c4439f202c"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate an arbitrary MAC with respect to a given target  <br /></td></tr>
<tr class="separator:a5a34ab7a976a76180ebc58c4439f202c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94aa283bf74d93496621d4995309e8b" id="r_ac94aa283bf74d93496621d4995309e8b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ac94aa283bf74d93496621d4995309e8b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ac94aa283bf74d93496621d4995309e8b">evaluateMacPbc</a> (<a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; sourceCenter, T macSq, <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; targetCenter, <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; targetSize, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box)</td></tr>
<tr class="memdesc:ac94aa283bf74d93496621d4995309e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">evaluate an arbitrary MAC with respect to a given target  <br /></td></tr>
<tr class="separator:ac94aa283bf74d93496621d4995309e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb4e6471bd9e9a4a1634f5f2867d0d2" id="r_aedb4e6471bd9e9a4a1634f5f2867d0d2"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aedb4e6471bd9e9a4a1634f5f2867d0d2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aedb4e6471bd9e9a4a1634f5f2867d0d2">minMacMutual</a> (const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;centerA, const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;sizeA, const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;centerB, const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;sizeB, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box, float invTheta)</td></tr>
<tr class="memdesc:aedb4e6471bd9e9a4a1634f5f2867d0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">commutative version of the min-distance mac, based on floating point math  <br /></td></tr>
<tr class="separator:aedb4e6471bd9e9a4a1634f5f2867d0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27845dc2ac5f1c5b89145cc0e4ac891d" id="r_a27845dc2ac5f1c5b89145cc0e4ac891d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a27845dc2ac5f1c5b89145cc0e4ac891d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a27845dc2ac5f1c5b89145cc0e4ac891d">minVecMacMutual</a> (const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;centerA, const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;sizeA, const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;centerB, const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;sizeB, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box, float invThetaEff)</td></tr>
<tr class="memdesc:a27845dc2ac5f1c5b89145cc0e4ac891d"><td class="mdescLeft">&#160;</td><td class="mdescRight">commutative combination of min-distance and vector map  <br /></td></tr>
<tr class="separator:a27845dc2ac5f1c5b89145cc0e4ac891d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f569845ca10ff4bacca42eed2fd287" id="r_a71f569845ca10ff4bacca42eed2fd287"><td class="memTemplParams" colspan="2">template&lt;class T , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a71f569845ca10ff4bacca42eed2fd287"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a71f569845ca10ff4bacca42eed2fd287">markMacPerBox</a> (const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;targetCenter, const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;targetSize, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *prefixes, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *childOffsets, const <a class="el" href="namespacecstone.html#a3c2b5abd635257ad027f958158d2ae21">Vec4</a>&lt; T &gt; *centers, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> focusStart, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> focusEnd, char *markings)</td></tr>
<tr class="memdesc:a71f569845ca10ff4bacca42eed2fd287"><td class="mdescLeft">&#160;</td><td class="mdescRight">mark all nodes of <code>octree</code> (leaves and internal) that fail the evaluateMac w.r.t to <code>target</code>  <br /></td></tr>
<tr class="separator:a71f569845ca10ff4bacca42eed2fd287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada05a9ac34188ec75a417d15ef0ecbd1" id="r_ada05a9ac34188ec75a417d15ef0ecbd1"><td class="memTemplParams" colspan="2">template&lt;class T , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:ada05a9ac34188ec75a417d15ef0ecbd1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ada05a9ac34188ec75a417d15ef0ecbd1">markMacs</a> (const <a class="el" href="structcstone_1_1OctreeView.html">OctreeView</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;octree, const <a class="el" href="namespacecstone.html#a3c2b5abd635257ad027f958158d2ae21">Vec4</a>&lt; T &gt; *centers, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> focusStart, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> focusEnd, char *markings)</td></tr>
<tr class="memdesc:ada05a9ac34188ec75a417d15ef0ecbd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark each node in an octree that fails the MAC paired with any node from a given focus SFC range.  <br /></td></tr>
<tr class="separator:ada05a9ac34188ec75a417d15ef0ecbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d4e6d74e234a922ea605def1c0068a" id="r_ab2d4e6d74e234a922ea605def1c0068a"><td class="memTemplParams" colspan="2">template&lt;class T , template&lt; class &gt; class TreeType, class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:ab2d4e6d74e234a922ea605def1c0068a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ab2d4e6d74e234a922ea605def1c0068a">findPeersMac</a> (int myRank, const <a class="el" href="classcstone_1_1SpaceCurveAssignment.html">SpaceCurveAssignment</a> &amp;assignment, const TreeType&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;domainTree, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box, float invThetaEff)</td></tr>
<tr class="memdesc:ab2d4e6d74e234a922ea605def1c0068a"><td class="mdescLeft">&#160;</td><td class="mdescRight">find peer ranks based on a multipole acceptance criterion and dual tree traversal  <br /></td></tr>
<tr class="separator:ab2d4e6d74e234a922ea605def1c0068a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b747b0fc3e494cad494566e8bdfb1b4" id="r_a6b747b0fc3e494cad494566e8bdfb1b4"><td class="memTemplParams" colspan="2">template&lt;template&lt; class &gt; class TreeType, class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </td></tr>
<tr class="memitem:a6b747b0fc3e494cad494566e8bdfb1b4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a6b747b0fc3e494cad494566e8bdfb1b4">findPeersMacStt</a> (int myRank, const <a class="el" href="classcstone_1_1SpaceCurveAssignment.html">SpaceCurveAssignment</a> &amp;assignment, const TreeType&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;octree, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box, float invThetaEff)</td></tr>
<tr class="memdesc:a6b747b0fc3e494cad494566e8bdfb1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Args identical to findPeersMac, but implemented with single tree traversal for comparison.  <br /></td></tr>
<tr class="separator:a6b747b0fc3e494cad494566e8bdfb1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0897f5abb9304cd370691d0f3acc2833" id="r_a0897f5abb9304cd370691d0f3acc2833"><td class="memTemplParams" colspan="2">template&lt;class C , class A &gt; </td></tr>
<tr class="memitem:a0897f5abb9304cd370691d0f3acc2833"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a0897f5abb9304cd370691d0f3acc2833">singleTraversal</a> (const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *childOffsets, C &amp;&amp;continuationCriterion, A &amp;&amp;endpointAction)</td></tr>
<tr class="separator:a0897f5abb9304cd370691d0f3acc2833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad407c13173a72b989bb057a20c57c2d2" id="r_ad407c13173a72b989bb057a20c57c2d2"><td class="memTemplParams" colspan="2">template&lt;class TreeType , class MAC , class M2L , class P2P &gt; </td></tr>
<tr class="memitem:ad407c13173a72b989bb057a20c57c2d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ad407c13173a72b989bb057a20c57c2d2">dualTraversal</a> (const TreeType &amp;octree, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> a, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> b, MAC &amp;&amp;continuation, M2L &amp;&amp;m2l, P2P &amp;&amp;p2p)</td></tr>
<tr class="memdesc:ad407c13173a72b989bb057a20c57c2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic dual-traversal of a tree with pairs of indices. Also called simultaneous traversal.  <br /></td></tr>
<tr class="separator:ad407c13173a72b989bb057a20c57c2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04fb4d5442270713bb8bc7aeca3b0b82" id="r_a04fb4d5442270713bb8bc7aeca3b0b82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a04fb4d5442270713bb8bc7aeca3b0b82">isLeafIndex</a> (<a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> nodeIndex)</td></tr>
<tr class="memdesc:a04fb4d5442270713bb8bc7aeca3b0b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">checks whether a binary tree index corresponds to a leaf index  <br /></td></tr>
<tr class="separator:a04fb4d5442270713bb8bc7aeca3b0b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac79408cd9f7644d48fe84a48c42ae163" id="r_ac79408cd9f7644d48fe84a48c42ae163"><td class="memItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ac79408cd9f7644d48fe84a48c42ae163">storeLeafIndex</a> (<a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> index)</td></tr>
<tr class="memdesc:ac79408cd9f7644d48fe84a48c42ae163"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a leaf index to the storage format  <br /></td></tr>
<tr class="separator:ac79408cd9f7644d48fe84a48c42ae163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e8197184b6d3da4357baf1dd8d9cf57" id="r_a7e8197184b6d3da4357baf1dd8d9cf57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a7e8197184b6d3da4357baf1dd8d9cf57">loadLeafIndex</a> (<a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> index)</td></tr>
<tr class="memdesc:a7e8197184b6d3da4357baf1dd8d9cf57"><td class="mdescLeft">&#160;</td><td class="mdescRight">restore a leaf index from the storage format  <br /></td></tr>
<tr class="separator:a7e8197184b6d3da4357baf1dd8d9cf57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211fab363a1ee0bf71c0729c23975e7c" id="r_a211fab363a1ee0bf71c0729c23975e7c"><td class="memTemplParams" colspan="2">template&lt;class I &gt; </td></tr>
<tr class="memitem:a211fab363a1ee0bf71c0729c23975e7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a211fab363a1ee0bf71c0729c23975e7c">findSplit</a> (const I *sortedSfcCodes, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> first, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> last)</td></tr>
<tr class="memdesc:a211fab363a1ee0bf71c0729c23975e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">find position of first differing bit  <br /></td></tr>
<tr class="separator:a211fab363a1ee0bf71c0729c23975e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce484ffced62baff6f1a37e20b3404e" id="r_a9ce484ffced62baff6f1a37e20b3404e"><td class="memTemplParams" colspan="2">template&lt;class I &gt; </td></tr>
<tr class="memitem:a9ce484ffced62baff6f1a37e20b3404e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a9ce484ffced62baff6f1a37e20b3404e">constructInternalNode</a> (const I *codes, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> nCodes, <a class="el" href="structcstone_1_1BinaryNode.html">BinaryNode</a>&lt; I &gt; *internalNodes, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> firstIndex)</td></tr>
<tr class="memdesc:a9ce484ffced62baff6f1a37e20b3404e"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct the internal binary tree node with index idx  <br /></td></tr>
<tr class="separator:a9ce484ffced62baff6f1a37e20b3404e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5282c3fcbcc6e1a2f714c5598c5d99a3" id="r_a5282c3fcbcc6e1a2f714c5598c5d99a3"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a5282c3fcbcc6e1a2f714c5598c5d99a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a5282c3fcbcc6e1a2f714c5598c5d99a3">createBinaryTree</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *tree, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> <a class="el" href="namespacecstone.html#a1dbc37f14064985ccf1d261936b2f56c">nNodes</a>, <a class="el" href="structcstone_1_1BinaryNode.html">BinaryNode</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; *binaryTree)</td></tr>
<tr class="memdesc:a5282c3fcbcc6e1a2f714c5598c5d99a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a binary radix tree from a cornerstone octree  <br /></td></tr>
<tr class="separator:a5282c3fcbcc6e1a2f714c5598c5d99a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e025d9e90b740839839148eda01b39" id="r_ac8e025d9e90b740839839148eda01b39"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T , class F &gt; </td></tr>
<tr class="memitem:ac8e025d9e90b740839839148eda01b39"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ac8e025d9e90b740839839148eda01b39">continuumCount</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> nodeStart, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> nodeEnd, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box, F &amp;&amp;concentration)</td></tr>
<tr class="memdesc:ac8e025d9e90b740839839148eda01b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">estimate particle count of the given node based on the concentration continuum and node volume  <br /></td></tr>
<tr class="separator:ac8e025d9e90b740839839148eda01b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90ec813afb97dd1ca1c9a96a6bc1e05" id="r_ae90ec813afb97dd1ca1c9a96a6bc1e05"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T , class F &gt; </td></tr>
<tr class="memitem:ae90ec813afb97dd1ca1c9a96a6bc1e05"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ae90ec813afb97dd1ca1c9a96a6bc1e05">computeContinuumCounts</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *tree, unsigned *counts, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> numNodes, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box, F &amp;&amp;concentration)</td></tr>
<tr class="separator:ae90ec813afb97dd1ca1c9a96a6bc1e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fe3b49146bae7b2c48dcd93f720cd7" id="r_a51fe3b49146bae7b2c48dcd93f720cd7"><td class="memTemplParams" colspan="2">template&lt;class F , class T , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a51fe3b49146bae7b2c48dcd93f720cd7"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a51fe3b49146bae7b2c48dcd93f720cd7">updateContinuumCsarray</a> (F &amp;&amp;concentration, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box, unsigned bucketSize, std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;tree, std::vector&lt; unsigned &gt; &amp;counts)</td></tr>
<tr class="separator:a51fe3b49146bae7b2c48dcd93f720cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d2e8e9837a2d152facaa83b61364cb" id="r_aa2d2e8e9837a2d152facaa83b61364cb"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class F , class T &gt; </td></tr>
<tr class="memitem:aa2d2e8e9837a2d152facaa83b61364cb"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;, std::vector&lt; unsigned &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aa2d2e8e9837a2d152facaa83b61364cb">computeContinuumCsarray</a> (F &amp;&amp;concentration, const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;box, unsigned bucketSize)</td></tr>
<tr class="memdesc:aa2d2e8e9837a2d152facaa83b61364cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build an a cornerstone array based on continuum particle concentration.  <br /></td></tr>
<tr class="separator:aa2d2e8e9837a2d152facaa83b61364cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae922edf0daae713c655238e3a455e444" id="r_ae922edf0daae713c655238e3a455e444"><td class="memTemplParams" colspan="2">template&lt;class I &gt; </td></tr>
<tr class="memitem:ae922edf0daae713c655238e3a455e444"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ae922edf0daae713c655238e3a455e444">checkOctreeInvariants</a> (const I *tree, int <a class="el" href="namespacecstone.html#a1dbc37f14064985ccf1d261936b2f56c">nNodes</a>)</td></tr>
<tr class="memdesc:ae922edf0daae713c655238e3a455e444"><td class="mdescLeft">&#160;</td><td class="mdescRight">check whether the cornerstone octree format invariants are fulfilled  <br /></td></tr>
<tr class="separator:ae922edf0daae713c655238e3a455e444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ec4b59cebfcf34d51cd47d329336bf" id="r_aa8ec4b59cebfcf34d51cd47d329336bf"><td class="memTemplParams" colspan="2">template&lt;class I &gt; </td></tr>
<tr class="memitem:aa8ec4b59cebfcf34d51cd47d329336bf"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aa8ec4b59cebfcf34d51cd47d329336bf">makeRootNodeTree</a> ()</td></tr>
<tr class="memdesc:aa8ec4b59cebfcf34d51cd47d329336bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns an octree with just the root node  <br /></td></tr>
<tr class="separator:aa8ec4b59cebfcf34d51cd47d329336bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55c9d16d29b405984e5e7e9a547017f8" id="r_a55c9d16d29b405984e5e7e9a547017f8"><td class="memTemplParams" colspan="2">template&lt;class I &gt; </td></tr>
<tr class="memitem:a55c9d16d29b405984e5e7e9a547017f8"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a55c9d16d29b405984e5e7e9a547017f8">makeNLevelGrid</a> (int level)</td></tr>
<tr class="memdesc:a55c9d16d29b405984e5e7e9a547017f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a uniform grid of SFC codes  <br /></td></tr>
<tr class="separator:a55c9d16d29b405984e5e7e9a547017f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f92230428b7a80937108192b446c6ec" id="r_a7f92230428b7a80937108192b446c6ec"><td class="memTemplParams" colspan="2">template&lt;class I &gt; </td></tr>
<tr class="memitem:a7f92230428b7a80937108192b446c6ec"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; I &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a7f92230428b7a80937108192b446c6ec">makeUniformNLevelTree</a> (std::size_t nParticles, int bucketSize)</td></tr>
<tr class="memdesc:a7f92230428b7a80937108192b446c6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a uniform cornerstone octree with 8^ceil(log8(nBuckets)) nodes  <br /></td></tr>
<tr class="separator:a7f92230428b7a80937108192b446c6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73faa49f3e97ef9c4f648f95788b1383" id="r_a73faa49f3e97ef9c4f648f95788b1383"><td class="memTemplParams" colspan="2">template&lt;class I &gt; </td></tr>
<tr class="memitem:a73faa49f3e97ef9c4f648f95788b1383"><td class="memTemplItemLeft" align="right" valign="top">I&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a73faa49f3e97ef9c4f648f95788b1383">codeFromIndices</a> (std::array&lt; unsigned char, <a class="el" href="structcstone_1_1maxTreeLevel.html">maxTreeLevel</a>&lt; uint64_t &gt;{}&gt; indices)</td></tr>
<tr class="memdesc:a73faa49f3e97ef9c4f648f95788b1383"><td class="mdescLeft">&#160;</td><td class="mdescRight">transfer a series of hierarchical octree indices into a morton code  <br /></td></tr>
<tr class="separator:a73faa49f3e97ef9c4f648f95788b1383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7352f342f22c452ac104f0dc3c49dcfa" id="r_a7352f342f22c452ac104f0dc3c49dcfa"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a7352f342f22c452ac104f0dc3c49dcfa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a7352f342f22c452ac104f0dc3c49dcfa">findNodeBelow</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *tree, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> numNodes, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> key)</td></tr>
<tr class="memdesc:a7352f342f22c452ac104f0dc3c49dcfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">return first node that starts at or below (contains) key  <br /></td></tr>
<tr class="separator:a7352f342f22c452ac104f0dc3c49dcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dc0da6b08a06a674ba578a500b9951b" id="r_a5dc0da6b08a06a674ba578a500b9951b"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a5dc0da6b08a06a674ba578a500b9951b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a5dc0da6b08a06a674ba578a500b9951b">findNodeAbove</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *tree, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> numNodes, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> key)</td></tr>
<tr class="memdesc:a5dc0da6b08a06a674ba578a500b9951b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return first node that starts at or above key  <br /></td></tr>
<tr class="separator:a5dc0da6b08a06a674ba578a500b9951b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c73dcd6cf7a04a107df433cb38422a1" id="r_a9c73dcd6cf7a04a107df433cb38422a1"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a9c73dcd6cf7a04a107df433cb38422a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a9c73dcd6cf7a04a107df433cb38422a1">calculateNodeCount</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> nodeStart, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> nodeEnd, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *codesStart, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *codesEnd, size_t maxCount)</td></tr>
<tr class="memdesc:a9c73dcd6cf7a04a107df433cb38422a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">count particles in one tree node  <br /></td></tr>
<tr class="separator:a9c73dcd6cf7a04a107df433cb38422a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5d8ce1e40c6bb6c827b6172b3dc89f" id="r_adc5d8ce1e40c6bb6c827b6172b3dc89f"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:adc5d8ce1e40c6bb6c827b6172b3dc89f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="structutil_1_1array.html">util::array</a>&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#adc5d8ce1e40c6bb6c827b6172b3dc89f">findSearchBounds</a> (std::make_signed_t&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; firstIdx, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> targetCode, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *codesStart, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *codesEnd)</td></tr>
<tr class="memdesc:adc5d8ce1e40c6bb6c827b6172b3dc89f"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine search bound for <code>targetCode</code> in an array of sorted particle SFC codes  <br /></td></tr>
<tr class="separator:adc5d8ce1e40c6bb6c827b6172b3dc89f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e3d0a04ce76554a09310ecf1491637e" id="r_a0e3d0a04ce76554a09310ecf1491637e"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a0e3d0a04ce76554a09310ecf1491637e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a0e3d0a04ce76554a09310ecf1491637e">updateNodeCount</a> (<a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> nodeIdx, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *tree, std::make_signed_t&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; firstGuess, std::make_signed_t&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; secondGuess, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *codesStart, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *codesEnd, unsigned maxCount)</td></tr>
<tr class="memdesc:a0e3d0a04ce76554a09310ecf1491637e"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate node counts with a guess to accelerate the binary search  <br /></td></tr>
<tr class="separator:a0e3d0a04ce76554a09310ecf1491637e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cb008d94cbcd4793449db72656b81d" id="r_a11cb008d94cbcd4793449db72656b81d"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a11cb008d94cbcd4793449db72656b81d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a11cb008d94cbcd4793449db72656b81d">computeNodeCounts</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *tree, unsigned *counts, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> <a class="el" href="namespacecstone.html#a1dbc37f14064985ccf1d261936b2f56c">nNodes</a>, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *codesStart, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *codesEnd, unsigned maxCount, bool useCountsAsGuess=false)</td></tr>
<tr class="memdesc:a11cb008d94cbcd4793449db72656b81d"><td class="mdescLeft">&#160;</td><td class="mdescRight">count number of particles in each octree node  <br /></td></tr>
<tr class="separator:a11cb008d94cbcd4793449db72656b81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4411d480bef1d2248a7588f15cf56108" id="r_a4411d480bef1d2248a7588f15cf56108"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a4411d480bef1d2248a7588f15cf56108"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">util::tuple</a>&lt; int, unsigned &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a4411d480bef1d2248a7588f15cf56108">siblingAndLevel</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *csTree, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> nodeIdx)</td></tr>
<tr class="memdesc:a4411d480bef1d2248a7588f15cf56108"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the sibling index and level of the specified csTree node  <br /></td></tr>
<tr class="separator:a4411d480bef1d2248a7588f15cf56108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b86238125bbea713e167b3cd1086fd" id="r_a70b86238125bbea713e167b3cd1086fd"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a70b86238125bbea713e167b3cd1086fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a70b86238125bbea713e167b3cd1086fd">calculateNodeOp</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *tree, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> nodeIdx, const unsigned *counts, unsigned bucketSize)</td></tr>
<tr class="memdesc:a70b86238125bbea713e167b3cd1086fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns 0 for merging, 1 for no-change, 8 for splitting  <br /></td></tr>
<tr class="separator:a70b86238125bbea713e167b3cd1086fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64074858ad1cdf8d64e35e43c2116184" id="r_a64074858ad1cdf8d64e35e43c2116184"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> &gt; </td></tr>
<tr class="memitem:a64074858ad1cdf8d64e35e43c2116184"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a64074858ad1cdf8d64e35e43c2116184">rebalanceDecision</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *tree, const unsigned *counts, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> <a class="el" href="namespacecstone.html#a1dbc37f14064985ccf1d261936b2f56c">nNodes</a>, unsigned bucketSize, <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> *nodeOps)</td></tr>
<tr class="memdesc:a64074858ad1cdf8d64e35e43c2116184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute split or fuse decision for each octree node in parallel.  <br /></td></tr>
<tr class="separator:a64074858ad1cdf8d64e35e43c2116184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab037b5d134c9a444399ff0830e3ef7b7" id="r_ab037b5d134c9a444399ff0830e3ef7b7"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:ab037b5d134c9a444399ff0830e3ef7b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ab037b5d134c9a444399ff0830e3ef7b7">processNode</a> (<a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> nodeIndex, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *oldTree, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *nodeOps, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *newTree)</td></tr>
<tr class="memdesc:ab037b5d134c9a444399ff0830e3ef7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">transform old nodes into new nodes based on opcodes  <br /></td></tr>
<tr class="separator:ab037b5d134c9a444399ff0830e3ef7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30283c76e76daa6b00f4f4c7d381b758" id="r_a30283c76e76daa6b00f4f4c7d381b758"><td class="memTemplParams" colspan="2">template&lt;class InputVector , class OutputVector &gt; </td></tr>
<tr class="memitem:a30283c76e76daa6b00f4f4c7d381b758"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a30283c76e76daa6b00f4f4c7d381b758">rebalanceTree</a> (const InputVector &amp;tree, OutputVector &amp;newTree, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *nodeOps)</td></tr>
<tr class="memdesc:a30283c76e76daa6b00f4f4c7d381b758"><td class="mdescLeft">&#160;</td><td class="mdescRight">split or fuse octree nodes based on node counts relative to bucketSize  <br /></td></tr>
<tr class="separator:a30283c76e76daa6b00f4f4c7d381b758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a1ec7cae65b6e22b7ca82cb56766e1" id="r_a88a1ec7cae65b6e22b7ca82cb56766e1"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a88a1ec7cae65b6e22b7ca82cb56766e1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a88a1ec7cae65b6e22b7ca82cb56766e1">updateOctree</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *codesStart, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *codesEnd, unsigned bucketSize, std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;tree, std::vector&lt; unsigned &gt; &amp;counts, unsigned maxCount=std::numeric_limits&lt; unsigned &gt;::max())</td></tr>
<tr class="memdesc:a88a1ec7cae65b6e22b7ca82cb56766e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the octree with a single rebalance/count step  <br /></td></tr>
<tr class="separator:a88a1ec7cae65b6e22b7ca82cb56766e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9140b3f62c0d76d10f40fb464ffb7d8" id="r_ab9140b3f62c0d76d10f40fb464ffb7d8"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:ab9140b3f62c0d76d10f40fb464ffb7d8"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;, std::vector&lt; unsigned &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ab9140b3f62c0d76d10f40fb464ffb7d8">computeOctree</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *codesStart, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *codesEnd, unsigned bucketSize, unsigned maxCount=std::numeric_limits&lt; unsigned &gt;::max())</td></tr>
<tr class="memdesc:ab9140b3f62c0d76d10f40fb464ffb7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience wrapper for updateOctree. Start from scratch and return a fully converged cornerstone tree.  <br /></td></tr>
<tr class="separator:ab9140b3f62c0d76d10f40fb464ffb7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bb6086c47be8ddb833d56d0b576382" id="r_af5bb6086c47be8ddb833d56d0b576382"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:af5bb6086c47be8ddb833d56d0b576382"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#af5bb6086c47be8ddb833d56d0b576382">updateTreelet</a> (gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; treelet, gsl::span&lt; const unsigned &gt; counts, unsigned bucketSize)</td></tr>
<tr class="memdesc:af5bb6086c47be8ddb833d56d0b576382"><td class="mdescLeft">&#160;</td><td class="mdescRight">update a treelet (sub-octree not spanning full SFC) based on node counts  <br /></td></tr>
<tr class="separator:af5bb6086c47be8ddb833d56d0b576382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3304e05eace94cbb9fcc9623fbbc10" id="r_aac3304e05eace94cbb9fcc9623fbbc10"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:aac3304e05eace94cbb9fcc9623fbbc10"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aac3304e05eace94cbb9fcc9623fbbc10">computeSpanningTree</a> (gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; spanningKeys)</td></tr>
<tr class="memdesc:aac3304e05eace94cbb9fcc9623fbbc10"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a cornerstone octree around a series of given SFC codes  <br /></td></tr>
<tr class="separator:aac3304e05eace94cbb9fcc9623fbbc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54fe2d447f490b59383a4e81fb01eeb" id="r_ac54fe2d447f490b59383a4e81fb01eeb"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:ac54fe2d447f490b59383a4e81fb01eeb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ac54fe2d447f490b59383a4e81fb01eeb">computeNodeCountsGpu</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *tree, unsigned *counts, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> numNodes, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *firstKey, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *lastKey, unsigned maxCount, bool useCountsAsGuess=false)</td></tr>
<tr class="memdesc:ac54fe2d447f490b59383a4e81fb01eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">count number of particles in each octree node  <br /></td></tr>
<tr class="separator:ac54fe2d447f490b59383a4e81fb01eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7405ab60f72143816f24e7d8171404a0" id="r_a7405ab60f72143816f24e7d8171404a0"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a7405ab60f72143816f24e7d8171404a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a7405ab60f72143816f24e7d8171404a0">computeNodeOpsGpu</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *tree, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> numNodes, const unsigned *counts, unsigned bucketSize, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *nodeOps)</td></tr>
<tr class="memdesc:a7405ab60f72143816f24e7d8171404a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">split or fuse octree nodes based on node counts relative to bucketSize  <br /></td></tr>
<tr class="separator:a7405ab60f72143816f24e7d8171404a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8e2a6dc6e18bf9c83704ada3011c36" id="r_a9b8e2a6dc6e18bf9c83704ada3011c36"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a9b8e2a6dc6e18bf9c83704ada3011c36"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a9b8e2a6dc6e18bf9c83704ada3011c36">rebalanceTreeGpu</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *tree, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> numNodes, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> newNumNodes, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *nodeOps, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *newTree)</td></tr>
<tr class="separator:a9b8e2a6dc6e18bf9c83704ada3011c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbc37f14064985ccf1d261936b2f56c" id="r_a1dbc37f14064985ccf1d261936b2f56c"><td class="memTemplParams" colspan="2">template&lt;class Vector &gt; </td></tr>
<tr class="memitem:a1dbc37f14064985ccf1d261936b2f56c"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a1dbc37f14064985ccf1d261936b2f56c">nNodes</a> (const Vector &amp;tree)</td></tr>
<tr class="memdesc:a1dbc37f14064985ccf1d261936b2f56c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of nodes in a tree  <br /></td></tr>
<tr class="separator:a1dbc37f14064985ccf1d261936b2f56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e2062bd79da67bece5d065b0796b9d" id="r_ad9e2062bd79da67bece5d065b0796b9d"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:ad9e2062bd79da67bece5d065b0796b9d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#ad9e2062bd79da67bece5d065b0796b9d">binaryKeyWeight</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> key, unsigned level)</td></tr>
<tr class="memdesc:ad9e2062bd79da67bece5d065b0796b9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">map a binary node index to an octree node index  <br /></td></tr>
<tr class="separator:ad9e2062bd79da67bece5d065b0796b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058a1896a0a9b902a06b45ef9c3988ba" id="r_a058a1896a0a9b902a06b45ef9c3988ba"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a058a1896a0a9b902a06b45ef9c3988ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a058a1896a0a9b902a06b45ef9c3988ba">createUnsortedLayoutCpu</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *leaves, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> numInternalNodes, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> numLeafNodes, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *prefixes, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *internalToLeaf)</td></tr>
<tr class="memdesc:a058a1896a0a9b902a06b45ef9c3988ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">combine internal and leaf tree parts into a single array with the nodeKey prefixes  <br /></td></tr>
<tr class="separator:a058a1896a0a9b902a06b45ef9c3988ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f863c69e15e957dbd75ad5cc049340" id="r_af7f863c69e15e957dbd75ad5cc049340"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:af7f863c69e15e957dbd75ad5cc049340"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#af7f863c69e15e957dbd75ad5cc049340">linkTreeCpu</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *prefixes, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> numInternalNodes, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *<a class="el" href="namespacecstone.html#a9c12e16cab4a89d81bc2e07ac2c2f9f3">leafToInternal</a>, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *levelRange, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *childOffsets, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *parents)</td></tr>
<tr class="memdesc:af7f863c69e15e957dbd75ad5cc049340"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract parent/child relationships from binary tree and translate to sorted order  <br /></td></tr>
<tr class="separator:af7f863c69e15e957dbd75ad5cc049340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd20c14b8f8bc227c4c0181a4a0bf9fa" id="r_abd20c14b8f8bc227c4c0181a4a0bf9fa"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:abd20c14b8f8bc227c4c0181a4a0bf9fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#abd20c14b8f8bc227c4c0181a4a0bf9fa">getLevelRangeCpu</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *nodeKeys, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> numNodes, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *levelRange)</td></tr>
<tr class="memdesc:abd20c14b8f8bc227c4c0181a4a0bf9fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">determine the octree subdivision level boundaries  <br /></td></tr>
<tr class="separator:abd20c14b8f8bc227c4c0181a4a0bf9fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffc5a21c54e9bf040740f8c89b3363c" id="r_adffc5a21c54e9bf040740f8c89b3363c"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:adffc5a21c54e9bf040740f8c89b3363c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#adffc5a21c54e9bf040740f8c89b3363c">buildOctreeCpu</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *cstoneTree, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> numLeafNodes, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> numInternalNodes, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *prefixes, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *childOffsets, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *parents, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *levelRange, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *internalToLeaf, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *<a class="el" href="namespacecstone.html#a9c12e16cab4a89d81bc2e07ac2c2f9f3">leafToInternal</a>)</td></tr>
<tr class="memdesc:adffc5a21c54e9bf040740f8c89b3363c"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct the internal octree part of a given octree leaf cell array on the GPU  <br /></td></tr>
<tr class="separator:adffc5a21c54e9bf040740f8c89b3363c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d98b14c83424cc18ef39d8f6b38d8d8" id="r_a2d98b14c83424cc18ef39d8f6b38d8d8"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a2d98b14c83424cc18ef39d8f6b38d8d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a2d98b14c83424cc18ef39d8f6b38d8d8">locateNode</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> nodeKey, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *prefixes, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *levelRange)</td></tr>
<tr class="memdesc:a2d98b14c83424cc18ef39d8f6b38d8d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">locate with <code>nodeKey</code> given in Warren-Salmon placeholder-bit format  <br /></td></tr>
<tr class="separator:a2d98b14c83424cc18ef39d8f6b38d8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae35e7010bca5c00123ca2e3372fb8e7" id="r_aae35e7010bca5c00123ca2e3372fb8e7"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:aae35e7010bca5c00123ca2e3372fb8e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aae35e7010bca5c00123ca2e3372fb8e7">locateNode</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> startKey, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> endKey, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *prefixes, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *levelRange)</td></tr>
<tr class="memdesc:aae35e7010bca5c00123ca2e3372fb8e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the index of the node with SFC key range [startKey:endKey]  <br /></td></tr>
<tr class="separator:aae35e7010bca5c00123ca2e3372fb8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db91b41610ef07e5923e0700efec461" id="r_a7db91b41610ef07e5923e0700efec461"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a7db91b41610ef07e5923e0700efec461"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a7db91b41610ef07e5923e0700efec461">containingNode</a> (<a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> nodeKey, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *prefixes, const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *childOffsets)</td></tr>
<tr class="memdesc:a7db91b41610ef07e5923e0700efec461"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the smallest node that contains <code>nodeKey</code>  <br /></td></tr>
<tr class="separator:a7db91b41610ef07e5923e0700efec461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5887e9a73201a008261f28051232d9f7" id="r_a5887e9a73201a008261f28051232d9f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a5887e9a73201a008261f28051232d9f7">maxDepth</a> (const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *levelOffsets, <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> level)</td></tr>
<tr class="separator:a5887e9a73201a008261f28051232d9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090ebf42ad9e3fcc46e9e1801b61cf3c" id="r_a090ebf42ad9e3fcc46e9e1801b61cf3c"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a090ebf42ad9e3fcc46e9e1801b61cf3c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a090ebf42ad9e3fcc46e9e1801b61cf3c">updateInternalTree</a> (gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; leaves, <a class="el" href="structcstone_1_1OctreeView.html">OctreeView</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; o)</td></tr>
<tr class="separator:a090ebf42ad9e3fcc46e9e1801b61cf3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c12e16cab4a89d81bc2e07ac2c2f9f3" id="r_a9c12e16cab4a89d81bc2e07ac2c2f9f3"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class Accelerator &gt; </td></tr>
<tr class="memitem:a9c12e16cab4a89d81bc2e07ac2c2f9f3"><td class="memTemplItemLeft" align="right" valign="top">gsl::span&lt; const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a9c12e16cab4a89d81bc2e07ac2c2f9f3">leafToInternal</a> (const <a class="el" href="classcstone_1_1OctreeData.html">OctreeData</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>, Accelerator &gt; &amp;octree)</td></tr>
<tr class="separator:a9c12e16cab4a89d81bc2e07ac2c2f9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadfa5884a2d8afd6ccedc727ef7e5714" id="r_aadfa5884a2d8afd6ccedc727ef7e5714"><td class="memTemplParams" colspan="2">template&lt;class T , class CombinationFunction &gt; </td></tr>
<tr class="memitem:aadfa5884a2d8afd6ccedc727ef7e5714"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#aadfa5884a2d8afd6ccedc727ef7e5714">upsweep</a> (gsl::span&lt; const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt; levelOffset, gsl::span&lt; const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt; childOffsets, T *quantities, CombinationFunction &amp;&amp;combinationFunction)</td></tr>
<tr class="separator:aadfa5884a2d8afd6ccedc727ef7e5714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa2b5275fcf299ae834f893fb786182" id="r_a8fa2b5275fcf299ae834f893fb786182"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a8fa2b5275fcf299ae834f893fb786182"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a8fa2b5275fcf299ae834f893fb786182">buildOctreeGpu</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *cstoneTree, <a class="el" href="structcstone_1_1OctreeView.html">OctreeView</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; d)</td></tr>
<tr class="memdesc:a8fa2b5275fcf299ae834f893fb786182"><td class="mdescLeft">&#160;</td><td class="mdescRight">construct the internal octree part of a given octree leaf cell array on the GPU  <br /></td></tr>
<tr class="separator:a8fa2b5275fcf299ae834f893fb786182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cf065220a8232bdedfaa255d405ffa" id="r_a42cf065220a8232bdedfaa255d405ffa"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a42cf065220a8232bdedfaa255d405ffa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a42cf065220a8232bdedfaa255d405ffa">updateOctreeGlobal</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *keyStart, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *keyEnd, unsigned bucketSize, std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;tree, std::vector&lt; unsigned &gt; &amp;counts)</td></tr>
<tr class="memdesc:a42cf065220a8232bdedfaa255d405ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform one octree update, consisting of one rebalance and one node counting step  <br /></td></tr>
<tr class="separator:a42cf065220a8232bdedfaa255d405ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcac472e9a458b39654d869ee33435a" id="r_a0dcac472e9a458b39654d869ee33435a"><td class="memTemplParams" colspan="2">template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </td></tr>
<tr class="memitem:a0dcac472e9a458b39654d869ee33435a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a0dcac472e9a458b39654d869ee33435a">updateOctreeGlobal</a> (const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *keyStart, const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *keyEnd, unsigned bucketSize, <a class="el" href="classcstone_1_1Octree.html">Octree</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;tree, std::vector&lt; unsigned &gt; &amp;counts)</td></tr>
<tr class="memdesc:a0dcac472e9a458b39654d869ee33435a"><td class="mdescLeft">&#160;</td><td class="mdescRight">global update step of an octree, including regeneration of the internal node structure  <br /></td></tr>
<tr class="separator:a0dcac472e9a458b39654d869ee33435a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6856f8936f03359f68fee86ea43ecd1b" id="r_a6856f8936f03359f68fee86ea43ecd1b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a6856f8936f03359f68fee86ea43ecd1b">gatherCpu</a></td></tr>
<tr class="memdesc:a6856f8936f03359f68fee86ea43ecd1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lambda to avoid templated functors that would become template-template parameters when passed to functions.  <br /></td></tr>
<tr class="separator:a6856f8936f03359f68fee86ea43ecd1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e34f9437a564d29f806c424793680ca" id="r_a3e34f9437a564d29f806c424793680ca"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a3e34f9437a564d29f806c424793680ca">gatherGpuL</a></td></tr>
<tr class="memdesc:a3e34f9437a564d29f806c424793680ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lambda to avoid templated functors that would become template-template parameters when passed to functions.  <br /></td></tr>
<tr class="separator:a3e34f9437a564d29f806c424793680ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512a141ed0f250c7cb25ce891981d0aa" id="r_a512a141ed0f250c7cb25ce891981d0aa"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecstone.html#a512a141ed0f250c7cb25ce891981d0aa">eightSiblings</a> = 8</td></tr>
<tr class="memdesc:a512a141ed0f250c7cb25ce891981d0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fixed number of children per node.  <br /></td></tr>
<tr class="separator:a512a141ed0f250c7cb25ce891981d0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a17864a21bbfcf1e20ef7c834edae7cf3" name="a17864a21bbfcf1e20ef7c834edae7cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17864a21bbfcf1e20ef7c834edae7cf3">&#9670;&#160;</a></span>FBox</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecstone.html#a17864a21bbfcf1e20ef7c834edae7cf3">cstone::FBox</a> = typedef <a class="el" href="classcstone_1_1SimpleBox.html">SimpleBox</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c6d0a9f945916bff359b92736f003c4" name="a6c6d0a9f945916bff359b92736f003c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6d0a9f945916bff359b92736f003c4">&#9670;&#160;</a></span>HilbertKey</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IntegerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecstone.html#a6c6d0a9f945916bff359b92736f003c4">cstone::HilbertKey</a> = typedef <a class="el" href="structStrongType.html">StrongType</a>&lt;IntegerType, struct HilbertKeyTag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strong type for Hilbert keys. </p>

</div>
</div>
<a id="a72f04118d59095aa5ac36e505d445d0b" name="a72f04118d59095aa5ac36e505d445d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f04118d59095aa5ac36e505d445d0b">&#9670;&#160;</a></span>IBox</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">cstone::IBox</a> = typedef <a class="el" href="classcstone_1_1SimpleBox.html">SimpleBox</a>&lt;int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e01a219224a6310ad91973dbcaf1b1e" name="a4e01a219224a6310ad91973dbcaf1b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e01a219224a6310ad91973dbcaf1b1e">&#9670;&#160;</a></span>LocalIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">cstone::LocalIndex</a> = typedef unsigned</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>index type of local particle arrays </p>

</div>
</div>
<a id="ac3aaa9bdf295f6d863bd8af0b9c95b38" name="ac3aaa9bdf295f6d863bd8af0b9c95b38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3aaa9bdf295f6d863bd8af0b9c95b38">&#9670;&#160;</a></span>MortonKey</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IntegerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecstone.html#ac3aaa9bdf295f6d863bd8af0b9c95b38">cstone::MortonKey</a> = typedef <a class="el" href="structStrongType.html">StrongType</a>&lt;IntegerType, struct MortonKeyTag&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Strong type for Morton keys. </p>

</div>
</div>
<a id="a91ab04d838fb61ba643368b6419793df" name="a91ab04d838fb61ba643368b6419793df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ab04d838fb61ba643368b6419793df">&#9670;&#160;</a></span>SendManifest</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecstone.html#a91ab04d838fb61ba643368b6419793df">cstone::SendManifest</a> = typedef <a class="el" href="classcstone_1_1IndexRanges.html">IndexRanges</a>&lt;<a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>stores one or multiple index ranges of local particles to send out to another rank </p>

</div>
</div>
<a id="a4d054fd740773a4ffbaecadfb6cecf92" name="a4d054fd740773a4ffbaecadfb6cecf92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d054fd740773a4ffbaecadfb6cecf92">&#9670;&#160;</a></span>SfcKind</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IntegerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecstone.html#a4d054fd740773a4ffbaecadfb6cecf92">cstone::SfcKind</a> = typedef <a class="el" href="namespacecstone.html#a6c6d0a9f945916bff359b92736f003c4">HilbertKey</a>&lt;IntegerType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>use this definition to select the kind of space filling curve to use </p>

</div>
</div>
<a id="a3767e831204a1a7e180456eced6d15e5" name="a3767e831204a1a7e180456eced6d15e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3767e831204a1a7e180456eced6d15e5">&#9670;&#160;</a></span>SourceCenterType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecstone.html#a3767e831204a1a7e180456eced6d15e5">cstone::SourceCenterType</a> = typedef <a class="el" href="structutil_1_1array.html">util::array</a>&lt;T, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab92e8dfcff11066ac75330812a896de9" name="ab92e8dfcff11066ac75330812a896de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92e8dfcff11066ac75330812a896de9">&#9670;&#160;</a></span>TreeIndexPair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecstone.html#ab92e8dfcff11066ac75330812a896de9">cstone::TreeIndexPair</a> = typedef <a class="el" href="structcstone_1_1IndexPair.html">IndexPair</a>&lt;<a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02ddbbe0e6bf938c6b5675d15fd3ced3" name="a02ddbbe0e6bf938c6b5675d15fd3ced3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ddbbe0e6bf938c6b5675d15fd3ced3">&#9670;&#160;</a></span>TreeNodeIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">cstone::TreeNodeIndex</a> = typedef int</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls the node index type, has to be signed. Change to 64-bit if more than 2 billion tree nodes are required. </p>

</div>
</div>
<a id="a7e1dfa0259eedf8f87f334dab04e92da" name="a7e1dfa0259eedf8f87f334dab04e92da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1dfa0259eedf8f87f334dab04e92da">&#9670;&#160;</a></span>Vec3</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">cstone::Vec3</a> = typedef <a class="el" href="structutil_1_1array.html">util::array</a>&lt;T, 3&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c2b5abd635257ad027f958158d2ae21" name="a3c2b5abd635257ad027f958158d2ae21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2b5abd635257ad027f958158d2ae21">&#9670;&#160;</a></span>Vec4</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacecstone.html#a3c2b5abd635257ad027f958158d2ae21">cstone::Vec4</a> = typedef <a class="el" href="structutil_1_1array.html">util::array</a>&lt;T, 4&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a2a0e1a8a75927421e319d5474fc7b816" name="a2a0e1a8a75927421e319d5474fc7b816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0e1a8a75927421e319d5474fc7b816">&#9670;&#160;</a></span>BoundaryType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacecstone.html#a2a0e1a8a75927421e319d5474fc7b816">cstone::BoundaryType</a> : char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2a0e1a8a75927421e319d5474fc7b816a7cef8a734855777c2a9d0caf42666e69" name="a2a0e1a8a75927421e319d5474fc7b816a7cef8a734855777c2a9d0caf42666e69"></a>open&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a0e1a8a75927421e319d5474fc7b816ae6ffdec5e14fce371eb7ae99edebbbee" name="a2a0e1a8a75927421e319d5474fc7b816ae6ffdec5e14fce371eb7ae99edebbbee"></a>periodic&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2a0e1a8a75927421e319d5474fc7b816acec315e3d0975e5cc2811d5d8725f149" name="a2a0e1a8a75927421e319d5474fc7b816acec315e3d0975e5cc2811d5d8725f149"></a>fixed&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a31981fd8652f4ff13624cecdd1bbce07" name="a31981fd8652f4ff13624cecdd1bbce07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31981fd8652f4ff13624cecdd1bbce07">&#9670;&#160;</a></span>P2pTags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacecstone.html#a31981fd8652f4ff13624cecdd1bbce07">cstone::P2pTags</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a31981fd8652f4ff13624cecdd1bbce07a7d2e7649b3ff02477d72c6ee3f2bf866" name="a31981fd8652f4ff13624cecdd1bbce07a7d2e7649b3ff02477d72c6ee3f2bf866"></a>focusTransfer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31981fd8652f4ff13624cecdd1bbce07abd5e7e1f0f5a0ba0b0e03e6193c35449" name="a31981fd8652f4ff13624cecdd1bbce07abd5e7e1f0f5a0ba0b0e03e6193c35449"></a>focusPeerCounts&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31981fd8652f4ff13624cecdd1bbce07a77a0dbbc4e6b9d704e43ebda2cc9161f" name="a31981fd8652f4ff13624cecdd1bbce07a77a0dbbc4e6b9d704e43ebda2cc9161f"></a>focusPeerCenters&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31981fd8652f4ff13624cecdd1bbce07a3bb747f80b8cf5e6a366bb5c3f5fbbab" name="a31981fd8652f4ff13624cecdd1bbce07a3bb747f80b8cf5e6a366bb5c3f5fbbab"></a>haloRequestKeys&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31981fd8652f4ff13624cecdd1bbce07aa2ae917ea9ba07793448fb827b899ac9" name="a31981fd8652f4ff13624cecdd1bbce07aa2ae917ea9ba07793448fb827b899ac9"></a>domainExchange&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a31981fd8652f4ff13624cecdd1bbce07a78664471a35a2ecded9c082a4a31ae0e" name="a31981fd8652f4ff13624cecdd1bbce07a78664471a35a2ecded9c082a4a31ae0e"></a>haloExchange&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a388434742a2abebe943b6f5445e6732b" name="a388434742a2abebe943b6f5445e6732b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388434742a2abebe943b6f5445e6732b">&#9670;&#160;</a></span>ResolutionStatus</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespacecstone.html#a388434742a2abebe943b6f5445e6732b">cstone::ResolutionStatus</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a388434742a2abebe943b6f5445e6732ba7de33615d7fbc1cb7bc608d12f1993d2" name="a388434742a2abebe943b6f5445e6732ba7de33615d7fbc1cb7bc608d12f1993d2"></a>converged&#160;</td><td class="fielddoc"><p>required SFC keys present in tree, no action needed </p>
</td></tr>
<tr><td class="fieldname"><a id="a388434742a2abebe943b6f5445e6732ba6c15ee6418136c7d340274db7d302858" name="a388434742a2abebe943b6f5445e6732ba6c15ee6418136c7d340274db7d302858"></a>cancelMerge&#160;</td><td class="fielddoc"><p>required SFC keys already present in tree, but had to cancel rebalance-merge operations </p>
</td></tr>
<tr><td class="fieldname"><a id="a388434742a2abebe943b6f5445e6732ba2971b584d3673ffb4dbcf822a50ee91e" name="a388434742a2abebe943b6f5445e6732ba2971b584d3673ffb4dbcf822a50ee91e"></a>rebalance&#160;</td><td class="fielddoc"><p>subsequent rebalance can resolve the required SFC key by subdividing the closest node </p>
</td></tr>
<tr><td class="fieldname"><a id="a388434742a2abebe943b6f5445e6732ba26934eb377001f66e37289a5c93fe284" name="a388434742a2abebe943b6f5445e6732ba26934eb377001f66e37289a5c93fe284"></a>failed&#160;</td><td class="fielddoc"><p>subsequent rebalance cannot resolve the required SFC key with subdividing the closest node </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acb12a092d7e1b2024a8a952922e3ff29" name="acb12a092d7e1b2024a8a952922e3ff29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb12a092d7e1b2024a8a952922e3ff29">&#9670;&#160;</a></span>addBody()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> void cstone::addBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a3767e831204a1a7e180456eced6d15e5">SourceCenterType</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a3767e831204a1a7e180456eced6d15e5">SourceCenterType</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add a single body contribution to a mass center </p>

</div>
</div>
<a id="a9db476068a87e55ae7c268cfccd958fe" name="a9db476068a87e55ae7c268cfccd958fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db476068a87e55ae7c268cfccd958fe">&#9670;&#160;</a></span>addDelta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> int cstone::addDelta </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pbc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3bf6861918ed045b01aed162da49c0ca" name="a3bf6861918ed045b01aed162da49c0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf6861918ed045b01aed162da49c0ca">&#9670;&#160;</a></span>applyPBC()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tc , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> void cstone::applyPBC </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">cstone::Box</a>&lt; Tc &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>xx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>yy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>zz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Legacy PBC. </p>

</div>
</div>
<a id="a5d48aeeaa166d7d207d93e702cd67736" name="a5d48aeeaa166d7d207d93e702cd67736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d48aeeaa166d7d207d93e702cd67736">&#9670;&#160;</a></span>applyPbc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; cstone::applyPbc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>dX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the shortest periodic distance dX = A - B between two points,. </p>

</div>
</div>
<a id="ad9e2062bd79da67bece5d065b0796b9d" name="ad9e2062bd79da67bece5d065b0796b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e2062bd79da67bece5d065b0796b9d">&#9670;&#160;</a></span>binaryKeyWeight()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> cstone::binaryKeyWeight </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>map a binary node index to an octree node index </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>a cornerstone leaf cell key </td></tr>
    <tr><td class="paramname">level</td><td>the subdivision level of <code>key</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index offset</dd></dl>
<p>if</p><ul>
<li>cstree is a cornerstone leaf array</li>
<li>l = commonPrefix(cstree[j], cstree[j+1]), l % 3 == 0</li>
<li>k = cstree[j]</li>
</ul>
<p>then i = (j + binaryKeyWeight(k, l) / 7 equals the index of the internal octree node with key k, see unit test of this function for an illustration </p>

</div>
</div>
<a id="adffc5a21c54e9bf040740f8c89b3363c" name="adffc5a21c54e9bf040740f8c89b3363c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adffc5a21c54e9bf040740f8c89b3363c">&#9670;&#160;</a></span>buildOctreeCpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::buildOctreeCpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>cstoneTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>numLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>numInternalNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>childOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>parents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>levelRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>internalToLeaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>leafToInternal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct the internal octree part of a given octree leaf cell array on the GPU </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>unsigned 32- or 64-bit integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cstoneTree</td><td>GPU buffer with the SFC leaf cell keys </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8fa2b5275fcf299ae834f893fb786182" name="a8fa2b5275fcf299ae834f893fb786182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa2b5275fcf299ae834f893fb786182">&#9670;&#160;</a></span>buildOctreeGpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cstone::buildOctreeGpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>cstoneTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcstone_1_1OctreeView.html">OctreeView</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construct the internal octree part of a given octree leaf cell array on the GPU </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>unsigned 32- or 64-bit integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cstoneTree</td><td>GPU buffer with the SFC leaf cell keys </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d</td><td>input: pointers to pre-allocated GPU buffers for octree cells output: fully linked octree</td></tr>
  </table>
  </dd>
</dl>
<p>This does not allocate memory on the GPU, (except thrust temp buffers for scans and sorting) </p>

</div>
</div>
<a id="a9c73dcd6cf7a04a107df433cb38422a1" name="a9c73dcd6cf7a04a107df433cb38422a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c73dcd6cf7a04a107df433cb38422a1">&#9670;&#160;</a></span>calculateNodeCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> unsigned cstone::calculateNodeCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>nodeStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>nodeEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>codesStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>codesEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>count particles in one tree node </p>

</div>
</div>
<a id="a70b86238125bbea713e167b3cd1086fd" name="a70b86238125bbea713e167b3cd1086fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b86238125bbea713e167b3cd1086fd">&#9670;&#160;</a></span>calculateNodeOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> int cstone::calculateNodeOp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>nodeIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bucketSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns 0 for merging, 1 for no-change, 8 for splitting </p>

</div>
</div>
<a id="ab0c911adec30af9bcf3f090a02967c1b" name="ab0c911adec30af9bcf3f090a02967c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c911adec30af9bcf3f090a02967c1b">&#9670;&#160;</a></span>centerAndSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">util::tuple</a>&lt; <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt;, <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &gt; cstone::centerAndSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> &amp;&#160;</td>
          <td class="paramname"><em>ibox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculate floating point 3D center and radius of a and integer box and bounding box pair </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>float or double </td></tr>
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ibox</td><td>integer coordinate box </td></tr>
    <tr><td class="paramname">box</td><td>floating point bounding box </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the geometrical center and the vector from the center to the box corner farthest from the origin </dd></dl>

</div>
</div>
<a id="ae922edf0daae713c655238e3a455e444" name="ae922edf0daae713c655238e3a455e444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae922edf0daae713c655238e3a455e444">&#9670;&#160;</a></span>checkOctreeInvariants()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cstone::checkOctreeInvariants </td>
          <td>(</td>
          <td class="paramtype">const I *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check whether the cornerstone octree format invariants are fulfilled </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>32- or 64-bit unsigned integer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>octree nodes given as Morton codes of length <em>nNodes+1</em> </td></tr>
    <tr><td class="paramname">nNodes</td><td>number of nodes </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if invariants ar satisfied, false otherwise</dd></dl>
<p>The invariants are:</p><ul>
<li>tree contains code 0 and the maximum code 2^30 or 2^61</li>
<li>tree is sorted</li>
<li>difference between consecutive elements must be a power of 8 </li>
</ul>

</div>
</div>
<a id="a73faa49f3e97ef9c4f648f95788b1383" name="a73faa49f3e97ef9c4f648f95788b1383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73faa49f3e97ef9c4f648f95788b1383">&#9670;&#160;</a></span>codeFromIndices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">I cstone::codeFromIndices </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; unsigned char, <a class="el" href="structcstone_1_1maxTreeLevel.html">maxTreeLevel</a>&lt; uint64_t &gt;{}&gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>transfer a series of hierarchical octree indices into a morton code </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>indices[0] contains the octree index 0-7 for the top-level, indices[1] refers to the first subdivision, etc a 32-bit integer can resolve up to 10 layers, while a 64-bit integer can resolve 21 layers</td></tr>
  </table>
  </dd>
</dl>
<p>Note: all indices must be in the range [0-7]!</p>
<dl class="section return"><dt>Returns</dt><dd>the morton code </dd></dl>

</div>
</div>
<a id="a95cbcfe710369f388a0229b85bef0ffa" name="a95cbcfe710369f388a0229b85bef0ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95cbcfe710369f388a0229b85bef0ffa">&#9670;&#160;</a></span>commonNodePrefix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> cstone::commonNodePrefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">cstone::Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the smallest octree node in placeholder-bit format that contains the given floating point box. </p>

</div>
</div>
<a id="a78f509b9fb275cb8bf0d540681174822" name="a78f509b9fb275cb8bf0d540681174822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f509b9fb275cb8bf0d540681174822">&#9670;&#160;</a></span>commonPrefix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr int cstone::commonPrefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>key1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>key2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculate common prefix (cpr) of two SFC keys </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32 or 64 bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key1</td><td>first SFC code key </td></tr>
    <tr><td class="paramname">key2</td><td>second SFC code key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of continuous identical bits, counting from MSB minus the 2 unused bits in 32 bit codes or minus the 1 unused bit in 64 bit codes. </dd></dl>

</div>
</div>
<a id="a8e67b0f98874eda3f3bc50c49d79e5a2" name="a8e67b0f98874eda3f3bc50c49d79e5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e67b0f98874eda3f3bc50c49d79e5a2">&#9670;&#160;</a></span>computeByteOffsets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Arrays&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto cstone::computeByteOffsets </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arrays...&#160;</td>
          <td class="paramname"><em>arrays</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>each sub-buffer will be aligned on a <em>alignment-byte</em> aligned boundary</p>

</div>
</div>
<a id="ae90ec813afb97dd1ca1c9a96a6bc1e05" name="ae90ec813afb97dd1ca1c9a96a6bc1e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90ec813afb97dd1ca1c9a96a6bc1e05">&#9670;&#160;</a></span>computeContinuumCounts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::computeContinuumCounts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>concentration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2d2e8e9837a2d152facaa83b61364cb" name="aa2d2e8e9837a2d152facaa83b61364cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d2e8e9837a2d152facaa83b61364cb">&#9670;&#160;</a></span>computeContinuumCsarray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class F , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;, std::vector&lt; unsigned &gt; &gt; cstone::computeContinuumCsarray </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>concentration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bucketSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build an a cornerstone array based on continuum particle concentration. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
    <tr><td class="paramname">F</td><td>functor object </td></tr>
    <tr><td class="paramname">T</td><td>float or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">concentration</td><td>concentration function mapping (x,y,z) in <code>box</code> to a particle concentration </td></tr>
    <tr><td class="paramname">box</td><td>global coordinate bounding box </td></tr>
    <tr><td class="paramname">bucketSize</td><td>max number of particles per (leaf) node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple(csarray, counts) </dd></dl>

</div>
</div>
<a id="a8165efc91b4a594d357eb3ef12702de6" name="a8165efc91b4a594d357eb3ef12702de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8165efc91b4a594d357eb3ef12702de6">&#9670;&#160;</a></span>computeGeoCentersGpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cstone::computeGeoCentersGpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute geometric node center and sizes based on node SFC keys </p>

</div>
</div>
<a id="a40cde21101a4ca77d3499955752cf891" name="a40cde21101a4ca77d3499955752cf891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40cde21101a4ca77d3499955752cf891">&#9670;&#160;</a></span>computeHaloReceiveList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcstone_1_1SendList.html">SendList</a> cstone::computeHaloReceiveList </td>
          <td>(</td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> &gt;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const int &gt;&#160;</td>
          <td class="paramname"><em>haloFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="namespacecstone.html#ab92e8dfcff11066ac75330812a896de9">TreeIndexPair</a> &gt;&#160;</td>
          <td class="paramname"><em>assignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const int &gt;&#160;</td>
          <td class="paramname"><em>peerRanks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>computes a list which local array ranges are going to be filled with halo particles </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layout</td><td>prefix sum of leaf counts of locally present nodes (see computeNodeLayout) length N+1 </td></tr>
    <tr><td class="paramname">haloFlags</td><td>0 or 1 for each leaf, length N </td></tr>
    <tr><td class="paramname">assignment</td><td>assignment of leaf nodes to peer ranks </td></tr>
    <tr><td class="paramname">peerRanks</td><td>list of peer ranks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of array index ranges for the receiving part in exchangeHalos </dd></dl>

</div>
</div>
<a id="a5a3e9f74e4a895b164eb4fc56d67548a" name="a5a3e9f74e4a895b164eb4fc56d67548a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3e9f74e4a895b164eb4fc56d67548a">&#9670;&#160;</a></span>computeLeafMassCenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class T3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::computeLeafMassCenter </td>
          <td>(</td>
          <td class="paramtype">gsl::span&lt; const T1 &gt;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const T1 &gt;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const T1 &gt;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const T2 &gt;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt;&#160;</td>
          <td class="paramname"><em>leafToInternal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> *&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a3767e831204a1a7e180456eced6d15e5">SourceCenterType</a>&lt; T3 &gt; *&#160;</td>
          <td class="paramname"><em>sourceCenter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute mass center coordinates for leaf nodes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>source body x coordinates </td></tr>
    <tr><td class="paramname">y</td><td>source body y coordinates </td></tr>
    <tr><td class="paramname">z</td><td>source body z coordinates </td></tr>
    <tr><td class="paramname">m</td><td>source body masses </td></tr>
    <tr><td class="paramname">leafToInternal</td><td>translation map from cornerstone leaf cell array indices to node indices of the full octree </td></tr>
    <tr><td class="paramname">layout</td><td>array of length numLeafNodes + 1, the i-th element contains the index to of the first particle in x,y,z,m contained in the i-th leaf node of the octree </td></tr>
    <tr><td class="paramname">sourceCenter</td><td>array of length numNodes of the full octree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f786caffb83a2c5348c9f98a8290e6c" name="a7f786caffb83a2c5348c9f98a8290e6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f786caffb83a2c5348c9f98a8290e6c">&#9670;&#160;</a></span>computeLeafSourceCenterGpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tc , class Tm , class Tf &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cstone::computeLeafSourceCenterGpu </td>
          <td>(</td>
          <td class="paramtype">const Tc *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tc *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tc *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tm *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>leafToInternal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>numLeaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> *&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a3c2b5abd635257ad027f958158d2ae21">Vec4</a>&lt; Tf &gt; *&#160;</td>
          <td class="paramname"><em>centers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute mass centers of leaf cells </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>particle x coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>particle y coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>particle z coordinates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>particle masses </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">leafToInternal</td><td>maps a leaf node index to an internal layout node index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numLeaves</td><td>number of leaf nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">layout</td><td>particle location of each node, length <em>numLeaves</em> + 1 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">centers</td><td>output mass centers, in internal node layout, length &gt;= max(leafToInternal) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2943d299973f8dea28eb12cb4bfd05b1" name="a2943d299973f8dea28eb12cb4bfd05b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2943d299973f8dea28eb12cb4bfd05b1">&#9670;&#160;</a></span>computeMinMacR2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a3c2b5abd635257ad027f958158d2ae21">Vec4</a>&lt; T &gt; cstone::computeMinMacR2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>invThetaEff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute square of the acceptance radius for the minimum distance MAC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>SFC key of the tree cell with Warren-Salmon placeholder-bit </td></tr>
    <tr><td class="paramname">invThetaEff</td><td>1/theta + s (effective opening parameter) </td></tr>
    <tr><td class="paramname">box</td><td>global coordinate bounding box </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>geometric center in the first 3 elements, the square of the distance from <code>sourceCenter</code> beyond which the MAC fails or passes in the 4th element </dd></dl>

</div>
</div>
<a id="a11cb008d94cbcd4793449db72656b81d" name="a11cb008d94cbcd4793449db72656b81d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11cb008d94cbcd4793449db72656b81d">&#9670;&#160;</a></span>computeNodeCounts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::computeNodeCounts </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>nNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>codesStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>codesEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useCountsAsGuess</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>count number of particles in each octree node </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>octree nodes given as SFC codes of length <em>nNodes+1</em> needs to satisfy the octree invariants </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">counts</td><td>output particle counts per node, length = <em>nNodes</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nNodes</td><td>number of nodes in tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">codesStart</td><td>sorted particle SFC code range start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">codesEnd</td><td>sorted particle SFC code range end </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxCount</td><td>maximum particle count per node to store, this is used to prevent overflow in MPI_Allreduce </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac54fe2d447f490b59383a4e81fb01eeb" name="ac54fe2d447f490b59383a4e81fb01eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54fe2d447f490b59383a4e81fb01eeb">&#9670;&#160;</a></span>computeNodeCountsGpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cstone::computeNodeCountsGpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>firstKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>lastKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useCountsAsGuess</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>count number of particles in each octree node </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>octree nodes given as Morton codes of length <em>nNodes+1</em> needs to satisfy the octree invariants </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">counts</td><td>output particle counts per node, length = <em>nNodes</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numNodes</td><td>number of nodes in tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstKey</td><td>sorted particle SFC code range start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lastKey</td><td>sorted particle SFC code range end </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxCount</td><td>maximum particle count per node to store, this is used to prevent overflow in MPI_Allreduce </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9fd9a12b3c41b32a4e7c33b380e821f6" name="a9fd9a12b3c41b32a4e7c33b380e821f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd9a12b3c41b32a4e7c33b380e821f6">&#9670;&#160;</a></span>computeNodeLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cstone::computeNodeLayout </td>
          <td>(</td>
          <td class="paramtype">gsl::span&lt; const unsigned &gt;&#160;</td>
          <td class="paramname"><em>focusLeafCounts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const int &gt;&#160;</td>
          <td class="paramname"><em>haloFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>firstAssignedIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>lastAssignedIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> &gt;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculate the location (offset) of each focus tree leaf node in the particle arrays </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">focusLeafCounts</td><td>node counts of the focus leaves, size N </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">haloFlags</td><td>flag for each node, with a non-zero value if present as halo node, size N </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstAssignedIdx</td><td>first focus leaf idx to treat as part of the assigned nodes on the executing rank </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lastAssignedIdx</td><td>last focus leaf idx to treat as part of the assigned nodes on the executing rank </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">layout</td><td>length N+1. The first element is zero, the last element is equal to the sum of all all present (assigned+halo) node counts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7405ab60f72143816f24e7d8171404a0" name="a7405ab60f72143816f24e7d8171404a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7405ab60f72143816f24e7d8171404a0">&#9670;&#160;</a></span>computeNodeOpsGpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> cstone::computeNodeOpsGpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bucketSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>nodeOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>split or fuse octree nodes based on node counts relative to bucketSize </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>vector of octree nodes in cornerstone format, length = <code>numNodes</code> + 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numNodes</td><td>number of nodes in <code>tree</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counts</td><td>output particle counts per node, length = <code>tree.size()</code> - 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bucketSize</td><td>maximum particle count per (leaf) node and </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodeOps</td><td>node transformation codes, length = <code>numNodes</code> + 1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of nodes in the future rebalanced tree </dd></dl>

</div>
</div>
<a id="ab9140b3f62c0d76d10f40fb464ffb7d8" name="ab9140b3f62c0d76d10f40fb464ffb7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9140b3f62c0d76d10f40fb464ffb7d8">&#9670;&#160;</a></span>computeOctree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;, std::vector&lt; unsigned &gt; &gt; cstone::computeOctree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>codesStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>codesEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bucketSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxCount</em> = <code>std::numeric_limits&lt;unsigned&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience wrapper for updateOctree. Start from scratch and return a fully converged cornerstone tree. </p>

</div>
</div>
<a id="aaf448edc66cef42f59f85e742e4df114" name="aaf448edc66cef42f59f85e742e4df114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf448edc66cef42f59f85e742e4df114">&#9670;&#160;</a></span>computeSfcKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::computeSfcKeys </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>particleKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute the SFC keys for the input coordinate arrays </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>float or double </td></tr>
    <tr><td class="paramname">KeyType</td><td>HilbertKey or MortonKey </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>coordinate input arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">codeBegin</td><td>output for SFC keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>number of particles, size of input and output arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>coordinate bounding box </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3e9e74ae1bced8d15efa7ebae52c2e2" name="ad3e9e74ae1bced8d15efa7ebae52c2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e9e74ae1bced8d15efa7ebae52c2e2">&#9670;&#160;</a></span>computeSfcKeysGpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cstone::computeSfcKeysGpu </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aac3304e05eace94cbb9fcc9623fbbc10" name="aac3304e05eace94cbb9fcc9623fbbc10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3304e05eace94cbb9fcc9623fbbc10">&#9670;&#160;</a></span>computeSpanningTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; cstone::computeSpanningTree </td>
          <td>(</td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>spanningKeys</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a cornerstone octree around a series of given SFC codes </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIterator</td><td>iterator to 32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spanningKeys</td><td>input SFC key sequence </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the cornerstone octree containing all values in the given code sequence plus any additional intermediate SFC codes between them required to fulfill the cornerstone invariants.</dd></dl>
<p>Typical application: Generation of a minimal global tree where the input code sequence corresponds to the partitioning of the space filling curve into numMpiRanks intervals.</p>
<p>Requirements on the input sequence [firstCode:lastCode]:</p><ul>
<li>must start with 0, i.e. *firstCode == 0</li>
<li>must end with 2^30 or 2^63, i.e. *(lastCode - 1) == nodeRange&lt;CodeType&gt;(0) with CodeType =- std::decay_t&lt;decltype(*firstCode)&gt;</li>
<li>must be sorted </li>
</ul>

</div>
</div>
<a id="aa68f9bf47f0afed62abeb3333352f668" name="aa68f9bf47f0afed62abeb3333352f668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68f9bf47f0afed62abeb3333352f668">&#9670;&#160;</a></span>computeTotalSendBytes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int alignment, class... Arrays&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t cstone::computeTotalSendBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1SendList.html">SendList</a> &amp;&#160;</td>
          <td class="paramname"><em>sendList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thisRank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytesHeader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arrays...&#160;</td>
          <td class="paramname"><em>arrays</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>we add <em>alignment</em> bytes to the start of each message to provide space for the message length</p>

</div>
</div>
<a id="a1cbde3b7e05ff14f26d3ca47ddc367f9" name="a1cbde3b7e05ff14f26d3ca47ddc367f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbde3b7e05ff14f26d3ca47ddc367f9">&#9670;&#160;</a></span>computeTotalSendBytes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int alignment, class... Arrays&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t cstone::computeTotalSendBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1SendRanges.html">SendRanges</a> &amp;&#160;</td>
          <td class="paramname"><em>sends</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thisRank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytesHeader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arrays...&#160;</td>
          <td class="paramname"><em>arrays</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>we add <em>alignment</em> bytes to the start of each message to provide space for the message length</p>

</div>
</div>
<a id="a00710c213ab0c946ca126490d9144bca" name="a00710c213ab0c946ca126490d9144bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00710c213ab0c946ca126490d9144bca">&#9670;&#160;</a></span>computeVecMacR2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> T cstone::computeVecMacR2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>expCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>invTheta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute square of the acceptance radius for the vector MAC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>SFC key of the tree cell with Warren-Salmon placeholder-bit </td></tr>
    <tr><td class="paramname">expCenter</td><td>expansion (com) center of the source (cell) </td></tr>
    <tr><td class="paramname">invTheta</td><td>1/theta (opening parameter) </td></tr>
    <tr><td class="paramname">box</td><td>global coordinate bounding box </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the square of the distance from <code>sourceCenter</code> beyond which the MAC fails or passes </dd></dl>

</div>
</div>
<a id="a9ce484ffced62baff6f1a37e20b3404e" name="a9ce484ffced62baff6f1a37e20b3404e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce484ffced62baff6f1a37e20b3404e">&#9670;&#160;</a></span>constructInternalNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> void cstone::constructInternalNode </td>
          <td>(</td>
          <td class="paramtype">const I *&#160;</td>
          <td class="paramname"><em>codes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>nCodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcstone_1_1BinaryNode.html">BinaryNode</a>&lt; I &gt; *&#160;</td>
          <td class="paramname"><em>internalNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>firstIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>construct the internal binary tree node with index idx </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codes</td><td>sorted Morton code sequence without duplicates </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nCodes</td><td>number of elements in <code>codes</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">internalNodes</td><td>output internal binary radix tree, size is nCodes - 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstIndex</td><td>element of <code>internalNodes</code> to construct, permissible range is 0 &lt;= firstIndex &lt; nCodes-1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab49458052e6817b7a5e01de1beeca693" name="ab49458052e6817b7a5e01de1beeca693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49458052e6817b7a5e01de1beeca693">&#9670;&#160;</a></span>containedIn() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; std::is_unsigned_v&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;, bool &gt; cstone::containedIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>codeStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>codeEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check whether a coordinate box is fully contained in a Morton code range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codeStart</td><td>Morton code range start </td></tr>
    <tr><td class="paramname">codeEnd</td><td>Morton code range end </td></tr>
    <tr><td class="paramname">box</td><td>3D box with x,y,z integer coordinates in [0,2^maxTreeLevel&lt;KeyType&gt;{}-1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the box is fully contained within the specified Morton code range </dd></dl>

</div>
</div>
<a id="a16383bf043362449171b90353b9d1c3b" name="a16383bf043362449171b90353b9d1c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16383bf043362449171b90353b9d1c3b">&#9670;&#160;</a></span>containedIn() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; std::is_unsigned_v&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;, bool &gt; cstone::containedIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>nodeStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>nodeEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>codeStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>codeEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>determine whether a binary/octree node (prefix, prefixLength) is fully contained in an SFC range </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>lowest SFC code of the tree node </td></tr>
    <tr><td class="paramname">prefixLength</td><td>range of the tree node in bits, corresponding SFC range is 2^(3*maxTreeLevel&lt;KeyType&gt;{} - prefixLength) </td></tr>
    <tr><td class="paramname">codeStart</td><td>start of the SFC range </td></tr>
    <tr><td class="paramname">codeEnd</td><td>end of the SFC range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a4fa7d9370b5c932ca1a89c0b9781594e" name="a4fa7d9370b5c932ca1a89c0b9781594e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa7d9370b5c932ca1a89c0b9781594e">&#9670;&#160;</a></span>containedIn() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; std::is_unsigned_v&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;, bool &gt; cstone::containedIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>prefixBitKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>codeStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>codeEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7db91b41610ef07e5923e0700efec461" name="a7db91b41610ef07e5923e0700efec461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db91b41610ef07e5923e0700efec461">&#9670;&#160;</a></span>containingNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> cstone::containingNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>nodeKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>childOffsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the smallest node that contains <code>nodeKey</code> </p>

</div>
</div>
<a id="ac8e025d9e90b740839839148eda01b39" name="ac8e025d9e90b740839839148eda01b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e025d9e90b740839839148eda01b39">&#9670;&#160;</a></span>continuumCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> unsigned cstone::continuumCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>nodeStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>nodeEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>concentration</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>estimate particle count of the given node based on the concentration continuum and node volume </p>

</div>
</div>
<a id="a2538a5139580d11da28a522a00231453" name="a2538a5139580d11da28a522a00231453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2538a5139580d11da28a522a00231453">&#9670;&#160;</a></span>countGpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t cstone::countGpu </td>
          <td>(</td>
          <td class="paramtype">const ValueType *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f91481f971476236c3b2f21291daf0e" name="a9f91481f971476236c3b2f21291daf0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f91481f971476236c3b2f21291daf0e">&#9670;&#160;</a></span>countRequestParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::countRequestParticles </td>
          <td>(</td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const unsigned &gt;&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>requestLeaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt;&#160;</td>
          <td class="paramname"><em>levelRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>requestCounts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>count particles inside specified ranges of a cornerstone leaf tree </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">leaves</td><td>cornerstone SFC key sequence, </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counts</td><td>particle counts of <code>leaves</code>, length = length(leaves) - 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">requestLeaves</td><td>query cornerstone SFC key sequence </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prefixes</td><td>node keys that matches the layout of <code>request</code> counts </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">levelRange</td><td>octree-level boundary starts, used for efficiently locating nodes <code>prefixes</code> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">requestCounts</td><td>output counts for <code>requestLeaves</code>, length = same as <code>prefixes</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5282c3fcbcc6e1a2f714c5598c5d99a3" name="a5282c3fcbcc6e1a2f714c5598c5d99a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5282c3fcbcc6e1a2f714c5598c5d99a3">&#9670;&#160;</a></span>createBinaryTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::createBinaryTree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>nNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcstone_1_1BinaryNode.html">BinaryNode</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; *&#160;</td>
          <td class="paramname"><em>binaryTree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a binary radix tree from a cornerstone octree </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>Sorted Morton codes representing the leaves of the (global) octree or the locations of objects in 3D. Cornerstone invariants are not a requirement for this function, only that the codes be sorted and not contain any duplicates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nNodes</td><td>nNodes == length(tree) - 1 If <code>tree</code> is in cornerstone format, nNodes is the number of leaf nodes. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">binaryTree</td><td>output binary tree, length == <code>nNodes</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the internal part of the input tree constructed as binary nodes</dd></dl>
<p>Note that if the input <code>tree</code> is a cornerstone octree, the root node with index 0 in the returned binary tree only maps binary nodes 0 &lt;= ... &lt; tree.size() -1. Due to the last element of tree being the maximum Morton code 2^(30 or 61), the last node/element of the returned binary tree will be set up as a useless second root node that is not reachable from the root node with index 0. So if <code>tree</code> is a cornerstone octree with an array size of N, we can say that</p><ul>
<li><code>tree</code> has N-1 octree leaf nodes</li>
<li>the output is a binary tree of array size N-1 with 0...N-2 as usable elements</li>
</ul>
<p>One could of course prevent the generation of the last binary node with index N-1, but that would result in loss of generality for arbitrary sorted Morton code sequences without duplicates. </p>

</div>
</div>
<a id="ad83b1d50b08bf5c589d6bce93b2dabba" name="ad83b1d50b08bf5c589d6bce93b2dabba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83b1d50b08bf5c589d6bce93b2dabba">&#9670;&#160;</a></span>createFpBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a17864a21bbfcf1e20ef7c834edae7cf3">FBox</a>&lt; T &gt; cstone::createFpBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> &amp;&#160;</td>
          <td class="paramname"><em>ibox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create a floating point box from and integer box </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>float or double </td></tr>
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ibox</td><td>integer box </td></tr>
    <tr><td class="paramname">box</td><td>global coordinate bounding box </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the floating point box </dd></dl>

</div>
</div>
<a id="ac3f1e806067f32870433b12cd3339a77" name="ac3f1e806067f32870433b12cd3339a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f1e806067f32870433b12cd3339a77">&#9670;&#160;</a></span>createIBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> cstone::createIBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert a floating point box to an IBox with a volume not smaller than the input box </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>floating point box center </td></tr>
    <tr><td class="paramname">size</td><td>floating point box size </td></tr>
    <tr><td class="paramname">box</td><td>global coordinate bounding box </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted IBox</dd></dl>
<p>Inverts createFpBox </p>

</div>
</div>
<a id="a9e1d20c97356ea707766c593d4556bf5" name="a9e1d20c97356ea707766c593d4556bf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1d20c97356ea707766c593d4556bf5">&#9670;&#160;</a></span>createSendRanges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcstone_1_1SendRanges.html">SendRanges</a> cstone::createSendRanges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1SpaceCurveAssignment.html">SpaceCurveAssignment</a> &amp;&#160;</td>
          <td class="paramname"><em>assignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>treeLeaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>particleKeys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Based on global assignment, create the list of local particle index ranges to send to each rank. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">assignment</td><td>global space curve assignment to ranks </td></tr>
    <tr><td class="paramname">tree</td><td>global cornerstone octree that matches the node counts used to create <code>assignment</code> </td></tr>
    <tr><td class="paramname">particleKeys</td><td>sorted list of SFC keys of local particles present on this rank </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>for each rank, a list of index ranges into <code>particleKeys</code> to send</dd></dl>
<p>Converts the global assignment particle keys ranges into particle indices with binary search </p>

</div>
</div>
<a id="a058a1896a0a9b902a06b45ef9c3988ba" name="a058a1896a0a9b902a06b45ef9c3988ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058a1896a0a9b902a06b45ef9c3988ba">&#9670;&#160;</a></span>createUnsortedLayoutCpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::createUnsortedLayoutCpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>numInternalNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>numLeafNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>internalToLeaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>combine internal and leaf tree parts into a single array with the nodeKey prefixes </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>unsigned 32- or 64-bit integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">leaves</td><td>cornerstone SFC keys, length numLeafNodes + 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numInternalNodes</td><td>number of internal octree nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numLeafNodes</td><td>total number of nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">binaryToOct</td><td>translation map from binary to octree nodes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">prefixes</td><td>output octree SFC keys, length <code>numInternalNodes</code> + numLeafNodes NOTE: keys are prefixed with Warren-Salmon placeholder bits! </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">internalToLeaf</td><td>iota 0,1,2,3,... sequence for later use, length same as <code>prefixes</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7a0069a226f71950884bdbce365aef3" name="af7a0069a226f71950884bdbce365aef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a0069a226f71950884bdbce365aef3">&#9670;&#160;</a></span>decodeHilbert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">util::tuple</a>&lt; unsigned, unsigned, unsigned &gt; cstone::decodeHilbert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inverse function of iHilbert </p>

</div>
</div>
<a id="a862268d9c2f782effdd90cc578e2274b" name="a862268d9c2f782effdd90cc578e2274b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862268d9c2f782effdd90cc578e2274b">&#9670;&#160;</a></span>decodeHilbert2D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">util::tuple</a>&lt; unsigned, unsigned &gt; cstone::decodeHilbert2D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0fc40b5985e5508fd1d9a4e013a0ddb" name="ae0fc40b5985e5508fd1d9a4e013a0ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0fc40b5985e5508fd1d9a4e013a0ddb">&#9670;&#160;</a></span>decodeHilbert2DConstant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">util::tuple</a>&lt; unsigned, unsigned &gt; cstone::decodeHilbert2DConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inverse function of iHilbert 32 bit only up to oder 16 but works at constant time. </p>

</div>
</div>
<a id="a9b208333a41d773b6ac6106aaf625d64" name="a9b208333a41d773b6ac6106aaf625d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b208333a41d773b6ac6106aaf625d64">&#9670;&#160;</a></span>decodeMorton()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">util::tuple</a>&lt; unsigned, unsigned, unsigned &gt; cstone::decodeMorton </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>decode X,Y,Z components of a Morton key into a tuple </p>

</div>
</div>
<a id="aa03c2fc3addf2158300b5e1c17df3684" name="aa03c2fc3addf2158300b5e1c17df3684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03c2fc3addf2158300b5e1c17df3684">&#9670;&#160;</a></span>decodePlaceholderBit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> cstone::decodePlaceholderBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>decode an SFC key in Warren-Salmon placeholder bit format </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>input SFC key with 1-bit prepended </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>SFC-key without 1-bit and shifted to most significant bit</dd></dl>
<p>Inverts encodePlaceholderBit. </p>

</div>
</div>
<a id="a4bb049aaa3103bdd79f42fb329a88639" name="a4bb049aaa3103bdd79f42fb329a88639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb049aaa3103bdd79f42fb329a88639">&#9670;&#160;</a></span>decodePrefixLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr unsigned cstone::decodePrefixLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the number of key-bits in the input <code>code</code> </p>

</div>
</div>
<a id="a09be5264e068c0b1d4056c4ebacdad55" name="a09be5264e068c0b1d4056c4ebacdad55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09be5264e068c0b1d4056c4ebacdad55">&#9670;&#160;</a></span>decodeSendCountCpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint64_t cstone::decodeSendCountCpu </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>recvPtr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a55ba890fd3fc397dfd56619fbfee6e3a" name="a55ba890fd3fc397dfd56619fbfee6e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ba890fd3fc397dfd56619fbfee6e3a">&#9670;&#160;</a></span>decodeSfc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; <a class="el" href="structcstone_1_1IsMorton.html">IsMorton</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;{}, <a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">util::tuple</a>&lt; unsigned, unsigned, unsigned &gt; &gt; cstone::decodeSfc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>decode a Morton key </p>

</div>
</div>
<a id="a595434f3bdf01b9ccdb62921e1ccdbbb" name="a595434f3bdf01b9ccdb62921e1ccdbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595434f3bdf01b9ccdb62921e1ccdbbb">&#9670;&#160;</a></span>decodeSfc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; <a class="el" href="structcstone_1_1IsHilbert.html">IsHilbert</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;{}, <a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">util::tuple</a>&lt; unsigned, unsigned, unsigned &gt; &gt; cstone::decodeSfc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>decode a Hilbert key </p>

</div>
</div>
<a id="acb36224fc3057d03fb74b4c88739b632" name="acb36224fc3057d03fb74b4c88739b632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb36224fc3057d03fb74b4c88739b632">&#9670;&#160;</a></span>digitWeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr int cstone::digitWeight </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>digit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the offset octal digit weight for binary tree &lt;-&gt; octree index correspondence </p>

</div>
</div>
<a id="a47f584269a1300d63b860188b4e08d20" name="a47f584269a1300d63b860188b4e08d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f584269a1300d63b860188b4e08d20">&#9670;&#160;</a></span>distancePBC()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tc , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> T cstone::distancePBC </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">cstone::Box</a>&lt; Tc &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>hi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tc&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tc&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tc&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tc&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tc&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tc&#160;</td>
          <td class="paramname"><em>z2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a40382c3f221c9b3c95c2604104530260" name="a40382c3f221c9b3c95c2604104530260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40382c3f221c9b3c95c2604104530260">&#9670;&#160;</a></span>distanceSq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Pbc, class T , std::enable_if_t&lt; Pbc, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr T cstone::distanceSq </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute squared distance, taking PBC into account </p>
<p>compute squared distance between to points in 3D</p>
<p>Note that if pbc{X,Y,Z} is false, the result is identical to distancesq below. </p>

</div>
</div>
<a id="ad407c13173a72b989bb057a20c57c2d2" name="ad407c13173a72b989bb057a20c57c2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad407c13173a72b989bb057a20c57c2d2">&#9670;&#160;</a></span>dualTraversal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TreeType , class MAC , class M2L , class P2P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::dualTraversal </td>
          <td>(</td>
          <td class="paramtype">const TreeType &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MAC &amp;&amp;&#160;</td>
          <td class="paramname"><em>continuation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">M2L &amp;&amp;&#160;</td>
          <td class="paramname"><em>m2l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P2P &amp;&amp;&#160;</td>
          <td class="paramname"><em>p2p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic dual-traversal of a tree with pairs of indices. Also called simultaneous traversal. </p>
<p>Since the continuation criterion and the two endpoint actions for failed/passed criteria are provided as arguments, this function is completely generic and can be used to evaluate MACs for FMM, general collision detection for halo discovery and surface detection.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
    <tr><td class="paramname">MAC</td><td>traversal continuation criterion </td></tr>
    <tr><td class="paramname">M2L</td><td>endpoint action for nodes that passed <code>MAC</code> </td></tr>
    <tr><td class="paramname">P2P</td><td>endpoint action for leaf nodes that did not pass <code>MAC</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">octree</td><td>traversable octree </td></tr>
    <tr><td class="paramname">a</td><td>first octree node index for starting the traversal </td></tr>
    <tr><td class="paramname">b</td><td>second start octree node index for starting the traversal </td></tr>
    <tr><td class="paramname">continuation</td><td>Criterion whether or not to continue traversing two nodes callable with signature bool(TreeNodeIndex, TreeNodeIndex) often, the criterion is some sort of multipole acceptance criterion </td></tr>
    <tr><td class="paramname">m2l</td><td>Multipole-2-local, called each for each node pair during traversal that passed <code>criterion</code>. Callable with signature void(TreeNodeIndex, TreeNodeIndex) </td></tr>
    <tr><td class="paramname">p2p</td><td>Particle-2-particle, called for each pair of leaf nodes during traversal that did not pass <code>continuation</code> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af86e6fc94838cadc77f9c359cafbf3ec" name="af86e6fc94838cadc77f9c359cafbf3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af86e6fc94838cadc77f9c359cafbf3ec">&#9670;&#160;</a></span>enclosingBoxCode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> cstone::enclosingBoxCode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>treeLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>cut down the input SFC code to the start code of the enclosing box at &lt;treeLevel&gt; </p>

</div>
</div>
<a id="abe358bb531bd012cf6bd426cc6f236a4" name="abe358bb531bd012cf6bd426cc6f236a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe358bb531bd012cf6bd426cc6f236a4">&#9670;&#160;</a></span>encodePlaceholderBit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> cstone::encodePlaceholderBit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>prefixLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert a plain SFC key into the placeholder bit format (Warren-Salmon 1993) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>input SFC key </td></tr>
    <tr><td class="paramname">prefixLength</td><td>number of leading bits which are part of the code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>code shifted by trailing zeros and prepended with 1-bit</dd></dl>
<p>Example: encodePlaceholderBit(06350000000, 9) -&gt; 01635 (in octal) </p>

</div>
</div>
<a id="af6aaf222db0e48d8c2a6160e2cc434f7" name="af6aaf222db0e48d8c2a6160e2cc434f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6aaf222db0e48d8c2a6160e2cc434f7">&#9670;&#160;</a></span>encodeSendCountCpu()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cstone::encodeSendCountCpu </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>sendPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3cdd497661db752b18566752aeaf781" name="ab3cdd497661db752b18566752aeaf781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3cdd497661db752b18566752aeaf781">&#9670;&#160;</a></span>enforceKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecstone.html#a388434742a2abebe943b6f5445e6732b">ResolutionStatus</a> cstone::enforceKeys </td>
          <td>(</td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>mandatoryKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>nodeKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>childOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>parents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>nodeOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa93a49739c3550acda549f8711319add" name="aa93a49739c3550acda549f8711319add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93a49739c3550acda549f8711319add">&#9670;&#160;</a></span>enforceKeysGpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecstone.html#a388434742a2abebe943b6f5445e6732b">ResolutionStatus</a> cstone::enforceKeysGpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>forcedKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>numForcedKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>nodeKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>childOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>parents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>nodeOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af89f00e258c0348bcc7df1ad1c664d17" name="af89f00e258c0348bcc7df1ad1c664d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af89f00e258c0348bcc7df1ad1c664d17">&#9670;&#160;</a></span>enforceKeySingle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a388434742a2abebe943b6f5445e6732b">ResolutionStatus</a> cstone::enforceKeySingle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>nodeKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>childOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>parents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>nodeOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a34ab7a976a76180ebc58c4439f202c" name="a5a34ab7a976a76180ebc58c4439f202c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a34ab7a976a76180ebc58c4439f202c">&#9670;&#160;</a></span>evaluateMac()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> bool cstone::evaluateMac </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>sourceCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>macSq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>targetCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>targetSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate an arbitrary MAC with respect to a given target </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>float or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceCenter</td><td>expansion center of the MAC </td></tr>
    <tr><td class="paramname">macSq</td><td>squared acceptance radius around <code>sourceCenter</code> </td></tr>
    <tr><td class="paramname">targetCenter</td><td>target coordinate </td></tr>
    <tr><td class="paramname">targetSize</td><td>target half box length (&gt;0) in all dimensions </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the target is closer to <code>sourceCenter</code> than the acceptance radius </dd></dl>

</div>
</div>
<a id="ac94aa283bf74d93496621d4995309e8b" name="ac94aa283bf74d93496621d4995309e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94aa283bf74d93496621d4995309e8b">&#9670;&#160;</a></span>evaluateMacPbc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> bool cstone::evaluateMacPbc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>sourceCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>macSq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>targetCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>targetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>evaluate an arbitrary MAC with respect to a given target </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>float or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceCenter</td><td>source cell expansion center, can be geometric or center-mass, depending on choice of MAC used to compute <code>macSq</code> </td></tr>
    <tr><td class="paramname">macSq</td><td>squared multipole acceptance radius of the source cell </td></tr>
    <tr><td class="paramname">targetCenter</td><td>geometric target cell center coordinates </td></tr>
    <tr><td class="paramname">targetSize</td><td>geometric size of the target cell </td></tr>
    <tr><td class="paramname">box</td><td>global coordinate bounding box </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the target is closer to <code>sourceCenter</code> than the acceptance radius </dd></dl>

</div>
</div>
<a id="a178146e60b42107a4114bf81a9f3b126" name="a178146e60b42107a4114bf81a9f3b126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178146e60b42107a4114bf81a9f3b126">&#9670;&#160;</a></span>exchangeParticles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Arrays&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::exchangeParticles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1SendRanges.html">SendRanges</a> &amp;&#160;</td>
          <td class="paramname"><em>sends</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>thisRank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcstone_1_1BufferDescription.html">BufferDescription</a>&#160;</td>
          <td class="paramname"><em>bufDesc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a>&#160;</td>
          <td class="paramname"><em>numParticlesAssigned</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> *&#160;</td>
          <td class="paramname"><em>ordering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::tuple&lt; int, <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>receiveLog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arrays...&#160;</td>
          <td class="paramname"><em>arrays</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>exchange array elements with other ranks according to the specified ranges </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Arrays</td><td>pointers to particles buffers </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sendList</td><td>List of index ranges to be sent to each rank, indices are valid w.r.t to arrays present on <code>thisRank</code> relative to <code>particleStart</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thisRank</td><td>Rank of the executing process </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bufDesc</td><td>data layout of local <code>arrays</code> with start, end of assigned particles and total size </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nParticlesAssigned</td><td>New number of assigned particles for each array on <code>thisRank</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ordering</td><td>Ordering through which to access arrays, valid w.r.t to [particleStart:particleEnd] </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">arrays</td><td>Pointers of different types but identical sizes. The index range based exchange operations performed are identical for each input array. Upon completion, arrays will contain elements from the specified ranges and ranks. The order in which the incoming ranges are grouped is random.</td></tr>
  </table>
  </dd>
</dl>
<p>Example: If sendList[ri] contains the range [upper, lower), all elements (arrays+inputOffset)[ordering[upper:lower]] will be sent to rank ri. At the destination ri, the incoming elements will be either prepended or appended to elements already present on ri. No information about incoming particles to <code>thisRank</code> is contained in the function arguments, only their total number <code>nParticlesAssigned</code>, which also includes any assigned particles already present on <code>thisRank</code>. </p>

</div>
</div>
<a id="a00a968270cec25b6a39e8c67b262e9e0" name="a00a968270cec25b6a39e8c67b262e9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a968270cec25b6a39e8c67b262e9e0">&#9670;&#160;</a></span>exchangeRequestKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcstone_1_1SendList.html">SendList</a> cstone::exchangeRequestKeys </td>
          <td>(</td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>treeLeaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const int &gt;&#160;</td>
          <td class="paramname"><em>haloFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="namespacecstone.html#ab92e8dfcff11066ac75330812a896de9">TreeIndexPair</a> &gt;&#160;</td>
          <td class="paramname"><em>assignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const int &gt;&#160;</td>
          <td class="paramname"><em>peerRanks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> &gt;&#160;</td>
          <td class="paramname"><em>layout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>exchange halo request keys, establish particle indices to send </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">treeLeaves</td><td>cornerstone octree leaves, length N+1 </td></tr>
    <tr><td class="paramname">haloFlags</td><td>0 or 1 for each node in <code>leaves</code>, length N nodes marked with 1 are halos of the executing rank </td></tr>
    <tr><td class="paramname">assignment</td><td>assignment of <code>treeLeaves</code> to ranks, only ranks listed in <code>peerRanks</code> are accessed </td></tr>
    <tr><td class="paramname">peerRanks</td><td>list of peer rank IDs </td></tr>
    <tr><td class="paramname">layout</td><td>particle location (index in buffers) of each node in <em>treeLeaves</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classcstone_1_1SendList.html" title="SendList contains one manifest per rank.">SendList</a>, containing ranges of local particle indices to send out to each peer rank in subsequent halo particle exchanges.</dd></dl>
<p>Preconditions:</p>
<p>Let node index i on rank r1 be marked as a halo, i.e. haloFlags[i] == 1.</p><ul>
<li>Then the assigned rank of i, r2 = assignment.findRank(i) has to be listed in <code>peerRanks</code>, otherwise the request is not sent and r1 will not receive those halos in the subsequent halo particle exchange, which will cause it to fail.</li>
<li>r1 sends the range [treeLeaves[i]:treeLeaves[i+1]] to r2, so that range has to be part of the assignment of r2. </li>
</ul>

</div>
</div>
<a id="a5f767b85fd6efedc6e75ba442a22eb3a" name="a5f767b85fd6efedc6e75ba442a22eb3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f767b85fd6efedc6e75ba442a22eb3a">&#9670;&#160;</a></span>exchangeTreeletGeneral()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::exchangeTreeletGeneral </td>
          <td>(</td>
          <td class="paramtype">gsl::span&lt; const int &gt;&#160;</td>
          <td class="paramname"><em>peerRanks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>peerTrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="structcstone_1_1IndexPair.html">IndexPair</a>&lt; <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>focusAssignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt;&#160;</td>
          <td class="paramname"><em>levelRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt;&#160;</td>
          <td class="paramname"><em>csToInternalMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; T &gt;&#160;</td>
          <td class="paramname"><em>quantities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>commTag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa30449c51e61189b86fb0d2b5ee578c0" name="aa30449c51e61189b86fb0d2b5ee578c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30449c51e61189b86fb0d2b5ee578c0">&#9670;&#160;</a></span>exchangeTreelets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::exchangeTreelets </td>
          <td>(</td>
          <td class="paramtype">gsl::span&lt; const int &gt;&#160;</td>
          <td class="paramname"><em>peerRanks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="structcstone_1_1IndexPair.html">IndexPair</a>&lt; <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>focusAssignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>localLeaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>peerTrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; MPI_Request &gt; &amp;&#160;</td>
          <td class="paramname"><em>receiveRequests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>exchange subtree structures with peers </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">peerRanks</td><td>List of peer rank IDs </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">focusAssignment</td><td>The assignment of <code>localLeaves</code> to peer ranks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">localLeaves</td><td>The tree of the executing rank. Covers the global domain, but is locally focused. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">peerTrees</td><td>The tree structures of REMOTE peer ranks covering the LOCALLY assigned part of the tree. Each treelet covers the same SFC key range (the assigned range of the executing rank) but is adaptively (MAC) resolved from the perspective of the peer rank.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: peerTrees stores the view of REMOTE ranks for the LOCAL domain. While focusAssignment and localLeaves contain the LOCAL view of REMOTE peer domains. </p>

</div>
</div>
<a id="acdb4e95e663e6c702975822c043c8bd0" name="acdb4e95e663e6c702975822c043c8bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb4e95e663e6c702975822c043c8bd0">&#9670;&#160;</a></span>exclusiveScan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::exclusiveScan </td>
          <td>(</td>
          <td class="paramtype">const T1 *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>multi-threaded exclusive scan (prefix sum) implementation </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T1,T2</td><td>integer types </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>input values, length = <code>numElements</code> </td></tr>
    <tr><td class="paramname">out</td><td>output values, length = <code>numElements</code> </td></tr>
    <tr><td class="paramname">numElements</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa30135a440b8f0b44257a76002137041" name="aa30135a440b8f0b44257a76002137041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30135a440b8f0b44257a76002137041">&#9670;&#160;</a></span>exclusiveScan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::exclusiveScan </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a121ee051352297c57210243f4a9cc68f" name="a121ee051352297c57210243f4a9cc68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a121ee051352297c57210243f4a9cc68f">&#9670;&#160;</a></span>exclusiveScanGpu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IndexType , class SumType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::exclusiveScanGpu </td>
          <td>(</td>
          <td class="paramtype">const IndexType *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexType *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SumType *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63ca39fb979e388c402811cde2907386" name="a63ca39fb979e388c402811cde2907386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ca39fb979e388c402811cde2907386">&#9670;&#160;</a></span>exclusiveScanGpu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IndexType , class SumType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cstone::exclusiveScanGpu </td>
          <td>(</td>
          <td class="paramtype">const IndexType *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexType *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SumType *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SumType&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b09b85b484553f55da84e024e413389" name="a7b09b85b484553f55da84e024e413389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b09b85b484553f55da84e024e413389">&#9670;&#160;</a></span>exclusiveScanSerialInplace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cstone::exclusiveScanSerialInplace </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b792ce0fb408c428d0a85ff18450faa" name="a9b792ce0fb408c428d0a85ff18450faa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b792ce0fb408c428d0a85ff18450faa">&#9670;&#160;</a></span>extractMarkedElements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IntegralType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; IntegralType &gt; cstone::extractMarkedElements </td>
          <td>(</td>
          <td class="paramtype">gsl::span&lt; const IntegralType &gt;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const int &gt;&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>firstReqIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>secondReqIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extract ranges of marked indices from a source array </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IntegralType</td><td>an integer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>array with quantities to extract, length N+1 </td></tr>
    <tr><td class="paramname">flags</td><td>0 or 1 flags for index, length N </td></tr>
    <tr><td class="paramname">firstReqIdx</td><td>first index, permissible range: [0:N] </td></tr>
    <tr><td class="paramname">secondReqIdx</td><td>second index, permissible range: [0:N+1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector (of pairs) of elements of <code>source</code> that span all elements [firstReqIdx:secondReqIdx] of <code>source</code> that are marked by <code>flags</code> </dd></dl>
<p>Even indices mark the start of a range, uneven indices mark the end of the previous range start. If two ranges are consecutive, they are fused into a single range.</p>
<p>This is used to extract</p><ul>
<li>SFC keys of cornerstone octree leaf nodes flagged as halos</li>
<li>Particle offsets from buffer layouts </li>
</ul>

</div>
</div>
<a id="a227df32554320b609359fbbc4929461d" name="a227df32554320b609359fbbc4929461d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227df32554320b609359fbbc4929461d">&#9670;&#160;</a></span>fieldStringsToInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Array &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; cstone::fieldStringsToInt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>subsetNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>allNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up indices of a (runtime-variable) number of field names. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Array</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">subsetNames</td><td>array of strings of field names to look up in <code>allNames</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">allNames</td><td>array of strings with names of all fields </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the indices of <code>subsetNames</code> in <code>allNames</code> </dd></dl>

</div>
</div>
<a id="a698640650664806a4e1cb8c953715fc2" name="a698640650664806a4e1cb8c953715fc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698640650664806a4e1cb8c953715fc2">&#9670;&#160;</a></span>fillGpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cstone::fillGpu </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acac48b2aa8c60c863f1dfa5fcce50a4c" name="acac48b2aa8c60c863f1dfa5fcce50a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac48b2aa8c60c863f1dfa5fcce50a4c">&#9670;&#160;</a></span>findCollisions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> void cstone::findCollisions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>nodePrefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>childOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>endpointAction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>excludeStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>excludeEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afda4494b138e3604cec6ac2152122ee2" name="afda4494b138e3604cec6ac2152122ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda4494b138e3604cec6ac2152122ee2">&#9670;&#160;</a></span>findHalos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class RadiusType , class CoordinateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::findHalos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>childOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>internalToLeaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RadiusType *&#160;</td>
          <td class="paramname"><em>interactionRadii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; CoordinateType &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>firstNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>lastNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>collisionFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mark halo nodes with flags </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
    <tr><td class="paramname">RadiusType</td><td>float or double, float is sufficient for 64-bit codes or less </td></tr>
    <tr><td class="paramname">CoordinateType</td><td>float or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefixes</td><td>node keys in placeholder-bit format of fully linked octree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">childOffsets</td><td>first child node index of each node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internalToLeaf</td><td>conversion of fully linked indices to cstone indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">leaves</td><td>cornerstone array of tree leaves </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interactionRadii</td><td>effective halo search radii per octree (leaf) node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>coordinate bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstNode</td><td>first leaf node index to consider as local </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lastNode</td><td>last leaf node index to consider as local </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">collisionFlags</td><td>array of length octree.numLeafNodes, each node that is a halo from the perspective of [firstNode:lastNode] will be marked with a non-zero value. Note: does NOT reset non-colliding indices to 0, so <code>collisionFlags</code> should be zero-initialized prior to calling this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad9448f6719204b82ae70bacfbadcea84" name="ad9448f6719204b82ae70bacfbadcea84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9448f6719204b82ae70bacfbadcea84">&#9670;&#160;</a></span>findHalosGpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class RadiusType , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cstone::findHalosGpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>childOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>internalToLeaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RadiusType *&#160;</td>
          <td class="paramname"><em>interactionRadii</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>firstNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>lastNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>collisionFlags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>mark halo nodes with flags </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
    <tr><td class="paramname">RadiusType</td><td>float or double, float is sufficient for 64-bit codes or less </td></tr>
    <tr><td class="paramname">T</td><td>float or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefixes</td><td>Warren-Salmon node keys of the octree, length = numTreeNodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">childOffsets</td><td>child offsets array, length = numTreeNodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internalToLeaf</td><td>map leaf node indices of fully linked format to cornerstone order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">leaves</td><td>cstone array of leaf node keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interactionRadii</td><td>effective halo search radii per octree (leaf) node </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>coordinate bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">firstNode</td><td>first cstone leaf node index to consider as local </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">lastNode</td><td>last cstone leaf node index to consider as local </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">collisionFlags</td><td>array of length numLeafNodes, each node that is a halo from the perspective of [firstNode:lastNode] will be marked with a non-zero value. Note: does NOT reset non-colliding indices to 0, so <code>collisionFlags</code> should be zero-initialized prior to calling this function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a70d2575b3198947f078dd92be37c20" name="a3a70d2575b3198947f078dd92be37c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a70d2575b3198947f078dd92be37c20">&#9670;&#160;</a></span>findNeighbors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::findNeighbors </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a>&#160;</td>
          <td class="paramname"><em>firstId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a>&#160;</td>
          <td class="paramname"><em>lastId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcstone_1_1OctreeNsView.html">OctreeNsView</a>&lt; T, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>treeView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ngmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> *&#160;</td>
          <td class="paramname"><em>neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>neighborsCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a188c5f6ee7d9d5fb7a3ad4e7e77b05a7" name="a188c5f6ee7d9d5fb7a3ad4e7e77b05a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188c5f6ee7d9d5fb7a3ad4e7e77b05a7">&#9670;&#160;</a></span>findNeighbors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tc , class Th , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> unsigned cstone::findNeighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tc *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tc *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tc *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Th *&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcstone_1_1OctreeNsView.html">OctreeNsView</a>&lt; Tc, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; Tc &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ngmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> *&#160;</td>
          <td class="paramname"><em>neighbors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>findNeighbors of particle number <code>id</code> within radius </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>coordinate type, float or double </td></tr>
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit Morton or Hilbert key type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">i</td><td>the index of the particle for which to look for neighbors </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>particle x-coordinates in SFC order (as indexed by <code>tree.layout</code>) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>particle y-coordinates in SFC order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>particle z-coordinates in SFC order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>smoothing lengths (1/2 the search radius) in SFC order </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>octree connectivity and particle indexing </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>coordinate bounding box that was used to calculate the Morton codes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ngmax</td><td>maximum number of neighbors per particle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">neighbors</td><td>output to store the neighbors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>neighbor count of particle <code>i</code>, does not include self-reference; min return val is 0. </dd></dl>

</div>
</div>
<a id="a5dc0da6b08a06a674ba578a500b9951b" name="a5dc0da6b08a06a674ba578a500b9951b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dc0da6b08a06a674ba578a500b9951b">&#9670;&#160;</a></span>findNodeAbove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> cstone::findNodeAbove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return first node that starts at or above key </p>

</div>
</div>
<a id="a7352f342f22c452ac104f0dc3c49dcfa" name="a7352f342f22c452ac104f0dc3c49dcfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7352f342f22c452ac104f0dc3c49dcfa">&#9670;&#160;</a></span>findNodeBelow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> cstone::findNodeBelow </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return first node that starts at or below (contains) key </p>

</div>
</div>
<a id="ab2d4e6d74e234a922ea605def1c0068a" name="ab2d4e6d74e234a922ea605def1c0068a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d4e6d74e234a922ea605def1c0068a">&#9670;&#160;</a></span>findPeersMac()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , template&lt; class &gt; class TreeType, class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; cstone::findPeersMac </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myRank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1SpaceCurveAssignment.html">SpaceCurveAssignment</a> &amp;&#160;</td>
          <td class="paramname"><em>assignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TreeType&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>domainTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>invThetaEff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find peer ranks based on a multipole acceptance criterion and dual tree traversal </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>float or double </td></tr>
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">myRank</td><td>find peers for the globally assigned SFC segment with index myRank </td></tr>
    <tr><td class="paramname">assignment</td><td>Decomposition of the global SFC into segments </td></tr>
    <tr><td class="paramname">domainTree</td><td>octree built on top of the global cornerstone leaves </td></tr>
    <tr><td class="paramname">box</td><td>global coordinate bounding box </td></tr>
    <tr><td class="paramname">invThetaEff</td><td>1/theta + s, effective inverse opening parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list of segment indices (i.e. "ranks") that contain tree leaf nodes that fail the MAC paired with at least one tree leaf node inside the <code>myRank</code> segment. This list contains at least the segments at the surface of the <code>myRank</code> segment and possibly additional segments for low opening angles and/or low global resolution in <code>domainTree</code>.</dd></dl>
<p>Note: This function guarantees mutuality, if rank A identifies B as peer, then also rank B will have A as peer</p>
<p>Except for <code>myRank</code>, this function acts on data that is identical on all MPI ranks and doesn't need to do any communication. </p>

</div>
</div>
<a id="a6b747b0fc3e494cad494566e8bdfb1b4" name="a6b747b0fc3e494cad494566e8bdfb1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b747b0fc3e494cad494566e8bdfb1b4">&#9670;&#160;</a></span>findPeersMacStt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class &gt; class TreeType, class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; cstone::findPeersMacStt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myRank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1SpaceCurveAssignment.html">SpaceCurveAssignment</a> &amp;&#160;</td>
          <td class="paramname"><em>assignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TreeType&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>invThetaEff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Args identical to findPeersMac, but implemented with single tree traversal for comparison. </p>

</div>
</div>
<a id="adc5d8ce1e40c6bb6c827b6172b3dc89f" name="adc5d8ce1e40c6bb6c827b6172b3dc89f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5d8ce1e40c6bb6c827b6172b3dc89f">&#9670;&#160;</a></span>findSearchBounds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="structutil_1_1array.html">util::array</a>&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *, 2 &gt; cstone::findSearchBounds </td>
          <td>(</td>
          <td class="paramtype">std::make_signed_t&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>firstIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>targetCode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>codesStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>codesEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determine search bound for <code>targetCode</code> in an array of sorted particle SFC codes </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">firstIdx</td><td>first (of two) search boundary, must be non-negative, but can exceed the codes range (the guess for the location of <code>targetCode</code> in [codesStart:codesEnd] </td></tr>
    <tr><td class="paramname">targetCode</td><td>code to look for in [codesStart:codesEnd] </td></tr>
    <tr><td class="paramname">codesStart</td><td>particle SFC code array start </td></tr>
    <tr><td class="paramname">codesEnd</td><td>particle SFC code array end </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sub-range in [codesStart:codesEnd] containing <code>targetCode</code> </dd></dl>

</div>
</div>
<a id="a211fab363a1ee0bf71c0729c23975e7c" name="a211fab363a1ee0bf71c0729c23975e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211fab363a1ee0bf71c0729c23975e7c">&#9670;&#160;</a></span>findSplit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> cstone::findSplit </td>
          <td>(</td>
          <td class="paramtype">const I *&#160;</td>
          <td class="paramname"><em>sortedSfcCodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find position of first differing bit </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">I</td><td>32 or 64 bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sortedSfcCodes</td><td>sorted SFC codes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">first</td><td>first range index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">last</td><td>last rang index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of morton </dd></dl>

</div>
</div>
<a id="ae8a612f0b7ed2351d01753c64255f5bc" name="ae8a612f0b7ed2351d01753c64255f5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a612f0b7ed2351d01753c64255f5bc">&#9670;&#160;</a></span>focusTransfer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::focusTransfer </td>
          <td>(</td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>cstree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const unsigned &gt;&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bucketSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myRank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>oldFocusStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>oldFocusEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>newFocusStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>newFocusEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass on focus tree parts from old owners to new owners. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cstree</td><td>cornerstone leaf cell array (of the locally focused tree) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counts</td><td>particle counts per cell in <code>cstree</code>, length cstree.size() - 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">myRank</td><td>the executing rank </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oldFocusStart</td><td>SFC assignment boundaries from previous iteration </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">oldFocusEnd</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newFocusStart</td><td>new SFC assignment boundaries </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newFocusEnd</td><td></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">buffer</td><td>cell keys of parts of a remote rank's <code>cstree</code> for the newly assigned area of <code>myRank</code> will be appended to this</td></tr>
  </table>
  </dd>
</dl>
<p>When the assignment boundaries change, we let the previous owning rank pass on its focus tree of the part that it lost to the new owning rank. Thanks to doing so we can guarantee that each rank always has the highest focus tree resolution inside its focus of any rank: if rank a has focus SFC range F, then no other rank can have tree cells in F that don't exist in rank a's focus tree. </p>

</div>
</div>
<a id="a6fc44a01e05969aefa3493a1cc38755f" name="a6fc44a01e05969aefa3493a1cc38755f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fc44a01e05969aefa3493a1cc38755f">&#9670;&#160;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IndexType , class ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::gather </td>
          <td>(</td>
          <td class="paramtype">gsl::span&lt; const IndexType &gt;&#160;</td>
          <td class="paramname"><em>ordering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>gather reorder </p>

</div>
</div>
<a id="afce198b4b6ced8fd1a9f4344cc1a4bd5" name="afce198b4b6ced8fd1a9f4344cc1a4bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce198b4b6ced8fd1a9f4344cc1a4bd5">&#9670;&#160;</a></span>gatherArrays()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Gather , class... Arrays1, class... Arrays2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::gatherArrays </td>
          <td>(</td>
          <td class="paramtype">Gather &amp;&amp;&#160;</td>
          <td class="paramname"><em>gatherFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> *&#160;</td>
          <td class="paramname"><em>ordering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a>&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a>&#160;</td>
          <td class="paramname"><em>inputOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a>&#160;</td>
          <td class="paramname"><em>outputOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Arrays1 &amp;... &gt;&#160;</td>
          <td class="paramname"><em>arrays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Arrays2 &amp;... &gt;&#160;</td>
          <td class="paramname"><em>scratchBuffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reorder with state-less function object </p>

</div>
</div>
<a id="a297a9d4fedfb90e8f3e614a666fb2fb0" name="a297a9d4fedfb90e8f3e614a666fb2fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297a9d4fedfb90e8f3e614a666fb2fb0">&#9670;&#160;</a></span>gatherGpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class IndexType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cstone::gatherGpu </td>
          <td>(</td>
          <td class="paramtype">const IndexType *&#160;</td>
          <td class="paramname"><em>ordering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab864d92d59ef7c63c43621a4817fa427" name="ab864d92d59ef7c63c43621a4817fa427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab864d92d59ef7c63c43621a4817fa427">&#9670;&#160;</a></span>gatherRanges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class IndexType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cstone::gatherRanges </td>
          <td>(</td>
          <td class="paramtype">const IndexType *&#160;</td>
          <td class="paramname"><em>rangeScan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexType *&#160;</td>
          <td class="paramname"><em>rangeOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93b0f927e7ec08b1d4df35c12a3c5c37" name="a93b0f927e7ec08b1d4df35c12a3c5c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93b0f927e7ec08b1d4df35c12a3c5c37">&#9670;&#160;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FL , class Dataset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) cstone::get </td>
          <td>(</td>
          <td class="paramtype">Dataset &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a tuple of references to the specified particle field indices, to GPU fields if GPU is enabled. </p>

</div>
</div>
<a id="ad8b29471446ed343fcb2545e6aa4f1d3" name="ad8b29471446ed343fcb2545e6aa4f1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b29471446ed343fcb2545e6aa4f1d3">&#9670;&#160;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structutil_1_1StructuralString.html">util::StructuralString</a> F, class Dataset , class Tuple , std::enable_if_t&lt; std::is_same_v&lt; void, <a class="el" href="namespaceutil.html#a3673b879f42d462272525a91b4eec1e2">util::void_value_t</a>&lt; Dataset::fieldNames.size()&gt; &gt;, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) cstone::get </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a reference to the named field F from a tuple </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">F</td><td></td></tr>
    <tr><td class="paramname">Dataset</td><td>a type with a fieldNames member with the same number of fields as <code>tup</code> </td></tr>
    <tr><td class="paramname">Tuple</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tup</td><td>a tuple, for example the fields for a single particle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the field F from <code>tup</code> </dd></dl>

</div>
</div>
<a id="ab1770c737077f5f1c3d66ed6e4e62a63" name="ab1770c737077f5f1c3d66ed6e4e62a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1770c737077f5f1c3d66ed6e4e62a63">&#9670;&#160;</a></span>getDevice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;util::StructuralString... Fields, class Dataset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) cstone::getDevice </td>
          <td>(</td>
          <td class="paramtype">Dataset &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e6a279c9f3ff35f7e544e43df2fbecc" name="a5e6a279c9f3ff35f7e544e43df2fbecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6a279c9f3ff35f7e544e43df2fbecc">&#9670;&#160;</a></span>getFieldIndex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Array &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t cstone::getFieldIndex </td>
          <td>(</td>
          <td class="paramtype">std::string_view&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Array &amp;&#160;</td>
          <td class="paramname"><em>fieldNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compile-time index look-up of a string literal in a list of strings </p>

</div>
</div>
<a id="ad6363d74bcfa471820a465ae60754ffe" name="ad6363d74bcfa471820a465ae60754ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6363d74bcfa471820a465ae60754ffe">&#9670;&#160;</a></span>getFields()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Dataset , class Tuple , util::StructuralString... Fields&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) cstone::getFields </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structutil_1_1FieldList.html">util::FieldList</a>&lt; Fields... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab25df0d24626d6a364cadd70014387b4" name="ab25df0d24626d6a364cadd70014387b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab25df0d24626d6a364cadd70014387b4">&#9670;&#160;</a></span>getHost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;util::StructuralString... Fields, class Dataset &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) cstone::getHost </td>
          <td>(</td>
          <td class="paramtype">Dataset &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd20c14b8f8bc227c4c0181a4a0bf9fa" name="abd20c14b8f8bc227c4c0181a4a0bf9fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd20c14b8f8bc227c4c0181a4a0bf9fa">&#9670;&#160;</a></span>getLevelRangeCpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::getLevelRangeCpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>nodeKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>levelRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determine the octree subdivision level boundaries </p>

</div>
</div>
<a id="a6435851940ec611425cb49b4d59960df" name="a6435851940ec611425cb49b4d59960df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6435851940ec611425cb49b4d59960df">&#9670;&#160;</a></span>getPointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto cstone::getPointers </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a tuple of pointers to element i of <code>tup</code> = tuple of vector-like containers </p>

</div>
</div>
<a id="a26b72eeeddc9b4ff6d9e66b5551d93a4" name="a26b72eeeddc9b4ff6d9e66b5551d93a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b72eeeddc9b4ff6d9e66b5551d93a4">&#9670;&#160;</a></span>globalFocusExchange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Q , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T , class F , class Accelerator , class... UArgs&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::globalFocusExchange </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Octree.html">Octree</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>globalOctree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1FocusedOctree.html">FocusedOctree</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>, T, Accelerator &gt; &amp;&#160;</td>
          <td class="paramname"><em>focusTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; Q &gt;&#160;</td>
          <td class="paramname"><em>quantities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>upsweepFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>upsweepArgs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>exchange data of non-peer (beyond focus) tree cells </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Q</td><td>an arithmetic type, or compile-time fix-sized arrays thereof </td></tr>
    <tr><td class="paramname">T</td><td>float or double </td></tr>
    <tr><td class="paramname">F</td><td>function object for octree upsweep </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">globalOctree</td><td>a global (replicated on all ranks) tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">focusTree</td><td>octree focused on the executing rank </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">quantities</td><td>an array of length focusTree.octree().numTreeNodes() with cell properties of the locally focused octree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upsweepFunction</td><td>callable object that will be used to compute internal cell properties of the global tree based on global leaf quantities </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">upsweepArgs</td><td>additional arguments that might be required for a tree upsweep, such as expansion centers if Q is a multipole type.</td></tr>
  </table>
  </dd>
</dl>
<p>This function obtains missing information for tree cell quantities belonging to far-away ranks which are not peer ranks of the executing rank.</p>
<p>The data flow is: cell quantities owned by executing rank -&gt; globalLeafQuantities -&gt; global collective communication -&gt; upsweep -&gt; back-contribution from globalQuantities into <code>quantities</code> </p>
<p>Precondition: quantities contains valid data for each cell, including internal cells, that fall into the focus range of the executing rank Postcondition: each element of quantities corresponding to non-local cells not owned by any of the peer ranks contains data obtained through global collective communication between ranks </p>
<p>exchange global leaves</p>
<p>upsweep with the global tree</p>
<p>from the global tree, extract the part that the executing rank was missing</p>

</div>
</div>
<a id="a0122e33f79e345ef446fa458c7f223b9" name="a0122e33f79e345ef446fa458c7f223b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0122e33f79e345ef446fa458c7f223b9">&#9670;&#160;</a></span>haloexchange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Arrays&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::haloexchange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>epoch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1SendList.html">SendList</a> &amp;&#160;</td>
          <td class="paramname"><em>incomingHalos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1SendList.html">SendList</a> &amp;&#160;</td>
          <td class="paramname"><em>outgoingHalos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arrays...&#160;</td>
          <td class="paramname"><em>arrays</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc95690c1f0df3bc885c46a5ac068311" name="abc95690c1f0df3bc885c46a5ac068311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc95690c1f0df3bc885c46a5ac068311">&#9670;&#160;</a></span>haloExchangeGpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DevVec1 , class DevVec2 , class... Arrays&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::haloExchangeGpu </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>epoch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1SendList.html">SendList</a> &amp;&#160;</td>
          <td class="paramname"><em>incomingHalos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1SendList.html">SendList</a> &amp;&#160;</td>
          <td class="paramname"><em>outgoingHalos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DevVec1 &amp;&#160;</td>
          <td class="paramname"><em>sendScratchBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DevVec2 &amp;&#160;</td>
          <td class="paramname"><em>receiveScratchBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arrays...&#160;</td>
          <td class="paramname"><em>arrays</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac9eab950b9acb82f20f12541c3464c35" name="ac9eab950b9acb82f20f12541c3464c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9eab950b9acb82f20f12541c3464c35">&#9670;&#160;</a></span>hilbertIBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> cstone::hilbertIBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>keyStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the 3D integer coordinate box that contains the key range </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyStart</td><td>lower Hilbert key </td></tr>
    <tr><td class="paramname">keyEnd</td><td>upper Hilbert key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the integer box that contains the given key range </dd></dl>

</div>
</div>
<a id="a4f7f860eefca16f0b7242e15e1b022fe" name="a4f7f860eefca16f0b7242e15e1b022fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7f860eefca16f0b7242e15e1b022fe">&#9670;&#160;</a></span>hilbertIBoxKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> cstone::hilbertIBoxKeys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>keyStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>keyEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convenience wrapper </p>

</div>
</div>
<a id="a4a572ff0054fe71fa407673f3eab291a" name="a4a572ff0054fe71fa407673f3eab291a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a572ff0054fe71fa407673f3eab291a">&#9670;&#160;</a></span>iceil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr size_t cstone::iceil </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dividend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>divisor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ceil(dividend/divisor) for unsigned integers </p>

</div>
</div>
<a id="aa4dcb84daaec6536e0aaa988668c16eb" name="aa4dcb84daaec6536e0aaa988668c16eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4dcb84daaec6536e0aaa988668c16eb">&#9670;&#160;</a></span>idecodeMortonX()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; std::is_unsigned&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;{}, unsigned &gt; cstone::idecodeMortonX </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extract X component from a morton code </p>

</div>
</div>
<a id="a75767b0ac157bf8808a7a24a0f2da2fd" name="a75767b0ac157bf8808a7a24a0f2da2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75767b0ac157bf8808a7a24a0f2da2fd">&#9670;&#160;</a></span>idecodeMortonY()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; std::is_unsigned&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;{}, unsigned &gt; cstone::idecodeMortonY </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extract Y component from a morton code </p>

</div>
</div>
<a id="acb0d8dc950035be984093e6e10376394" name="acb0d8dc950035be984093e6e10376394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb0d8dc950035be984093e6e10376394">&#9670;&#160;</a></span>idecodeMortonZ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; std::is_unsigned&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;{}, unsigned &gt; cstone::idecodeMortonZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extract Z component from a morton code </p>

</div>
</div>
<a id="a52bd5946e8e61320adfcd45c3f4971cc" name="a52bd5946e8e61320adfcd45c3f4971cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bd5946e8e61320adfcd45c3f4971cc">&#9670;&#160;</a></span>iHilbert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; std::is_unsigned_v&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; cstone::iHilbert </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>py</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>pz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the Hilbert key for a 3D point of integer coordinates </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">px,py,pz</td><td>input coordinates in [0:2^maxTreeLevel&lt;KeyType&gt;{}] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Hilbert key </dd></dl>

</div>
</div>
<a id="a6cd10a5de70ff3ed14b1a99991179ad1" name="a6cd10a5de70ff3ed14b1a99991179ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd10a5de70ff3ed14b1a99991179ad1">&#9670;&#160;</a></span>iHilbert2D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; std::is_unsigned_v&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; cstone::iHilbert2D </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the Hilbert key for a 2D point of integer coordinates </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">px,py</td><td>input coordinates in [0:2^maxTreeLevel&lt;KeyType&gt;{}] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Hilbert key </dd></dl>

</div>
</div>
<a id="aca7fb4903e25f925e03ba06febfaf3d2" name="aca7fb4903e25f925e03ba06febfaf3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7fb4903e25f925e03ba06febfaf3d2">&#9670;&#160;</a></span>iMorton() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; std::is_unsigned&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;{}, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; cstone::iMorton </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>iy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>iz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a Morton code for a 3D point in integer coordinates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64 bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ix,iy,iz</td><td>input coordinates in [0:2^maxTreeLevel&lt;KeyType&gt;{}] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a01db86768abd4018d795355d13b1fc75" name="a01db86768abd4018d795355d13b1fc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01db86768abd4018d795355d13b1fc75">&#9670;&#160;</a></span>iMorton() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> cstone::iMorton </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>iy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>iz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>treeLevel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculate morton code from n-level integer 3D coordinates. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ix,iy,iz</td><td>input integer box coordinates, must be in the range [0, 2^treeLevel-1] </td></tr>
    <tr><td class="paramname">treeLevel</td><td>octree subdivison level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the morton code </dd></dl>

</div>
</div>
<a id="a3fb7e55212d2cf4f6037cc3789314ec9" name="a3fb7e55212d2cf4f6037cc3789314ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb7e55212d2cf4f6037cc3789314ec9">&#9670;&#160;</a></span>initialDomainSplits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; cstone::initialDomainSplits </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numRanks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return <code>numRanks</code> equal length SFC segments for initial domain decomposition </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numRanks</td><td>number of segments </td></tr>
    <tr><td class="paramname">level</td><td>maximum tree depths or (=number of non-zero leading octal digits) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the segments</dd></dl>
<p>Example: returns [0 2525200000 5252500000 10000000000] for numRanks = 3 and level = 5 </p>

</div>
</div>
<a id="a67378828dfbab190ed20b44b4951d7f1" name="a67378828dfbab190ed20b44b4951d7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67378828dfbab190ed20b44b4951d7f1">&#9670;&#160;</a></span>injectKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class Alloc &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::injectKeys </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>, Alloc &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>keys</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inject specified keys into a cornerstone leaf tree </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tree</td><td>cornerstone octree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keys</td><td>list of SFC keys to insert</td></tr>
  </table>
  </dd>
</dl>
<p>This function needs to insert more than just <code>keys</code>, due the cornerstone invariant of consecutive nodes always having a power-of-8 difference. This means that each subdividing a node, all 8 children always have to be added. </p>

</div>
</div>
<a id="a92b8be6d3ec450bf99f6c2ec89d759c3" name="a92b8be6d3ec450bf99f6c2ec89d759c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b8be6d3ec450bf99f6c2ec89d759c3">&#9670;&#160;</a></span>insideBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> bool cstone::insideBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if the cuboid defined by center and size is contained within the bounding box </p>

</div>
</div>
<a id="a9a0aff1cf6863f5d6a6f32ebe071cde7" name="a9a0aff1cf6863f5d6a6f32ebe071cde7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a0aff1cf6863f5d6a6f32ebe071cde7">&#9670;&#160;</a></span>invertRanges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structcstone_1_1IndexPair.html">IndexPair</a>&lt; <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt; &gt; cstone::invertRanges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="structcstone_1_1IndexPair.html">IndexPair</a>&lt; <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculates the complementary range of the input ranges </p>
<p>Input:  ---&mdash; --&mdash; &ndash; -&mdash; &ndash;  Output: ----&mdash; -&mdash; &mdash; --&mdash; --&mdash; &mdash; ^ ^   </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td> </td></tr>
    <tr><td class="paramname">ranges</td><td>size &gt;= 1, must be sorted  </td></tr>
    <tr><td class="paramname">last</td><td>/ </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output ranges that cover everything within [first:last] that the input ranges did not cover </dd></dl>

</div>
</div>
<a id="a92963f07615ad16e265a0c525750eb85" name="a92963f07615ad16e265a0c525750eb85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92963f07615ad16e265a0c525750eb85">&#9670;&#160;</a></span>invThetaMinMac()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> float cstone::invThetaMinMac </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute 1/theta + s for the minimum distance MAC </p>

</div>
</div>
<a id="aa3153af86effca88169036a024d4d37c" name="aa3153af86effca88169036a024d4d37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3153af86effca88169036a024d4d37c">&#9670;&#160;</a></span>invThetaVecMac()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> float cstone::invThetaVecMac </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>theta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute 1/theta + s for the worst-case vector MAC </p>

</div>
</div>
<a id="aa2e7a2cadb54fca11090363230c8e092" name="aa2e7a2cadb54fca11090363230c8e092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e7a2cadb54fca11090363230c8e092">&#9670;&#160;</a></span>isAncestor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr bool cstone::isAncestor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return true if a is an ancestor of b or if a is a sibling of an ancestor of b </p>

</div>
</div>
<a id="af74c05ec93266d68239eedea007d51d2" name="af74c05ec93266d68239eedea007d51d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74c05ec93266d68239eedea007d51d2">&#9670;&#160;</a></span>iSfcKey() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; <a class="el" href="structcstone_1_1IsMorton.html">IsMorton</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;{}, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; cstone::iSfcKey </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>iy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>iz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Key encode overload for Morton keys. </p>

</div>
</div>
<a id="ae20db4c89bb64c02b6100f834cf44189" name="ae20db4c89bb64c02b6100f834cf44189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20db4c89bb64c02b6100f834cf44189">&#9670;&#160;</a></span>iSfcKey() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; <a class="el" href="structcstone_1_1IsHilbert.html">IsHilbert</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;{}, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; cstone::iSfcKey </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>ix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>iy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>iz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Key encode overload for Hilbert keys. </p>

</div>
</div>
<a id="a04fb4d5442270713bb8bc7aeca3b0b82" name="a04fb4d5442270713bb8bc7aeca3b0b82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04fb4d5442270713bb8bc7aeca3b0b82">&#9670;&#160;</a></span>isLeafIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr bool cstone::isLeafIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>nodeIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>checks whether a binary tree index corresponds to a leaf index </p>

</div>
</div>
<a id="acd74e2142c82f18659c4778f030a3e15" name="acd74e2142c82f18659c4778f030a3e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd74e2142c82f18659c4778f030a3e15">&#9670;&#160;</a></span>isPowerOf8()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr bool cstone::isPowerOf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether n is a power of 8 </p>

</div>
</div>
<a id="ad6f987f0a7b7cb62e98a43012b94fa2f" name="ad6f987f0a7b7cb62e98a43012b94fa2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f987f0a7b7cb62e98a43012b94fa2f">&#9670;&#160;</a></span>lastNzPlace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr int cstone::lastNzPlace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return position of last non-zero octal digit place in x </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>an integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>position of the last non-zero octal digit place, starting from 1 (left-most digit place) to 10 or 21 (64-bit), the right-most digit place. Returns 10 or 21 (64-bit) if x is zero. </dd></dl>

</div>
</div>
<a id="a9c12e16cab4a89d81bc2e07ac2c2f9f3" name="a9c12e16cab4a89d81bc2e07ac2c2f9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c12e16cab4a89d81bc2e07ac2c2f9f3">&#9670;&#160;</a></span>leafToInternal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class Accelerator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">gsl::span&lt; const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt; cstone::leafToInternal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1OctreeData.html">OctreeData</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>, Accelerator &gt; &amp;&#160;</td>
          <td class="paramname"><em>octree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a058de6b372d77881570754bbb339a240" name="a058de6b372d77881570754bbb339a240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058de6b372d77881570754bbb339a240">&#9670;&#160;</a></span>limitBoundaryShifts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::limitBoundaryShifts </td>
          <td>(</td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>oldBoundaries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>newTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const unsigned &gt;&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcstone_1_1SpaceCurveAssignment.html">SpaceCurveAssignment</a> &amp;&#160;</td>
          <td class="paramname"><em>newAssignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>limit SFC range assignment transfer to the domain of the rank above or below </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">oldBoundaries</td><td>SFC key assignment boundaries to ranks from the previous step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">newTree</td><td>the global octree leaves used for domain decomposition in the current step </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counts</td><td>particle counts per leaf cell in <code>newTree</code> </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">newAssignment</td><td>the current assignment, will be modified if needed</td></tr>
  </table>
  </dd>
</dl>
<p>When assignment boundaries change, we limit the growth of any rank downwards or upwards the SFC to the previous assignment of the rank below or above, i.e. rank r can only acquire new SFC areas that belonged to ranks r-1 or r+1 in the previous step. This limitation never kicks in for any halfway reasonable particle configuration as the handover of a rank's entire domain to another rank is quite an extreme scenario. But the limitation is useful for focused torture tests to demonstrate that the domain and octree invariants still hold under such circumstances. Imposing this limitation here is needed to guarantee that the focus tree resolution of any rank in its focus is not exceeded in the trees of any other rank. </p>

</div>
</div>
<a id="af7f863c69e15e957dbd75ad5cc049340" name="af7f863c69e15e957dbd75ad5cc049340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f863c69e15e957dbd75ad5cc049340">&#9670;&#160;</a></span>linkTreeCpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::linkTreeCpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>numInternalNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>leafToInternal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>levelRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>childOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>parents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extract parent/child relationships from binary tree and translate to sorted order </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>unsigned 32- or 64-bit integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prefixes</td><td>octree node prefixes in Warren-Salmon format </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numInternalNodes</td><td>number of internal octree nodes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">leafToInternal</td><td>translation map from unsorted layout to level/SFC sorted octree layout length is total number of octree nodes, internal + leaves </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">levelRange</td><td>indices of the first node at each level </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">childOffsets</td><td>octree node index of first child for each node, length is total number of nodes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">parents</td><td>parent index of for each node which is the first of 8 siblings i.e. the parent of node i is stored at parents[(i - 1)/8] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e8197184b6d3da4357baf1dd8d9cf57" name="a7e8197184b6d3da4357baf1dd8d9cf57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e8197184b6d3da4357baf1dd8d9cf57">&#9670;&#160;</a></span>loadLeafIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> cstone::loadLeafIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>restore a leaf index from the storage format </p>

</div>
</div>
<a id="a2d98b14c83424cc18ef39d8f6b38d8d8" name="a2d98b14c83424cc18ef39d8f6b38d8d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d98b14c83424cc18ef39d8f6b38d8d8">&#9670;&#160;</a></span>locateNode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> cstone::locateNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>nodeKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>levelRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>locate with <code>nodeKey</code> given in Warren-Salmon placeholder-bit format </p>

</div>
</div>
<a id="aae35e7010bca5c00123ca2e3372fb8e7" name="aae35e7010bca5c00123ca2e3372fb8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae35e7010bca5c00123ca2e3372fb8e7">&#9670;&#160;</a></span>locateNode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> cstone::locateNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>startKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>endKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>levelRange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the index of the node with SFC key range [startKey:endKey] </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startKey</td><td>lower SFC key </td></tr>
    <tr><td class="paramname">endKey</td><td>upper SFC key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index i of the node that satisfies codeStart(i) == startKey and codeEnd(i) == endKey, or numTreeNodes() if no such node exists. </dd></dl>
<p>prefixLength is 3 * treeLevel(endKey - startKey)</p>

</div>
</div>
<a id="a366f08c027ae6bcd8afdbf873f2cd948" name="a366f08c027ae6bcd8afdbf873f2cd948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366f08c027ae6bcd8afdbf873f2cd948">&#9670;&#160;</a></span>log8ceil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr unsigned cstone::log8ceil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute ceil(log8(n)) </p>

</div>
</div>
<a id="a2c05889c82ed9b4f99fc8652ec4e92a8" name="a2c05889c82ed9b4f99fc8652ec4e92a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c05889c82ed9b4f99fc8652ec4e92a8">&#9670;&#160;</a></span>lowerBoundGpu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class IndexType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cstone::lowerBoundGpu </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>valueFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>valueLast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a27585a7935f94c50cc6741628054ffc8" name="a27585a7935f94c50cc6741628054ffc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27585a7935f94c50cc6741628054ffc8">&#9670;&#160;</a></span>lowerBoundGpu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t cstone::lowerBoundGpu </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93e1980bc3b020c7c78fe8fba8ea90d6" name="a93e1980bc3b020c7c78fe8fba8ea90d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93e1980bc3b020c7c78fe8fba8ea90d6">&#9670;&#160;</a></span>makeGlobalBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Op  = MinMax&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto cstone::makeGlobalBox </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>previousBox</em> = <code><a class="el" href="classcstone_1_1Box.html">Box</a>&lt;T&gt;(0,&#160;1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute global bounding box for local x,y,z arrays </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>float or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>x coordinate array start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">y</td><td>y coordinate array start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">z</td><td>z coordinate array start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numElements</td><td>length of <em>x</em>,y,z arrays </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">previousBox</td><td>previous coordinate bounding box, default open-boundary box with limits ignored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new bounding box</dd></dl>
<p>For each periodic dimension, limits are fixed and will not be modified. For non-periodic dimensions, limits are determined by global min/max. </p>

</div>
</div>
<a id="a73ad9d460d331348d451f336e4d70d9c" name="a73ad9d460d331348d451f336e4d70d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ad9d460d331348d451f336e4d70d9c">&#9670;&#160;</a></span>makeHaloBox() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class CoordinateType , class RadiusType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> cstone::makeHaloBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RadiusType&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; CoordinateType &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a box with specified radius around node delineated by codeStart/End </p>

</div>
</div>
<a id="a84601c8dc86babee053dd371eb3a1acb" name="a84601c8dc86babee053dd371eb3a1acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84601c8dc86babee053dd371eb3a1acb">&#9670;&#160;</a></span>makeHaloBox() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class CoordinateType , class RadiusType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> cstone::makeHaloBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>codeStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>codeEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RadiusType&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; CoordinateType &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a box with specified radius around node delineated by codeStart/End </p>

</div>
</div>
<a id="a55c9d16d29b405984e5e7e9a547017f8" name="a55c9d16d29b405984e5e7e9a547017f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55c9d16d29b405984e5e7e9a547017f8">&#9670;&#160;</a></span>makeNLevelGrid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; I &gt; cstone::makeNLevelGrid </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a uniform grid of SFC codes </p>

</div>
</div>
<a id="a7692fb6ab797e4c497fc69b7f4afe52f" name="a7692fb6ab797e4c497fc69b7f4afe52f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7692fb6ab797e4c497fc69b7f4afe52f">&#9670;&#160;</a></span>makePrefix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> cstone::makePrefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the placeholder-bit prefix for the biggest possible node that starts at <code>a</code> </p>

</div>
</div>
<a id="aa8ec4b59cebfcf34d51cd47d329336bf" name="aa8ec4b59cebfcf34d51cd47d329336bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ec4b59cebfcf34d51cd47d329336bf">&#9670;&#160;</a></span>makeRootNodeTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; I &gt; cstone::makeRootNodeTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns an octree with just the root node </p>

</div>
</div>
<a id="a7f92230428b7a80937108192b446c6ec" name="a7f92230428b7a80937108192b446c6ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f92230428b7a80937108192b446c6ec">&#9670;&#160;</a></span>makeUniformNLevelTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class I &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; I &gt; cstone::makeUniformNLevelTree </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>nParticles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bucketSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a uniform cornerstone octree with 8^ceil(log8(nBuckets)) nodes </p>

</div>
</div>
<a id="a71f569845ca10ff4bacca42eed2fd287" name="a71f569845ca10ff4bacca42eed2fd287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f569845ca10ff4bacca42eed2fd287">&#9670;&#160;</a></span>markMacPerBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> void cstone::markMacPerBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>targetCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>targetSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>childOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a3c2b5abd635257ad027f958158d2ae21">Vec4</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>focusStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>focusEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>markings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>mark all nodes of <code>octree</code> (leaves and internal) that fail the evaluateMac w.r.t to <code>target</code> </p>

</div>
</div>
<a id="ada05a9ac34188ec75a417d15ef0ecbd1" name="ada05a9ac34188ec75a417d15ef0ecbd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada05a9ac34188ec75a417d15ef0ecbd1">&#9670;&#160;</a></span>markMacs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::markMacs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structcstone_1_1OctreeView.html">OctreeView</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>octree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a3c2b5abd635257ad027f958158d2ae21">Vec4</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>focusStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>focusEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>markings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark each node in an octree that fails the MAC paired with any node from a given focus SFC range. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>float or double </td></tr>
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">octree</td><td>octree, including internal part </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">centers</td><td>tree cell expansion (com) center coordinates and mac radius, size <code>octree.numTreeNodes()</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>global coordinate bounding box </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">focusStart</td><td>lower SFC focus code </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">focusEnd</td><td>upper SFC focus code </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">markings</td><td>array of length <code>octree.numTreeNodes()</code>, each position i will be set to 1, if the node of <code>octree</code> with index i fails the MAC paired with any node contained in the focus range [focusStart:focusEnd] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff03f64859fe8445a281bc6a7d7d0e70" name="aff03f64859fe8445a281bc6a7d7d0e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff03f64859fe8445a281bc6a7d7d0e70">&#9670;&#160;</a></span>massCenter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Ts , class Tc , class Tm &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a3767e831204a1a7e180456eced6d15e5">SourceCenterType</a>&lt; Ts &gt; cstone::massCenter </td>
          <td>(</td>
          <td class="paramtype">const Tc *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tc *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tc *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tm *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a>&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute a mass center from particles </p>

</div>
</div>
<a id="a5887e9a73201a008261f28051232d9f7" name="a5887e9a73201a008261f28051232d9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5887e9a73201a008261f28051232d9f7">&#9670;&#160;</a></span>maxDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> cstone::maxDepth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>levelOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">levelOffsets</td><td>array with level offset indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>length of <code>levelOffsets</code> (identical to <a class="el" href="structcstone_1_1maxTreeLevel.html">maxTreeLevel</a> + 2) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="a7a6c5d79a62a2faece2dfd25ecff4123" name="a7a6c5d79a62a2faece2dfd25ecff4123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a6c5d79a62a2faece2dfd25ecff4123">&#9670;&#160;</a></span>maxNormSquareGpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T cstone::maxNormSquareGpu </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1bd1154189698f17192551fe9dc9ea20" name="a1bd1154189698f17192551fe9dc9ea20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd1154189698f17192551fe9dc9ea20">&#9670;&#160;</a></span>maxNumRanges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t cstone::maxNumRanges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1SendList.html">SendList</a> &amp;&#160;</td>
          <td class="paramname"><em>sendList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a7d6cc236e3956657901f7485eaa804" name="a6a7d6cc236e3956657901f7485eaa804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7d6cc236e3956657901f7485eaa804">&#9670;&#160;</a></span>mergeCountAndMacOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> int cstone::mergeCountAndMacOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>nodeIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>nodeKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>childOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>parents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>macs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>focusStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>focusEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bucketSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>combines the particle count and multipole criteria for rebalancing </p>
<dl class="section return"><dt>Returns</dt><dd><ul>
<li>0 if node to be merged</li>
<li>1 if node to stay unchanged</li>
<li>8 if node to be split </li>
</ul>
</dd></dl>

</div>
</div>
<a id="aebe97e73f0e56eb55c5ec1421188ba07" name="aebe97e73f0e56eb55c5ec1421188ba07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe97e73f0e56eb55c5ec1421188ba07">&#9670;&#160;</a></span>minDistance() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; cstone::minDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>bCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>bSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the smallest distance vector between two boxes, 0 if they overlap </p>

</div>
</div>
<a id="ad2926ebebbbd59dd875d1b76ce284780" name="ad2926ebebbbd59dd875d1b76ce284780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2926ebebbbd59dd875d1b76ce284780">&#9670;&#160;</a></span>minDistance() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; cstone::minDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>aCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>bCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>bSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the smallest periodic distance vector between two boxes, 0 if they overlap </p>

</div>
</div>
<a id="a9a969cdbe72b38a77605c75863652e2f" name="a9a969cdbe72b38a77605c75863652e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a969cdbe72b38a77605c75863652e2f">&#9670;&#160;</a></span>minDistance() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; cstone::minDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>bCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>bSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the smallest distance vector of point X to box b, 0 if X is in b </p>

</div>
</div>
<a id="af79c464a99e13af9d60f56afb680a221" name="af79c464a99e13af9d60f56afb680a221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79c464a99e13af9d60f56afb680a221">&#9670;&#160;</a></span>minDistance() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; cstone::minDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>bCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>bSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the smallest periodic distance vector of point X to box b, 0 if X is in b </p>

</div>
</div>
<a id="abb1e5c5dee8fbe4f7cfe98057de2064f" name="abb1e5c5dee8fbe4f7cfe98057de2064f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1e5c5dee8fbe4f7cfe98057de2064f">&#9670;&#160;</a></span>minDistanceSq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> T cstone::minDistanceSq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience wrapper to minDistance. This should only be used for testing. </p>

</div>
</div>
<a id="aedb4e6471bd9e9a4a1634f5f2867d0d2" name="aedb4e6471bd9e9a4a1634f5f2867d0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb4e6471bd9e9a4a1634f5f2867d0d2">&#9670;&#160;</a></span>minMacMutual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> bool cstone::minMacMutual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>centerA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>centerB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>invTheta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>commutative version of the min-distance mac, based on floating point math </p>

</div>
</div>
<a id="a27845dc2ac5f1c5b89145cc0e4ac891d" name="a27845dc2ac5f1c5b89145cc0e4ac891d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27845dc2ac5f1c5b89145cc0e4ac891d">&#9670;&#160;</a></span>minVecMacMutual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> bool cstone::minVecMacMutual </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>centerA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizeA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>centerB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizeB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>invThetaEff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>commutative combination of min-distance and vector map </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">invThetaEff</td><td>1/theta + s, effective inverse opening parameter</td></tr>
  </table>
  </dd>
</dl>
<p>This MAC doesn't pass any A-B pairs that would fail either the min-distance or vector MAC. Can be used instead of the vector mac when the mass center locations are not known. </p>

</div>
</div>
<a id="a1b3f9c38718cf35b2601a4b970da82bc" name="a1b3f9c38718cf35b2601a4b970da82bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3f9c38718cf35b2601a4b970da82bc">&#9670;&#160;</a></span>mortonIBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> cstone::mortonIBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>keyStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the 3D integer coordinate box that contains the key range </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyStart</td><td>lower Morton key of the tree cell </td></tr>
    <tr><td class="paramname">level</td><td>octree subdivision level of the tree cell </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the integer box that contains the given key range </dd></dl>

</div>
</div>
<a id="a89b3736ffa6b65d0c54c9e05d1ab06ce" name="a89b3736ffa6b65d0c54c9e05d1ab06ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b3736ffa6b65d0c54c9e05d1ab06ce">&#9670;&#160;</a></span>mortonIBoxKeys()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> cstone::mortonIBoxKeys </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>keyStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>keyEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1dbc37f14064985ccf1d261936b2f56c" name="a1dbc37f14064985ccf1d261936b2f56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbc37f14064985ccf1d261936b2f56c">&#9670;&#160;</a></span>nNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t cstone::nNodes </td>
          <td>(</td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns the number of nodes in a tree </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Vector</td><td>a vector-like container that has a .size() member </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>input tree </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of nodes</dd></dl>
<p>This makes it explicit that a vector of n Morton codes corresponds to a tree with n-1 nodes. </p>

</div>
</div>
<a id="abe7368a509c88737ec8a557403c1fdec" name="abe7368a509c88737ec8a557403c1fdec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7368a509c88737ec8a557403c1fdec">&#9670;&#160;</a></span>nodeFpCenters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::nodeFpCenters </td>
          <td>(</td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute geometric node centers based on node SFC keys and the global bounding box </p>

</div>
</div>
<a id="ad2eb2287ba506a5fe544bf2627b4977b" name="ad2eb2287ba506a5fe544bf2627b4977b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2eb2287ba506a5fe544bf2627b4977b">&#9670;&#160;</a></span>nodeRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> cstone::nodeRange </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>treeLevel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute the maximum range of an octree node at a given subdivision level </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">treeLevel</td><td>octree subdivision level </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the range</dd></dl>
<p>At treeLevel 0, the range is the entire 30 or 63 bits used in the SFC code. After that, the range decreases by 3 bits for each level. </p>

</div>
</div>
<a id="ac095f0a0465d7704f9837a6d8d00e2bf" name="ac095f0a0465d7704f9837a6d8d00e2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac095f0a0465d7704f9837a6d8d00e2bf">&#9670;&#160;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr T cstone::normalize </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>normalize a spatial length w.r.t. to a min/max range </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">d</td><td></td></tr>
    <tr><td class="paramname">min</td><td></td></tr>
    <tr><td class="paramname">max</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="acb66a196d6e8bb727fd847dd1aff9b7a" name="acb66a196d6e8bb727fd847dd1aff9b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb66a196d6e8bb727fd847dd1aff9b7a">&#9670;&#160;</a></span>normalizeMass()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a3767e831204a1a7e180456eced6d15e5">SourceCenterType</a>&lt; T &gt; cstone::normalizeMass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a3767e831204a1a7e180456eced6d15e5">SourceCenterType</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>center</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finish mass center computation by diving coordinates by total mass </p>

</div>
</div>
<a id="a0d961aca810f7e594ae23c83407b24fe" name="a0d961aca810f7e594ae23c83407b24fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d961aca810f7e594ae23c83407b24fe">&#9670;&#160;</a></span>numElementsFit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Alignment, class... Arrays&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t cstone::numElementsFit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytesAvail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arrays...&#160;</td>
          <td class="paramname"><em>arrays</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of elements of all <code>arrays</code> that fit into <code>numBytesAvail</code> </p>

</div>
</div>
<a id="a4f257ac711f6ef81c1dfe2107cbf4ff2" name="a4f257ac711f6ef81c1dfe2107cbf4ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f257ac711f6ef81c1dfe2107cbf4ff2">&#9670;&#160;</a></span>nzAncestorOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> cstone::nzAncestorOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>nodeIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>parents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>nodeOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overrides a 0-value of nodeOps[nodeIdx] if <code>nodeIdx</code> is the left-most descendant of a non-zero ancestor. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeIdx</td><td>index of a leaf node to check </td></tr>
    <tr><td class="paramname">prefixes</td><td>node SFC keys in placeholder-bit format </td></tr>
    <tr><td class="paramname">parents</td><td>parent node indices per group of 8 siblings </td></tr>
    <tr><td class="paramname">nodeOps</td><td>node transformation operation in {0, 1, 8} </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 or nodeOps[closestNonZeroAncestor]</dd></dl>
<p>If <code>nodeIdx</code> is the left-most descendant of the closest ancestor with a non-zero nodeOps value, return the nodeOps value of the ancestor, 0 otherwise </p>

</div>
</div>
<a id="a1dcbc63abef4bbbac0fde10cbc77ea00" name="a1dcbc63abef4bbbac0fde10cbc77ea00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dcbc63abef4bbbac0fde10cbc77ea00">&#9670;&#160;</a></span>octalDigit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr unsigned cstone::octalDigit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>extract the n-th octal digit from an SFC key, starting from the most significant </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>Input SFC key code </td></tr>
    <tr><td class="paramname">position</td><td>Which digit place to extract. Return values will be meaningful for <code>position</code> in [1:11] for 32-bit keys and in [1:22] for 64-bit keys and will be zero otherwise, but a value of 0 for <code>position</code> can also be specified to detect whether the 31st or 63rd bit for the last cornerstone is non-zero. (The last cornerstone has a value of nodeRange&lt;KeyType&gt;(0) = 2^31 or 2^63) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the digit at place <code>position</code> </dd></dl>
<p>The position argument correspondence to octal digit places has been chosen such that octalDigit(code, pos) returns the octant at octree division level pos. </p>

</div>
</div>
<a id="aeffea930222fd56e27345f02dd181544" name="aeffea930222fd56e27345f02dd181544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeffea930222fd56e27345f02dd181544">&#9670;&#160;</a></span>octalPower()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> cstone::octalPower </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the power of 8 for the octal place at position <code>pos</code> </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>Position counting from left, starting from 1. Maximum value 10 or 21 (64-bit) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the power of 8 associated with the indicated octal place </dd></dl>

</div>
</div>
<a id="aedc6a11f3c77f13d55976dacaf86862b" name="aedc6a11f3c77f13d55976dacaf86862b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc6a11f3c77f13d55976dacaf86862b">&#9670;&#160;</a></span>omp_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::omp_copy </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>copy with multiple OpenMP threads </p>

</div>
</div>
<a id="acf53e91f88a6f7c9b738bbb2c2485e32" name="acf53e91f88a6f7c9b738bbb2c2485e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf53e91f88a6f7c9b738bbb2c2485e32">&#9670;&#160;</a></span>overlap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> bool cstone::overlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check whether two boxes overlap. takes PBC into account, boxes can wrap around </p>

</div>
</div>
<a id="a63eaf497749b63b3348ef8233e3acdf2" name="a63eaf497749b63b3348ef8233e3acdf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63eaf497749b63b3348ef8233e3acdf2">&#9670;&#160;</a></span>overlapRange()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr bool cstone::overlapRange </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>determine whether two ranges ab and cd overlap </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>periodic range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false</dd></dl>
<p>Some restrictions apply, no input value can be further than R from the periodic range. </p>

</div>
</div>
<a id="a5af31c5d2856b4995d020b1c999f8007" name="a5af31c5d2856b4995d020b1c999f8007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af31c5d2856b4995d020b1c999f8007">&#9670;&#160;</a></span>overlapTwoRanges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr bool cstone::overlapTwoRanges </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>d</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>standard criterion for two ranges a-b and c-d to overlap, a&lt;b and c&lt;d </p>

</div>
</div>
<a id="a6c438ae28e65cd6d9c2f73610e45fcee" name="a6c438ae28e65cd6d9c2f73610e45fcee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c438ae28e65cd6d9c2f73610e45fcee">&#9670;&#160;</a></span>packArrays()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int alignment, class F , class... Arrays&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t cstone::packArrays </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>gather</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> *&#160;</td>
          <td class="paramname"><em>ordering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a>&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arrays...&#160;</td>
          <td class="paramname"><em>arrays</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gather <code>numElements</code> of each array accessed through <code>ordering</code> into <code>buffer</code>. CPU and GPU. </p>

</div>
</div>
<a id="a888644d7cc3080934ff932ecf4e6fef2" name="a888644d7cc3080934ff932ecf4e6fef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a888644d7cc3080934ff932ecf4e6fef2">&#9670;&#160;</a></span>packBufferPtrs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int alignment, class... Arrays&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto cstone::packBufferPtrs </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>packedBufferBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>arraySize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Arrays...&#160;</td>
          <td class="paramname"><em>arrays</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute multiple pointers such that the argument <code>arrays</code> can be mapped into a single buffer. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">alignment</td><td>byte alignment of the individual arrays in the packed buffer </td></tr>
    <tr><td class="paramname">Arrays</td><td>arbitrary type of size 16 bytes or smaller </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packedBufferBase</td><td>base address of the packed buffer </td></tr>
    <tr><td class="paramname">arraySize</td><td>number of elements of each <code>array</code> </td></tr>
    <tr><td class="paramname">arrays</td><td>independent array pointers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a tuple with (src, packed) pointers for each array</dd></dl>
<p><code>arrays:</code> ---&mdash; ---&mdash; ---&mdash; (pointers) a b c</p>
<p>packedBuffer |---&mdash;|---&mdash;|---&mdash;| (pointer) A B C | packedBufferBase</p>
<p>return tuple( (a, A), (b, B), (c, C) )</p>
<p>Pointer types are <a class="el" href="structutil_1_1array.html" title="std::array-like compile-time size array">util::array</a>&lt;float, sizeof(*(a, b or c) / sizeof(float)&gt;..., i.e. the same size as the original element types. This is done to express all types up to 16 bytes with just four <a class="el" href="structutil_1_1array.html" title="std::array-like compile-time size array">util::array</a> types in order to reduce the number of gather/scatter GPU kernel template instantiations. </p>

</div>
</div>
<a id="a88e7cf1f2fbfdead5327f969077f8e96" name="a88e7cf1f2fbfdead5327f969077f8e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e7cf1f2fbfdead5327f969077f8e96">&#9670;&#160;</a></span>pad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> cstone::pad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add (binary) zeros behind a prefix </p>
<p>Allows comparisons, such as number of leading common bits (cpr) of the prefix with SFC codes.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>the bit pattern </td></tr>
    <tr><td class="paramname">length</td><td>number of bits in the prefix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>prefix padded out with zeros</dd></dl>
<p>Examples: pad(0b011u,  3) -&gt; 0b00011 &lt;&lt; 27 pad(0b011ul, 3) -&gt; 0b0011ul &lt;&lt; 60</p>
<p>i.e. <code>length</code> plus the number of zeros added adds up to 30 for 32-bit integers or 63 for 64-bit integers, because these are the numbers of usable bits in SFC codes. </p>

</div>
</div>
<a id="a8a2dce1b58e7b191458e54c806104633" name="a8a2dce1b58e7b191458e54c806104633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2dce1b58e7b191458e54c806104633">&#9670;&#160;</a></span>pbcAdjust()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr int cstone::pbcAdjust </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>map x into periodic range 0...R-1 </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td>periodic range </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x mapped into periodic range</dd></dl>
<p>Examples: -1 -&gt; R-1 0 -&gt; 0 1 -&gt; 1 R-1 -&gt; R-1 R -&gt; 0 R+1 -&gt; 1 </p>

</div>
</div>
<a id="aba18e6aab18c5f0526b4ac1d8a362071" name="aba18e6aab18c5f0526b4ac1d8a362071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba18e6aab18c5f0526b4ac1d8a362071">&#9670;&#160;</a></span>pbcDistance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int R&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr int cstone::pbcDistance </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maps x into the range [-R/2+1: R/2+1] (-511 to 512 with R = 1024) </p>

</div>
</div>
<a id="ab037b5d134c9a444399ff0830e3ef7b7" name="ab037b5d134c9a444399ff0830e3ef7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab037b5d134c9a444399ff0830e3ef7b7">&#9670;&#160;</a></span>processNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> void cstone::processNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>nodeIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>oldTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>nodeOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>newTree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>transform old nodes into new nodes based on opcodes </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeIndex</td><td>the node to process in <code>oldTree</code> </td></tr>
    <tr><td class="paramname">oldTree</td><td>the old tree </td></tr>
    <tr><td class="paramname">nodeOps</td><td>opcodes per old tree node </td></tr>
    <tr><td class="paramname">newTree</td><td>the new tree </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c2b4ac1679226c9f319e0856f165d90" name="a6c2b4ac1679226c9f319e0856f165d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2b4ac1679226c9f319e0856f165d90">&#9670;&#160;</a></span>protectAncestors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cstone::protectAncestors </td>
          <td>(</td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>nodeKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>parents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>nodeOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ef64cd9d40e71e96389fd38df2a624b" name="a9ef64cd9d40e71e96389fd38df2a624b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef64cd9d40e71e96389fd38df2a624b">&#9670;&#160;</a></span>protectAncestorsGpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cstone::protectAncestorsGpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a36c66fac2dfa8a2f60a9a8717039c573" name="a36c66fac2dfa8a2f60a9a8717039c573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c66fac2dfa8a2f60a9a8717039c573">&#9670;&#160;</a></span>putInBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt; cstone::putInBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a7e1dfa0259eedf8f87f334dab04e92da">Vec3</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fold X into a periodic image that lies inside <em>box</em>. </p>

</div>
</div>
<a id="a64074858ad1cdf8d64e35e43c2116184" name="a64074858ad1cdf8d64e35e43c2116184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64074858ad1cdf8d64e35e43c2116184">&#9670;&#160;</a></span>rebalanceDecision()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class <a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cstone::rebalanceDecision </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>nNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bucketSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a4e01a219224a6310ad91973dbcaf1b1e">LocalIndex</a> *&#160;</td>
          <td class="paramname"><em>nodeOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute split or fuse decision for each octree node in parallel. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>octree nodes given as SFC codes of length <code>nNodes</code> needs to satisfy the octree invariants </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counts</td><td>output particle counts per node, length = <code>nNodes</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nNodes</td><td>number of nodes in tree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bucketSize</td><td>maximum particle count per (leaf) node and minimum particle count (strictly &gt;) for (implicit) internal nodes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodeOps</td><td>stores rebalance decision result for each node, length = <code>nNodes</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all nodes are unchanged, false otherwise</dd></dl>
<p>For each node i in the tree, in nodeOps[i], stores</p><ul>
<li>0 if to be merged</li>
<li>1 if unchanged,</li>
<li>8 if to be split. </li>
</ul>

</div>
</div>
<a id="aa714a728fc64746d0b4258a372aee6e9" name="aa714a728fc64746d0b4258a372aee6e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa714a728fc64746d0b4258a372aee6e9">&#9670;&#160;</a></span>rebalanceDecisionEssential()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::rebalanceDecisionEssential </td>
          <td>(</td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>nodeKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>childOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>parents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>macs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>focusStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>focusEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bucketSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>nodeOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute locally essential split or fuse decision for each octree node in parallel. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeKeys</td><td>warren-salmon SFC keys for each tree node, length = <code>numNodes</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">childOffsets</td><td>node index of first child (0 identifies a leaf), length = <code>numNodes</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">parents</td><td>parent node index for each group of 8 siblings, length = (numNodes-1) / 8 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counts</td><td>particle count of each tree node, length = <code>numNodes</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">macs</td><td>multipole pass or fail per node, length = <code>numNodes</code> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">focusStart</td><td>first focus SFC key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">focusEnd</td><td>last focus SFC key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bucketSize</td><td>maximum particle count per (leaf) node and minimum particle count (strictly &gt;) for (implicit) internal nodes </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">nodeOps</td><td>stores rebalance decision result for each node, length = <code>numNodes</code> only leaf nodes will be set, internal nodes are ignored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if converged, false otherwise</dd></dl>
<p>For each leaf node i in the tree, in nodeOps[i], stores</p><ul>
<li>0 if to be merged</li>
<li>1 if unchanged,</li>
<li>8 if to be split. </li>
</ul>

</div>
</div>
<a id="adb3449f787ec814ea5b9313f2dd74de7" name="adb3449f787ec814ea5b9313f2dd74de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3449f787ec814ea5b9313f2dd74de7">&#9670;&#160;</a></span>rebalanceDecisionEssentialGpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cstone::rebalanceDecisionEssentialGpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>childOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>parents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned *&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>macs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>focusStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>focusEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bucketSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>nodeOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>numNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a30283c76e76daa6b00f4f4c7d381b758" name="a30283c76e76daa6b00f4f4c7d381b758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30283c76e76daa6b00f4f4c7d381b758">&#9670;&#160;</a></span>rebalanceTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputVector , class OutputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::rebalanceTree </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputVector &amp;&#160;</td>
          <td class="paramname"><em>newTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>nodeOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>split or fuse octree nodes based on node counts relative to bucketSize </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>cornerstone octree </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">newTree</td><td>rebalanced cornerstone octree </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nodeOps</td><td>rebalance decision for each node, length <code>numNodes(tree)</code> + 1 will be overwritten </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b8e2a6dc6e18bf9c83704ada3011c36" name="a9b8e2a6dc6e18bf9c83704ada3011c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8e2a6dc6e18bf9c83704ada3011c36">&#9670;&#160;</a></span>rebalanceTreeGpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cstone::rebalanceTreeGpu </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>numNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>newNumNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>nodeOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>newTree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a17dd0c7ff6a33d06e97f40ea93de14df" name="a17dd0c7ff6a33d06e97f40ea93de14df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17dd0c7ff6a33d06e97f40ea93de14df">&#9670;&#160;</a></span>reduceGpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tin , class Tout &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tout cstone::reduceGpu </td>
          <td>(</td>
          <td class="paramtype">const Tin *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tout&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8903485c9d64446ad1959c2babeb8085" name="a8903485c9d64446ad1959c2babeb8085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8903485c9d64446ad1959c2babeb8085">&#9670;&#160;</a></span>round_up()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr size_t cstone::round_up </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>round up <code>n</code> to multiple of <code>m</code> </p>

</div>
</div>
<a id="a7b486f0ab3931822b00ae976aadb932e" name="a7b486f0ab3931822b00ae976aadb932e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b486f0ab3931822b00ae976aadb932e">&#9670;&#160;</a></span>scaleGpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cstone::scaleGpu </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a936a255f2dc7870c011b659cc5e0b1ec" name="a936a255f2dc7870c011b659cc5e0b1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a936a255f2dc7870c011b659cc5e0b1ec">&#9670;&#160;</a></span>scatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IndexType , class ValueType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::scatter </td>
          <td>(</td>
          <td class="paramtype">gsl::span&lt; const IndexType &gt;&#160;</td>
          <td class="paramname"><em>ordering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>scatter reorder </p>

</div>
</div>
<a id="a192615b23fc8f7f187589b44bef872b8" name="a192615b23fc8f7f187589b44bef872b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192615b23fc8f7f187589b44bef872b8">&#9670;&#160;</a></span>scatterRanges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class IndexType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cstone::scatterRanges </td>
          <td>(</td>
          <td class="paramtype">const IndexType *&#160;</td>
          <td class="paramname"><em>rangeScan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexType *&#160;</td>
          <td class="paramname"><em>rangeOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numRanges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d0cc274b41e52039951d6ade0fd9ef5" name="a4d0cc274b41e52039951d6ade0fd9ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0cc274b41e52039951d6ade0fd9ef5">&#9670;&#160;</a></span>segmentMax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tin , class Tout , class IndexType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cstone::segmentMax </td>
          <td>(</td>
          <td class="paramtype">const Tin *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IndexType *&#160;</td>
          <td class="paramname"><em>segments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numSegments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tout *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>determine maximum elements in an array divided into multiple segments </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Tin</td><td>some type that supports comparison </td></tr>
    <tr><td class="paramname">Tout</td><td>some type that supports comparison </td></tr>
    <tr><td class="paramname">IndexType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>an array of length <em>segments</em>[numSegments] </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">segments</td><td>an array of length <em>numSegments</em> + 1 describing the segmentation of <em>input</em> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numSegments</td><td>number of segments </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>maximum in each segment, length <em>numSegments</em> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e5f3165630928bf87004240cfd521d3" name="a1e5f3165630928bf87004240cfd521d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5f3165630928bf87004240cfd521d3">&#9670;&#160;</a></span>sequenceGpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IndexType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cstone::sequenceGpu </td>
          <td>(</td>
          <td class="paramtype">IndexType *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IndexType&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f2de04bb3f7d8aa6876a84711d8476e" name="a1f2de04bb3f7d8aa6876a84711d8476e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2de04bb3f7d8aa6876a84711d8476e">&#9670;&#160;</a></span>setMac()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::setMac </td>
          <td>(</td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>nodeKeys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; <a class="el" href="namespacecstone.html#a3767e831204a1a7e180456eced6d15e5">SourceCenterType</a>&lt; T &gt; &gt;&#160;</td>
          <td class="paramname"><em>centers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>invTheta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>replace the last center element (mass) with the squared mac radius </p>

</div>
</div>
<a id="a8a655cdac9558c2b1d5735efdb837fc3" name="a8a655cdac9558c2b1d5735efdb837fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a655cdac9558c2b1d5735efdb837fc3">&#9670;&#160;</a></span>sfc3D() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> cstone::sfc3D </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates a Hilbert key for a 3D point within the specified box. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit Morton or Hilbert key type. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">x,y,z</td><td>input coordinates within the unit cube [0,1]^3 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">box</td><td>bounding for coordinates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the SFC key</dd></dl>
<p>Note: -KeyType needs to be specified explicitly. -not specifying an unsigned type results in a compilation error </p>

</div>
</div>
<a id="a00769dd2c65537a35757eb88b787d6fb" name="a00769dd2c65537a35757eb88b787d6fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00769dd2c65537a35757eb88b787d6fb">&#9670;&#160;</a></span>sfc3D() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> cstone::sfc3D </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>xmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>ymin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>zmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>mx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>my</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>mz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6fbf5fb6b1b594658cf28e9fb01a7e0f" name="a6fbf5fb6b1b594658cf28e9fb01a7e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbf5fb6b1b594658cf28e9fb01a7e0f">&#9670;&#160;</a></span>sfcIBox() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> cstone::sfcIBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>keyStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>keyEnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convenience overload </p>

</div>
</div>
<a id="a7b874e24bd703a1fc7cece9dff7319b2" name="a7b874e24bd703a1fc7cece9dff7319b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b874e24bd703a1fc7cece9dff7319b2">&#9670;&#160;</a></span>sfcIBox() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; <a class="el" href="structcstone_1_1IsMorton.html">IsMorton</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;{}, <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> &gt; cstone::sfcIBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>keyStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create and integer box from Morton keys </p>

</div>
</div>
<a id="a87ce41855c1576305d3d4c2ba8c6888f" name="a87ce41855c1576305d3d4c2ba8c6888f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ce41855c1576305d3d4c2ba8c6888f">&#9670;&#160;</a></span>sfcIBox() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> std::enable_if_t&lt; <a class="el" href="structcstone_1_1IsHilbert.html">IsHilbert</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;{}, <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> &gt; cstone::sfcIBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>keyStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create and integer box from Hilbert keys </p>

</div>
</div>
<a id="a74f5b958a480e3cdd096655e062b4ba7" name="a74f5b958a480e3cdd096655e062b4ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74f5b958a480e3cdd096655e062b4ba7">&#9670;&#160;</a></span>sfcKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a4d054fd740773a4ffbaecadfb6cecf92">SfcKind</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; cstone::sfcKey </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6b1384393b71ef54fe312b1dc87612c5" name="a6b1384393b71ef54fe312b1dc87612c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1384393b71ef54fe312b1dc87612c5">&#9670;&#160;</a></span>sfcKindPointer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> const <a class="el" href="namespacecstone.html#a4d054fd740773a4ffbaecadfb6cecf92">SfcKind</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; * cstone::sfcKindPointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert a integer pointer to the corresponding strongly typed SFC key pointer </p>

</div>
</div>
<a id="af9fd895eb19ec2ea4ed7c7277144bc44" name="af9fd895eb19ec2ea4ed7c7277144bc44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9fd895eb19ec2ea4ed7c7277144bc44">&#9670;&#160;</a></span>sfcKindPointer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespacecstone.html#a4d054fd740773a4ffbaecadfb6cecf92">SfcKind</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; * cstone::sfcKindPointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>convert an integer pointer to the corresponding strongly typed SFC key pointer </p>

</div>
</div>
<a id="abb9e16c392e9194a8ad7db68e3b6c884" name="abb9e16c392e9194a8ad7db68e3b6c884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9e16c392e9194a8ad7db68e3b6c884">&#9670;&#160;</a></span>sfcNeighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> cstone::sfcNeighbor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a72f04118d59095aa5ac36e505d445d0b">IBox</a> &amp;&#160;</td>
          <td class="paramname"><em>ibox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the smallest Hilbert key contained in the shifted box </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ibox</td><td>cubic integer coordinate box, edge length is a power of 2 </td></tr>
    <tr><td class="paramname">dx</td><td>x-shift, in units of the ibox edge length </td></tr>
    <tr><td class="paramname">dy</td><td>y-shift, in units of the ibox edge length </td></tr>
    <tr><td class="paramname">dz</td><td>z-shift, in units of the ibox edge length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the smallest key part of ibox shifted by (dx, dy, dz) </dd></dl>

</div>
</div>
<a id="a4411d480bef1d2248a7588f15cf56108" name="a4411d480bef1d2248a7588f15cf56108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4411d480bef1d2248a7588f15cf56108">&#9670;&#160;</a></span>siblingAndLevel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">util::tuple</a>&lt; int, unsigned &gt; cstone::siblingAndLevel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>csTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>nodeIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the sibling index and level of the specified csTree node </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">csTree</td><td>cornerstone octree, length N </td></tr>
    <tr><td class="paramname">nodeIdx</td><td>node index in [0:N] of <code>csTree</code> to compute sibling index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>in first pair element: index in [0:8] if all 8 siblings of the specified node are next to each other and at the same division level. -1 otherwise, i.e. if not all the 8 siblings exist in <code>csTree</code> at the same division level in second pair element: tree level of node at <code>nodeIdx</code> </dd></dl>
<p>Sibling nodes are group of 8 leaf nodes that have the same parent node. </p>

</div>
</div>
<a id="a3db9706ccab0a9816d5a59d6b3c0d046" name="a3db9706ccab0a9816d5a59d6b3c0d046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db9706ccab0a9816d5a59d6b3c0d046">&#9670;&#160;</a></span>singleRangeSfcSplit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcstone_1_1SpaceCurveAssignment.html">SpaceCurveAssignment</a> cstone::singleRangeSfcSplit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>globalCounts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nSplits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>assign the global tree/SFC to nSplits ranks, assigning to each rank only a single Morton code range </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">globalCounts</td><td>counts per leaf </td></tr>
    <tr><td class="paramname">nSplits</td><td>divide the global tree into nSplits pieces, sensible choice e.g.: nSplits == numRanks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector with nSplit elements, each element is a vector of SfcRanges of Morton codes</dd></dl>
<p>This function acts on global data. All calling ranks should call this function with identical arguments. Therefore each rank will compute the same <a class="el" href="classcstone_1_1SpaceCurveAssignment.html" title="stores which parts of the SFC belong to which rank, on a per-rank basis">SpaceCurveAssignment</a> and each rank will thus know the ranges that all the ranks are assigned. </p>

</div>
</div>
<a id="a0897f5abb9304cd370691d0f3acc2833" name="a0897f5abb9304cd370691d0f3acc2833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0897f5abb9304cd370691d0f3acc2833">&#9670;&#160;</a></span>singleTraversal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> void cstone::singleTraversal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>childOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>continuationCriterion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;&#160;</td>
          <td class="paramname"><em>endpointAction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a32c515535a3dc4da80b36efad0209c6f" name="a32c515535a3dc4da80b36efad0209c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c515535a3dc4da80b36efad0209c6f">&#9670;&#160;</a></span>smallestCommonBox()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">util::tuple</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; cstone::smallestCommonBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>firstKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>secondKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute an enclosing envelope corresponding to the smallest possible octree node for two input SFC codes </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">firstKey</td><td>first SFC key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">secondKey</td><td>second SFC key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>two SFC keys that delineate the start and end of the smallest octree node that contains both input keys </dd></dl>

</div>
</div>
<a id="a87dac531bf09977046c7e254522e3250" name="a87dac531bf09977046c7e254522e3250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87dac531bf09977046c7e254522e3250">&#9670;&#160;</a></span>sort_by_key() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InoutIterator , class OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::sort_by_key </td>
          <td>(</td>
          <td class="paramtype">InoutIterator&#160;</td>
          <td class="paramname"><em>inBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InoutIterator&#160;</td>
          <td class="paramname"><em>inEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>outBegin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the sortKey that sorts the input sequence, default ascending order </p>

</div>
</div>
<a id="af265e7e15a2ec8efa2e0c003acaac616" name="af265e7e15a2ec8efa2e0c003acaac616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af265e7e15a2ec8efa2e0c003acaac616">&#9670;&#160;</a></span>sort_by_key() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InoutIterator , class OutputIterator , class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::sort_by_key </td>
          <td>(</td>
          <td class="paramtype">InoutIterator&#160;</td>
          <td class="paramname"><em>keyBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InoutIterator&#160;</td>
          <td class="paramname"><em>keyEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>valueBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sort values according to a key </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keyBegin</td><td>key sequence start </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">keyEnd</td><td>key sequence end </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">valueBegin</td><td>values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>comparison function</td></tr>
  </table>
  </dd>
</dl>
<p>Upon completion of this routine, the key sequence will be sorted and values will be rearranged to reflect the key ordering </p>

</div>
</div>
<a id="ad732f7405445b02189e1104fa17690b1" name="ad732f7405445b02189e1104fa17690b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad732f7405445b02189e1104fa17690b1">&#9670;&#160;</a></span>sortByKeyGpu() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cstone::sortByKeyGpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a837a7f0c8f24b32e041018d43116d724" name="a837a7f0c8f24b32e041018d43116d724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837a7f0c8f24b32e041018d43116d724">&#9670;&#160;</a></span>sortByKeyGpu() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class ValueType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cstone::sortByKeyGpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>keyBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueType *&#160;</td>
          <td class="paramname"><em>valueBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07b2a553fd9770d6a014a8b6b3165730" name="a07b2a553fd9770d6a014a8b6b3165730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b2a553fd9770d6a014a8b6b3165730">&#9670;&#160;</a></span>spanSfcRange() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int cstone::spanSfcRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>overload to skip storage and just compute number of values, see spanSfcRange(KeyType a, KeyType b, KeyType*
output) above </p>

</div>
</div>
<a id="a441f5658d946885a1528d4ed214339f5" name="a441f5658d946885a1528d4ed214339f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441f5658d946885a1528d4ed214339f5">&#9670;&#160;</a></span>spanSfcRange() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class Store &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt; std::is_same_v&lt; Store, std::nullptr_t &gt;||std::is_same_v&lt; Store, <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> * &gt;, int &gt; cstone::spanSfcRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Store&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>generate SFC codes to cover the range [a:b] with a valid cornerstone sub-octree </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
    <tr><td class="paramname">Store</td><td>either std::nullptr_t or KeyType* </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>first SFC code </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>second SFC code, b &gt; a </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>output SFC codes, includes a, excludes b </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of values in output <pre class="fragment">                 | a_last_nz_pos (10)
</pre> Example: a: 0001 b: 0742 ab_first_diff_pos ^ ^ b_last_nz_pos (8) (10)</dd></dl>
<p>output: 1 2 3 4 5 6 7 10 20 30 40 50 60 70 100 200 300 400 500 600 700 710 720 730 740 741</p>
<p>Variables suffixed with "_pos" refer to an octal digit place. The value of 1 is the position of the left-most digit, and 10 (or 21 for 64-bit) refers to the right-most digit place. This convention is chosen such that the positional value coincides with the corresponding octree subdivision level. </p>

</div>
</div>
<a id="ac79408cd9f7644d48fe84a48c42ae163" name="ac79408cd9f7644d48fe84a48c42ae163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac79408cd9f7644d48fe84a48c42ae163">&#9670;&#160;</a></span>storeLeafIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> cstone::storeLeafIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert a leaf index to the storage format </p>

</div>
</div>
<a id="aafcbc01b2db139fd7f8c07503ea4555a" name="aafcbc01b2db139fd7f8c07503ea4555a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafcbc01b2db139fd7f8c07503ea4555a">&#9670;&#160;</a></span>toNBitInt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> unsigned cstone::toNBitInt </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>normalize a floating point number in [0,1] to an integer in [0 : 2^(10 or 21)] </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32-bit or 64-bit unsigned integer </td></tr>
    <tr><td class="paramname">T</td><td>float or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input floating point number in [0,1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x converted to an 10-bit or 21-bit integer maximum return value is 1023 or 2097151</dd></dl>
<p>Integer conversion happens with truncation as required for SFC code calculations </p>

</div>
</div>
<a id="abb204b9aa10b513f13fca2242eda85a9" name="abb204b9aa10b513f13fca2242eda85a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb204b9aa10b513f13fca2242eda85a9">&#9670;&#160;</a></span>toNBitIntCeil()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> , class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr unsigned cstone::toNBitIntCeil </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>normalize a floating point number in [0,1] to an integer in [0 : 2^(10 or 21)] </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32-bit or 64-bit unsigned integer </td></tr>
    <tr><td class="paramname">T</td><td>float or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input floating point number in [0,1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>x converted to an 10-bit or 21-bit integer maximum return value is 1023 or 2097151</dd></dl>
<p>Integer conversion happens with ceil() as required for converting halo radii to integers where we must round up to the smallest integer not less than x*2^(10 or 21) </p>

</div>
</div>
<a id="aa1f396c695e26b7edb950e4e9b8a8c71" name="aa1f396c695e26b7edb950e4e9b8a8c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f396c695e26b7edb950e4e9b8a8c71">&#9670;&#160;</a></span>translateAssignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::translateAssignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1SpaceCurveAssignment.html">SpaceCurveAssignment</a> &amp;&#160;</td>
          <td class="paramname"><em>assignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>domainTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>focusTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const int &gt;&#160;</td>
          <td class="paramname"><em>peerRanks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>myRank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacecstone.html#ab92e8dfcff11066ac75330812a896de9">TreeIndexPair</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>focusAssignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>translates an assignment of a given tree to a new tree </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">assignment</td><td>domain assignment </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">domainTree</td><td>domain tree leaves </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">focusTree</td><td>focus tree leaves </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">peerRanks</td><td>list of peer ranks </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">myRank</td><td>executing rank ID </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">focusAssignment</td><td>assignment with the same SFC key ranges per peer rank as the domain <code>assignment</code>, but with indices valid w.r.t <code>focusTree</code> </td></tr>
  </table>
  </dd>
</dl>
<p>The focus assignment is implemented as a plain vector; since only the ranges of peer ranks (and not all ranks) are set, the requirements of <a class="el" href="classcstone_1_1SpaceCurveAssignment.html" title="stores which parts of the SFC belong to which rank, on a per-rank basis">SpaceCurveAssignment</a> are not met and its findRank() function would not work. </p>

</div>
</div>
<a id="a3180e184261c7da178feb8f1cdd07c9f" name="a3180e184261c7da178feb8f1cdd07c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3180e184261c7da178feb8f1cdd07c9f">&#9670;&#160;</a></span>treeLevel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr unsigned cstone::treeLevel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>codeRange</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return octree subdivision level corresponding to codeRange </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codeRange</td><td>input SFC code range </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>octree subdivision level 0-10 (32-bit) or 0-21 (64-bit) </dd></dl>

</div>
</div>
<a id="a51fe3b49146bae7b2c48dcd93f720cd7" name="a51fe3b49146bae7b2c48dcd93f720cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51fe3b49146bae7b2c48dcd93f720cd7">&#9670;&#160;</a></span>updateContinuumCsarray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class T , class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cstone::updateContinuumCsarray </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>concentration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcstone_1_1Box.html">Box</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bucketSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>counts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a090ebf42ad9e3fcc46e9e1801b61cf3c" name="a090ebf42ad9e3fcc46e9e1801b61cf3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a090ebf42ad9e3fcc46e9e1801b61cf3c">&#9670;&#160;</a></span>updateInternalTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::updateInternalTree </td>
          <td>(</td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>leaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcstone_1_1OctreeView.html">OctreeView</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>o</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e3d0a04ce76554a09310ecf1491637e" name="a0e3d0a04ce76554a09310ecf1491637e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e3d0a04ce76554a09310ecf1491637e">&#9670;&#160;</a></span>updateNodeCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> unsigned cstone::updateNodeCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a>&#160;</td>
          <td class="paramname"><em>nodeIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::make_signed_t&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>firstGuess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::make_signed_t&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>secondGuess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>codesStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>codesEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate node counts with a guess to accelerate the binary search </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodeIdx</td><td>the index of the node in <code>tree</code> to compute </td></tr>
    <tr><td class="paramname">tree</td><td>cornerstone octree </td></tr>
    <tr><td class="paramname">firstGuess</td><td>guess location of <code>tree</code>[nodeIdx] in [codesStart:codesEnd] </td></tr>
    <tr><td class="paramname">secondGuess</td><td>guess location of <code>tree</code>[nodeIdx+1] in [codesStart:codesEnd] </td></tr>
    <tr><td class="paramname">codesStart</td><td>particle SFC code array start </td></tr>
    <tr><td class="paramname">codesEnd</td><td>particle SFC code array end </td></tr>
    <tr><td class="paramname">maxCount</td><td>maximum particle count to report per node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of particles in the node at <code>nodeIdx</code> or maxCount, whichever is smaller </dd></dl>

</div>
</div>
<a id="a88a1ec7cae65b6e22b7ca82cb56766e1" name="a88a1ec7cae65b6e22b7ca82cb56766e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a1ec7cae65b6e22b7ca82cb56766e1">&#9670;&#160;</a></span>updateOctree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cstone::updateOctree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>codesStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>codesEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bucketSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxCount</em> = <code>std::numeric_limits&lt;unsigned&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>update the octree with a single rebalance/count step </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer for SFC code </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">codesStart</td><td>local particle SFC codes start </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">codesEnd</td><td>local particle SFC codes end </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bucketSize</td><td>maximum number of particles per node </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tree</td><td>the octree leaf nodes (cornerstone format) </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">counts</td><td>the octree leaf node particle count </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">maxCount</td><td>if actual node counts are higher, they will be capped to <code>maxCount</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if tree was not modified, false otherwise</dd></dl>
<p>Remarks: It is sensible to assume that the bucket size of the tree is much smaller than 2^32, and thus it is ok to use 32-bit integers for the node counts, because if the node count happens to be bigger than 2^32 for a node, this node will anyway be divided until the node count is smaller than the bucket size. We just have to make sure to prevent overflow, in MPI_Allreduce, therefore, maxCount should be set to 2^32/numRanks - 1 for distributed tree builds. </p>

</div>
</div>
<a id="a0dcac472e9a458b39654d869ee33435a" name="a0dcac472e9a458b39654d869ee33435a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dcac472e9a458b39654d869ee33435a">&#9670;&#160;</a></span>updateOctreeGlobal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cstone::updateOctreeGlobal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>keyStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>keyEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bucketSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcstone_1_1Octree.html">Octree</a>&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>counts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>global update step of an octree, including regeneration of the internal node structure </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>unsigned 32- or 64-bit integer </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">keyStart</td><td>first particle key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">keyEnd</td><td>last particle key </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bucketSize</td><td>max number of particles per leaf </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">tree</td><td>a fully linked octree </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">counts</td><td>leaf node particle counts </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">numRanks</td><td>number of MPI ranks </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if tree was not changed </dd></dl>

</div>
</div>
<a id="a42cf065220a8232bdedfaa255d405ffa" name="a42cf065220a8232bdedfaa255d405ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42cf065220a8232bdedfaa255d405ffa">&#9670;&#160;</a></span>updateOctreeGlobal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool cstone::updateOctreeGlobal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>keyStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> *&#160;</td>
          <td class="paramname"><em>keyEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bucketSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned &gt; &amp;&#160;</td>
          <td class="paramname"><em>counts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform one octree update, consisting of one rebalance and one node counting step </p>
<p>See documentation of updateOctree </p>

</div>
</div>
<a id="af5bb6086c47be8ddb833d56d0b576382" name="af5bb6086c47be8ddb833d56d0b576382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5bb6086c47be8ddb833d56d0b576382">&#9670;&#160;</a></span>updateTreelet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; cstone::updateTreelet </td>
          <td>(</td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt;&#160;</td>
          <td class="paramname"><em>treelet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const unsigned &gt;&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bucketSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>update a treelet (sub-octree not spanning full SFC) based on node counts </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyType</td><td>32- or 64-bit unsigned integer for SFC code </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">treelet</td><td>cornerstone key sequence, covering only part of the SFC </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">counts</td><td>particle counts per cell in <code>treelet</code>, length = treelet.size() - 1 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">bucketSize</td><td>rebalance criterion </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>rebalanced treelet with nodes split where count &gt; <code>bucketSize</code> </dd></dl>
<p>Currently used for rebalancing an SFC range before hand-over to another rank after assignment shift. </p>

</div>
</div>
<a id="aadfa5884a2d8afd6ccedc727ef7e5714" name="aadfa5884a2d8afd6ccedc727ef7e5714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadfa5884a2d8afd6ccedc727ef7e5714">&#9670;&#160;</a></span>upsweep()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class CombinationFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void cstone::upsweep </td>
          <td>(</td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt;&#160;</td>
          <td class="paramname"><em>levelOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gsl::span&lt; const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> &gt;&#160;</td>
          <td class="paramname"><em>childOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>quantities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CombinationFunction &amp;&amp;&#160;</td>
          <td class="paramname"><em>combinationFunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae12e79798529918fb410f00377196713" name="ae12e79798529918fb410f00377196713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12e79798529918fb410f00377196713">&#9670;&#160;</a></span>upsweepCentersGpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cstone::upsweepCentersGpu </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>levelRange</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> *&#160;</td>
          <td class="paramname"><em>childOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecstone.html#a3767e831204a1a7e180456eced6d15e5">SourceCenterType</a>&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>centers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compute center of gravity for internal nodes with an upsweep </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>float or double </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">numLevels</td><td>max tree depth </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">levelRange</td><td>first node index per tree level </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">childOffsets</td><td>indices of first child node of each node </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">centers</td><td>center of mass coordinates with leaf node centers set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a491da2b745e89f2f955aa26504452bf0" name="a491da2b745e89f2f955aa26504452bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491da2b745e89f2f955aa26504452bf0">&#9670;&#160;</a></span>zeroLowBits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a> cstone::zeroLowBits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mesh_8hpp.html#ad29765d017498143e4586d5d86b9f32b">KeyType</a>&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>nBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>zero all but the highest nBits in a SFC code </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a512a141ed0f250c7cb25ce891981d0aa" name="a512a141ed0f250c7cb25ce891981d0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512a141ed0f250c7cb25ce891981d0aa">&#9670;&#160;</a></span>eightSiblings</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespacecstone.html#a02ddbbe0e6bf938c6b5675d15fd3ced3">TreeNodeIndex</a> cstone::eightSiblings = 8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fixed number of children per node. </p>
<p>This is beneficial for performance as long as the bucket-size, which is the minimum particle count of an internal node and the maximum count of a leaf, remains well above 8 and becomes very disadvantageous when resolving every particle in its own leaf node. </p>

</div>
</div>
<a id="a6856f8936f03359f68fee86ea43ecd1b" name="a6856f8936f03359f68fee86ea43ecd1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6856f8936f03359f68fee86ea43ecd1b">&#9670;&#160;</a></span>gatherCpu</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto cstone::gatherCpu</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">const</span> <span class="keyword">auto</span>* ordering, <span class="keyword">auto</span> numElements, <span class="keyword">const</span> <span class="keyword">auto</span>* src, <span class="keyword">const</span> <span class="keyword">auto</span> dest) {</div>
<div class="line">    gather&lt;LocalIndex&gt;({ordering, numElements}, src, dest);</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Lambda to avoid templated functors that would become template-template parameters when passed to functions. </p>

</div>
</div>
<a id="a3e34f9437a564d29f806c424793680ca" name="a3e34f9437a564d29f806c424793680ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e34f9437a564d29f806c424793680ca">&#9670;&#160;</a></span>gatherGpuL</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto cstone::gatherGpuL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">const</span> <span class="keyword">auto</span>* ordering, <span class="keyword">auto</span> numElements, <span class="keyword">const</span> <span class="keyword">auto</span>* src, <span class="keyword">const</span> <span class="keyword">auto</span> dest)</div>
<div class="line">{ <a class="code hl_function" href="namespacecstone.html#a297a9d4fedfb90e8f3e614a666fb2fb0">gatherGpu</a>(ordering, numElements, src, dest); }</div>
<div class="ttc" id="anamespacecstone_html_a297a9d4fedfb90e8f3e614a666fb2fb0"><div class="ttname"><a href="namespacecstone.html#a297a9d4fedfb90e8f3e614a666fb2fb0">cstone::gatherGpu</a></div><div class="ttdeci">void gatherGpu(const IndexType *ordering, size_t numElements, const T *src, T *buffer)</div></div>
</div><!-- fragment -->
<p>Lambda to avoid templated functors that would become template-template parameters when passed to functions. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacecstone.html">cstone</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
