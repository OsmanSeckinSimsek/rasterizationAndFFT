<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rasterizationAndFFT + Cornerstone API: type_list.hpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">rasterizationAndFFT + Cornerstone API
   </div>
   <div id="projectbrief">Distributed octree domain, rasterization, and FFT utilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('type__list_8hpp.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">type_list.hpp File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;cassert&gt;</code><br />
<code>#include &lt;tuple&gt;</code><br />
<code>#include &lt;type_traits&gt;</code><br />
<code>#include &quot;<a class="el" href="stl_8hpp_source.html">cstone/primitives/stl.hpp</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for type_list.hpp:</div>
<div class="dyncontent">
<div class="center"><img src="type__list_8hpp__incl.png" border="0" usemap="#atype__list_8hpp" alt=""/></div>
<map name="atype__list_8hpp" id="atype__list_8hpp">
<area shape="rect" title=" " alt="" coords="105,5,212,31"/>
<area shape="rect" title=" " alt="" coords="5,79,75,104"/>
<area shape="poly" title=" " alt="" coords="141,33,73,74,70,69,138,28"/>
<area shape="rect" title=" " alt="" coords="99,79,154,104"/>
<area shape="poly" title=" " alt="" coords="156,32,140,67,135,65,151,30"/>
<area shape="rect" title=" " alt="" coords="146,152,238,177"/>
<area shape="poly" title=" " alt="" coords="164,31,189,138,184,139,159,32"/>
<area shape="rect" href="stl_8hpp.html" title="Functionality that exist in std::, but cannot be used in device code." alt="" coords="230,79,413,104"/>
<area shape="poly" title=" " alt="" coords="186,28,283,71,281,75,184,33"/>
<area shape="poly" title=" " alt="" coords="302,106,227,147,224,143,299,102"/>
<area shape="rect" href="annotation_8hpp.html" title="Defines macros for enabling device code compilation." alt="" coords="263,152,465,177"/>
<area shape="poly" title=" " alt="" coords="331,103,352,139,348,142,326,106"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="type__list_8hpp__dep__incl.png" border="0" usemap="#atype__list_8hppdep" alt=""/></div>
<map name="atype__list_8hppdep" id="atype__list_8hppdep">
<area shape="rect" title=" " alt="" coords="601,5,708,31"/>
<area shape="rect" href="buffer__description_8hpp.html" title="Buffer description and management for domain decomposition particle exchanges." alt="" coords="494,79,661,104"/>
<area shape="poly" title=" " alt="" coords="634,42,592,80,588,76,630,38"/>
<area shape="rect" href="domain_8hpp.html" title="A domain class to manage distributed particles and their halos." alt="" coords="289,299,388,324"/>
<area shape="poly" title=" " alt="" coords="588,33,444,61,269,104,184,131,109,160,50,193,28,210,13,227,8,238,13,249,30,263,58,274,132,291,216,301,289,306,289,311,215,306,131,296,56,279,28,267,8,252,3,238,8,224,25,206,47,188,107,156,182,126,267,99,443,56,587,28"/>
<area shape="rect" href="data__util_8hpp.html" title="Utility functions to resolve names of particle fields to pointers." alt="" coords="803,79,909,104"/>
<area shape="poly" title=" " alt="" coords="701,33,824,76,822,81,699,38"/>
<area shape="rect" href="h5part__wrapper_8hpp.html" title="A C++ layer over H5Part." alt="" coords="934,79,1085,104"/>
<area shape="poly" title=" " alt="" coords="722,30,952,76,951,81,721,35"/>
<area shape="rect" href="ifile__io_8hpp.html" title="file I/O interface" alt="" coords="685,79,779,104"/>
<area shape="poly" title=" " alt="" coords="679,38,721,76,717,80,675,42"/>
<area shape="rect" href="layout_8hpp.html" title="Utility functions for determining the layout of particle buffers on a given rank." alt="" coords="275,152,365,177"/>
<area shape="poly" title=" " alt="" coords="604,37,484,81,404,120,341,154,338,150,401,115,482,76,602,32"/>
<area shape="rect" href="domaindecomp__mpi_8hpp.html" title="Exchange particles between different ranks to satisfy their assignments of the global octree." alt="" coords="390,152,573,177"/>
<area shape="poly" title=" " alt="" coords="552,114,499,154,495,150,549,110"/>
<area shape="rect" href="exchange__halos_8hpp.html" title="Halo particle exchange with MPI point&#45;to&#45;point communication." alt="" coords="597,152,752,177"/>
<area shape="poly" title=" " alt="" coords="606,110,660,150,657,154,603,114"/>
<area shape="rect" href="assignment_8hpp.html" title="Implementation of global particle assignment and distribution." alt="" coords="438,225,565,251"/>
<area shape="poly" title=" " alt="" coords="491,190,501,224,495,226,486,191"/>
<area shape="poly" title=" " alt="" coords="464,259,366,301,364,296,461,254"/>
<area shape="rect" href="domain__minimal_8cpp.html" title=" " alt="" coords="318,372,477,397"/>
<area shape="poly" title=" " alt="" coords="359,333,390,370,386,374,355,336"/>
<area shape="rect" href="mesh_8hpp.html" title=" " alt="" coords="501,372,587,397"/>
<area shape="poly" title=" " alt="" coords="385,326,512,369,510,374,384,331"/>
<area shape="rect" href="power__spectrum_8cpp.html" title=" " alt="" coords="465,445,623,471"/>
<area shape="poly" title=" " alt="" coords="321,336,304,367,302,382,307,396,331,412,370,426,466,445,465,450,369,431,329,417,303,399,297,383,299,365,316,334"/>
<area shape="poly" title=" " alt="" coords="547,411,547,445,541,445,541,411"/>
<area shape="rect" href="halos_8hpp.html" title="Implementation of halo discovery and halo exchange." alt="" coords="589,225,675,251"/>
<area shape="poly" title=" " alt="" coords="663,191,641,227,637,224,658,188"/>
<area shape="poly" title=" " alt="" coords="576,255,387,301,385,296,575,250"/>
<area shape="rect" href="field__get_8hpp.html" title="Utility functions to use compile&#45;time strings as arguments to get on tuples." alt="" coords="915,152,1021,177"/>
<area shape="poly" title=" " alt="" coords="887,109,951,150,948,154,884,114"/>
<area shape="rect" href="ifile__io__impl_8h.html" title=" " alt="" coords="777,152,890,177"/>
<area shape="poly" title=" " alt="" coords="761,110,818,150,815,154,758,114"/>
<area shape="poly" title=" " alt="" coords="800,187,770,205,740,227,697,271,668,310,641,350,602,399,557,447,553,443,598,396,636,347,664,306,693,268,737,223,767,201,797,182"/>
<area shape="rect" href="factory_8hpp.html" title="file I/O interface" alt="" coords="1057,225,1151,251"/>
<area shape="poly" title=" " alt="" coords="890,178,1061,223,1059,228,889,183"/>
<area shape="rect" href="ifile__io__ascii_8cpp.html" title="ASCII file I/O." alt="" coords="750,225,879,251"/>
<area shape="poly" title=" " alt="" coords="829,191,820,226,815,225,824,190"/>
<area shape="rect" href="ifile__io__hdf5_8cpp.html" title="File I/O interface implementation with H5Part." alt="" coords="904,225,1032,251"/>
<area shape="poly" title=" " alt="" coords="868,181,947,223,945,227,866,186"/>
<area shape="poly" title=" " alt="" coords="363,180,473,223,471,228,361,185"/>
<area shape="poly" title=" " alt="" coords="289,187,271,200,257,216,250,232,253,250,264,265,278,277,310,296,307,301,275,282,260,268,248,252,245,232,253,213,268,196,285,183"/>
<area shape="poly" title=" " alt="" coords="379,177,590,224,588,230,378,182"/>
<area shape="rect" href="exchange__keys_8hpp.html" title="Send/receive SFC key ranges to let peer ranks know which particles to send as halos." alt="" coords="263,225,414,251"/>
<area shape="poly" title=" " alt="" coords="329,190,338,225,333,226,324,191"/>
<area shape="rect" href="octree__focus__mpi_8hpp.html" title="Traits and functors for the MPI&#45;enabled FocusedOctree." alt="" coords="23,225,188,251"/>
<area shape="poly" title=" " alt="" coords="273,184,141,228,139,223,272,179"/>
<area shape="poly" title=" " alt="" coords="341,264,341,299,336,299,336,264"/>
<area shape="poly" title=" " alt="" coords="156,252,302,296,300,301,155,257"/>
</map>
</div>
</div>
<p><a href="type__list_8hpp_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1HasValueMember.html">util::HasValueMember&lt; T, class &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1HasValueMember_3_01T_00_01void__value__t_3_01T_1_1value_01_4_01_4.html">util::HasValueMember&lt; T, void_value_t&lt; T::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1TypeList.html">util::TypeList&lt; Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for a holder of entries of different data types.  <a href="structutil_1_1TypeList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1TypeListSize.html">util::TypeListSize&lt; TypeList &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1TypeListSize_3_01TypeList_3_01Ts_8_8_8_01_4_01_4.html">util::TypeListSize&lt; TypeList&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1TypeListElement.html">util::TypeListElement&lt; I, TL &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type retrieval: base template.  <a href="structutil_1_1TypeListElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1TypeListElement_3_01I_00_01TL_3_01Head_00_01Tail_8_8_8_01_4_01_4.html">util::TypeListElement&lt; I, TL&lt; Head, Tail... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type retrieval: recursion, strip one element.  <a href="structutil_1_1TypeListElement_3_01I_00_01TL_3_01Head_00_01Tail_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1TypeListElement_3_010_00_01TL_3_01Head_00_01Tail_8_8_8_01_4_01_4.html">util::TypeListElement&lt; 0, TL&lt; Head, Tail... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type retrieval: endpoint, Head is the desired type.  <a href="structutil_1_1TypeListElement_3_010_00_01TL_3_01Head_00_01Tail_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1TypeListElement_3_01I_00_01TL_3_4_01_4.html">util::TypeListElement&lt; I, TL&lt;&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type retrieval: out of bounds detection.  <a href="structutil_1_1TypeListElement_3_01I_00_01TL_3_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1detail_1_1Map___3_01P_00_01L_3_01Ts_8_8_8_01_4_01_4.html">util::detail::Map_&lt; P, L&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="structutil_1_1detail_1_1Map__.html" title="unimplemented base template">Map_</a>.  <a href="structutil_1_1detail_1_1Map___3_01P_00_01L_3_01Ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1detail_1_1Reduce___3_01P_00_01L_3_01Ts_8_8_8_01_4_01_4.html">util::detail::Reduce_&lt; P, L&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of <a class="el" href="structutil_1_1detail_1_1Reduce__.html" title="unimplemented base template">Reduce_</a>.  <a href="structutil_1_1detail_1_1Reduce___3_01P_00_01L_3_01Ts_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1detail_1_1FuseTwo___3_01L1_3_01Ts1_8_8_8_01_4_00_01L2_3_01Ts2_8_8_8_01_4_01_4.html">util::detail::FuseTwo_&lt; L1&lt; Ts1... &gt;, L2&lt; Ts2... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">implementation of <a class="el" href="structutil_1_1detail_1_1FuseTwo__.html" title="unimplemented base template">FuseTwo_</a>  <a href="structutil_1_1detail_1_1FuseTwo___3_01L1_3_01Ts1_8_8_8_01_4_00_01L2_3_01Ts2_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1detail_1_1Fuse___3_01L_01_4.html">util::detail::Fuse_&lt; L &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursion endpoint  <a href="structutil_1_1detail_1_1Fuse___3_01L_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1detail_1_1Fuse___3_01L1_00_01L2_00_01Ls_8_8_8_01_4.html">util::detail::Fuse_&lt; L1, L2, Ls... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">recurse until only one type is left  <a href="structutil_1_1detail_1_1Fuse___3_01L1_00_01L2_00_01Ls_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1detail_1_1RepeatHelper__.html">util::detail::RepeatHelper_&lt; L, N, Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">keep adding the template parameter pack to the type list  <a href="structutil_1_1detail_1_1RepeatHelper__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1detail_1_1RepeatHelper___3_01L_00_011_00_01Ts_8_8_8_01_4.html">util::detail::RepeatHelper_&lt; L, 1, Ts... &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">stop recurision  <a href="structutil_1_1detail_1_1RepeatHelper___3_01L_00_011_00_01Ts_8_8_8_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1detail_1_1Repeat__.html">util::detail::Repeat_&lt; L, N, class &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">base case  <a href="structutil_1_1detail_1_1Repeat__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1detail_1_1Repeat___3_01L_3_01Ts_8_8_8_01_4_00_01N_00_01std_1_1enable__if__t_3_01N_01_4_0a1_01_4.html">util::detail::Repeat_&lt; L&lt; Ts... &gt;, N, std::enable_if_t&lt; N &gt;=1 &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">capture original template parameter pack, protect against N &lt; 1  <a href="structutil_1_1detail_1_1Repeat___3_01L_3_01Ts_8_8_8_01_4_00_01N_00_01std_1_1enable__if__t_3_01N_01_4_0a1_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1detail_1_1AccessTypeMemberIfPresent.html">util::detail::AccessTypeMemberIfPresent&lt; T, class &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1detail_1_1AccessTypeMemberIfPresent_3_01T_00_01typename_01std_1_1void__t_3_01typename_01T_1_1type_01_4_01_4.html">util::detail::AccessTypeMemberIfPresent&lt; T, typename std::void_t&lt; typename T::type &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1detail_1_1MatchTypeOrTypeMember.html">util::detail::MatchTypeOrTypeMember&lt; N, T, Tuple &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Comparison meta function that compares T to Tuple[N].  <a href="structutil_1_1detail_1_1MatchTypeOrTypeMember.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1detail_1_1MatchField__.html">util::detail::MatchField_&lt; N, T, Tuple, Comparison, Match &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursion to check the next field N+1.  <a href="structutil_1_1detail_1_1MatchField__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1detail_1_1MatchField___3_01N_00_01T_00_01Tuple_00_01Comparison_00_01std_1_1enable_e531ea73e8411dfcb89494e2faf8567e.html">util::detail::MatchField_&lt; N, T, Tuple, Comparison, std::enable_if_t&lt; Comparison&lt; N, T, Tuple &gt;{}&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursion stop when Comparison&lt;N, T, Tuple&gt;::value is true  <a href="structutil_1_1detail_1_1MatchField___3_01N_00_01T_00_01Tuple_00_01Comparison_00_01std_1_1enable_e531ea73e8411dfcb89494e2faf8567e.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1FindIndex.html">util::FindIndex&lt; T, TL, Comparison &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function to return the first index in Tuple whose type matches T.  <a href="structutil_1_1FindIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1FindIndex_3_01T_00_01TL_3_01Ts_8_8_8_01_4_00_01Comparison_01_4.html">util::FindIndex&lt; T, TL&lt; Ts... &gt;, Comparison &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to only enable this trait if TL has template parameters.  <a href="structutil_1_1FindIndex_3_01T_00_01TL_3_01Ts_8_8_8_01_4_00_01Comparison_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1Contains.html">util::Contains&lt; T, TL &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template meta function to determine whether T is contained in TL  <a href="structutil_1_1Contains.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceutil" id="r_namespaceutil"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html">util</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceutil_1_1detail" id="r_namespaceutil_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil_1_1detail.html">util::detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3673b879f42d462272525a91b4eec1e2" id="r_a3673b879f42d462272525a91b4eec1e2"><td class="memTemplParams" colspan="2">template&lt;auto... &gt; </td></tr>
<tr class="memitem:a3673b879f42d462272525a91b4eec1e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a3673b879f42d462272525a91b4eec1e2">util::void_value_t</a> = void</td></tr>
<tr class="separator:a3673b879f42d462272525a91b4eec1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e41c154c3642236d4daacdaf6dbcae" id="r_ae6e41c154c3642236d4daacdaf6dbcae"><td class="memTemplParams" colspan="2">template&lt;size_t I, class TL &gt; </td></tr>
<tr class="memitem:ae6e41c154c3642236d4daacdaf6dbcae"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ae6e41c154c3642236d4daacdaf6dbcae">util::TypeListElement_t</a> = typename <a class="el" href="structutil_1_1TypeListElement.html">TypeListElement</a>&lt; I, TL &gt;::type</td></tr>
<tr class="memdesc:ae6e41c154c3642236d4daacdaf6dbcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type retrieval: convenience alias.  <br /></td></tr>
<tr class="separator:ae6e41c154c3642236d4daacdaf6dbcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34673b1b19f6e066563550630e54d58f" id="r_a34673b1b19f6e066563550630e54d58f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a34673b1b19f6e066563550630e54d58f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil_1_1detail.html#a34673b1b19f6e066563550630e54d58f">util::detail::AccessTypeMemberIfPresent_t</a> = typename <a class="el" href="structutil_1_1detail_1_1AccessTypeMemberIfPresent.html">AccessTypeMemberIfPresent</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a34673b1b19f6e066563550630e54d58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e952ed78af58e7c5f52541a3507796" id="r_ab7e952ed78af58e7c5f52541a3507796"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class P, class L &gt; </td></tr>
<tr class="memitem:ab7e952ed78af58e7c5f52541a3507796"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ab7e952ed78af58e7c5f52541a3507796">util::Map</a> = typename <a class="el" href="structutil_1_1detail_1_1Map__.html">detail::Map_</a>&lt; P, L &gt;::type</td></tr>
<tr class="memdesc:ab7e952ed78af58e7c5f52541a3507796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structutil_1_1TypeList.html" title="Base template for a holder of entries of different data types.">TypeList</a> of P instantiated with each template parameter of L.  <br /></td></tr>
<tr class="separator:ab7e952ed78af58e7c5f52541a3507796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa593a6a61a4fc92b882d2ea7cc719e73" id="r_aa593a6a61a4fc92b882d2ea7cc719e73"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class P, class L &gt; </td></tr>
<tr class="memitem:aa593a6a61a4fc92b882d2ea7cc719e73"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#aa593a6a61a4fc92b882d2ea7cc719e73">util::Reduce</a> = typename <a class="el" href="structutil_1_1detail_1_1Reduce__.html">detail::Reduce_</a>&lt; P, L &gt;::type</td></tr>
<tr class="memdesc:aa593a6a61a4fc92b882d2ea7cc719e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for expressing a datatype P templated with all the entries in type list L.  <br /></td></tr>
<tr class="separator:aa593a6a61a4fc92b882d2ea7cc719e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eee3b46dc529ae57d7783254a2302f3" id="r_a0eee3b46dc529ae57d7783254a2302f3"><td class="memTemplParams" colspan="2">template&lt;class... Ls&gt; </td></tr>
<tr class="memitem:a0eee3b46dc529ae57d7783254a2302f3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a0eee3b46dc529ae57d7783254a2302f3">util::FuseTwo</a> = typename <a class="el" href="structutil_1_1detail_1_1FuseTwo__.html">detail::FuseTwo_</a>&lt; Ls... &gt;::type</td></tr>
<tr class="memdesc:a0eee3b46dc529ae57d7783254a2302f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates template parameters of two variadic templates into a <a class="el" href="structutil_1_1TypeList.html" title="Base template for a holder of entries of different data types.">TypeList</a>.  <br /></td></tr>
<tr class="separator:a0eee3b46dc529ae57d7783254a2302f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260347f146e2617fb25359f2c962d2d2" id="r_a260347f146e2617fb25359f2c962d2d2"><td class="memTemplParams" colspan="2">template&lt;class... Ls&gt; </td></tr>
<tr class="memitem:a260347f146e2617fb25359f2c962d2d2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a260347f146e2617fb25359f2c962d2d2">util::Fuse</a> = typename <a class="el" href="structutil_1_1detail_1_1Fuse__.html">detail::Fuse_</a>&lt; Ls... &gt;::type</td></tr>
<tr class="memdesc:a260347f146e2617fb25359f2c962d2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This traits concatenates an arbitrary number of variadic templates into a single <a class="el" href="structutil_1_1TypeList.html" title="Base template for a holder of entries of different data types.">TypeList</a>.  <br /></td></tr>
<tr class="separator:a260347f146e2617fb25359f2c962d2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918e3449905cfdb305cd08daff75ea7d" id="r_a918e3449905cfdb305cd08daff75ea7d"><td class="memTemplParams" colspan="2">template&lt;class L , int N&gt; </td></tr>
<tr class="memitem:a918e3449905cfdb305cd08daff75ea7d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a918e3449905cfdb305cd08daff75ea7d">util::Repeat</a> = typename <a class="el" href="structutil_1_1detail_1_1Repeat__.html">detail::Repeat_</a>&lt; L, N &gt;::type</td></tr>
<tr class="memdesc:a918e3449905cfdb305cd08daff75ea7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat the template parameters of L N times.  <br /></td></tr>
<tr class="separator:a918e3449905cfdb305cd08daff75ea7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7b32b539ae6294b7e1d47c3d4d13ab23" id="r_a7b32b539ae6294b7e1d47c3d4d13ab23"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tuple &gt; </td></tr>
<tr class="memitem:a7b32b539ae6294b7e1d47c3d4d13ab23"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a7b32b539ae6294b7e1d47c3d4d13ab23">util::pickType</a> (Tuple &amp;tup)</td></tr>
<tr class="memdesc:a7b32b539ae6294b7e1d47c3d4d13ab23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function to return the element in Tuple whose type matches T.  <br /></td></tr>
<tr class="separator:a7b32b539ae6294b7e1d47c3d4d13ab23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implements general purpose TypeList and tuple utility traits</p>
<dl class="section author"><dt>Author</dt><dd>Sebastian Keller <a href="#" onclick="location.href='mai'+'lto:'+'seb'+'as'+'tia'+'n.'+'f.k'+'el'+'ler'+'@g'+'mai'+'l.'+'com'; return false;">sebas<span class="obfuscator">.nosp@m.</span>tian<span class="obfuscator">.nosp@m.</span>.f.ke<span class="obfuscator">.nosp@m.</span>ller<span class="obfuscator">.nosp@m.</span>@gmai<span class="obfuscator">.nosp@m.</span>l.co<span class="obfuscator">.nosp@m.</span>m</a> </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_11d14776504e0a846602c2c422cc3332.html">cstone</a></li><li class="navelem"><a class="el" href="dir_53f7f6b0a50e8f1ad5b9506f35c44008.html">include</a></li><li class="navelem"><a class="el" href="dir_e32ab675bfd7286b147ad98a8674a0a5.html">cstone</a></li><li class="navelem"><a class="el" href="dir_c5a9e8618339ffdc888cbb68089e6466.html">util</a></li><li class="navelem"><a class="el" href="type__list_8hpp.html">type_list.hpp</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
