<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>rasterizationAndFFT + Cornerstone API: util Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">rasterizationAndFFT + Cornerstone API
   </div>
   <div id="projectbrief">Distributed octree domain, rasterization, and FFT utilities</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('namespaceutil.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">util Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceutil_1_1detail" id="r_namespaceutil_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceutil_1_1vl__detail" id="r_namespaceutil_1_1vl__detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil_1_1vl__detail.html">vl_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1AlignedAllocator.html">AlignedAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1array.html">array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">std::array-like compile-time size array  <a href="structutil_1_1array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1Contains.html">Contains</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template meta function to determine whether T is contained in TL  <a href="structutil_1_1Contains.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1DefaultInitAdaptor.html">DefaultInitAdaptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocator adaptor to prevent value initialization from happening.  <a href="classutil_1_1DefaultInitAdaptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1FieldList.html">FieldList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1FieldListSize.html">FieldListSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1FieldListSize_3_01FieldList_3_01Vs_8_8_8_01_4_01_4.html">FieldListSize&lt; FieldList&lt; Vs... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1FindIndex.html">FindIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function to return the first index in Tuple whose type matches T.  <a href="structutil_1_1FindIndex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1FindIndex_3_01T_00_01TL_3_01Ts_8_8_8_01_4_00_01Comparison_01_4.html">FindIndex&lt; T, TL&lt; Ts... &gt;, Comparison &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization to only enable this trait if TL has template parameters.  <a href="structutil_1_1FindIndex_3_01T_00_01TL_3_01Ts_8_8_8_01_4_00_01Comparison_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1HasValueMember.html">HasValueMember</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1HasValueMember_3_01T_00_01void__value__t_3_01T_1_1value_01_4_01_4.html">HasValueMember&lt; T, void_value_t&lt; T::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1MakeFieldList.html">MakeFieldList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="structutil_1_1FieldList.html">FieldList</a> type from any type with a constexpr array&lt;N, const char*&gt; fieldNames member.  <a href="structutil_1_1MakeFieldList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1StructuralString.html">StructuralString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">constexpr string as structural type for use as non-type template parameter (C++20)  <a href="structutil_1_1StructuralString.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1TuplePlus.html">TuplePlus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">generic tuple addition functor that works for both thrust and std tuples  <a href="structutil_1_1TuplePlus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1TuplePlusImpl.html">TuplePlusImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1TypeList.html">TypeList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for a holder of entries of different data types.  <a href="structutil_1_1TypeList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1TypeListElement.html">TypeListElement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type retrieval: base template.  <a href="structutil_1_1TypeListElement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1TypeListElement_3_010_00_01TL_3_01Head_00_01Tail_8_8_8_01_4_01_4.html">TypeListElement&lt; 0, TL&lt; Head, Tail... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type retrieval: endpoint, Head is the desired type.  <a href="structutil_1_1TypeListElement_3_010_00_01TL_3_01Head_00_01Tail_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1TypeListElement_3_01I_00_01TL_3_01Head_00_01Tail_8_8_8_01_4_01_4.html">TypeListElement&lt; I, TL&lt; Head, Tail... &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type retrieval: recursion, strip one element.  <a href="structutil_1_1TypeListElement_3_01I_00_01TL_3_01Head_00_01Tail_8_8_8_01_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1TypeListElement_3_01I_00_01TL_3_4_01_4.html">TypeListElement&lt; I, TL&lt;&gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type retrieval: out of bounds detection.  <a href="structutil_1_1TypeListElement_3_01I_00_01TL_3_4_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1TypeListSize.html">TypeListSize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structutil_1_1TypeListSize_3_01TypeList_3_01Ts_8_8_8_01_4_01_4.html">TypeListSize&lt; TypeList&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a14a8bcf81422d42715866547b59565cf" id="r_a14a8bcf81422d42715866547b59565cf"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a14a8bcf81422d42715866547b59565cf"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">tuple</a> = std::tuple&lt; Ts... &gt;</td></tr>
<tr class="separator:a14a8bcf81422d42715866547b59565cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3dc849812f624c673b62f04fcaa002" id="r_a5e3dc849812f624c673b62f04fcaa002"><td class="memTemplParams" colspan="2">template&lt;std::size_t N&gt; </td></tr>
<tr class="memitem:a5e3dc849812f624c673b62f04fcaa002"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a5e3dc849812f624c673b62f04fcaa002">makeIndexSequenceReverse</a> = decltype(<a class="el" href="namespaceutil.html#a8b4c3755082fb42208664b0fef271c27">indexSequenceReverse</a>(std::make_index_sequence&lt; N &gt;{}))</td></tr>
<tr class="separator:a5e3dc849812f624c673b62f04fcaa002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3673b879f42d462272525a91b4eec1e2" id="r_a3673b879f42d462272525a91b4eec1e2"><td class="memTemplParams" colspan="2">template&lt;auto... &gt; </td></tr>
<tr class="memitem:a3673b879f42d462272525a91b4eec1e2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a3673b879f42d462272525a91b4eec1e2">void_value_t</a> = void</td></tr>
<tr class="separator:a3673b879f42d462272525a91b4eec1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6e41c154c3642236d4daacdaf6dbcae" id="r_ae6e41c154c3642236d4daacdaf6dbcae"><td class="memTemplParams" colspan="2">template&lt;size_t I, class TL &gt; </td></tr>
<tr class="memitem:ae6e41c154c3642236d4daacdaf6dbcae"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ae6e41c154c3642236d4daacdaf6dbcae">TypeListElement_t</a> = typename <a class="el" href="structutil_1_1TypeListElement.html">TypeListElement</a>&lt; I, TL &gt;::type</td></tr>
<tr class="memdesc:ae6e41c154c3642236d4daacdaf6dbcae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Element type retrieval: convenience alias.  <br /></td></tr>
<tr class="separator:ae6e41c154c3642236d4daacdaf6dbcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e952ed78af58e7c5f52541a3507796" id="r_ab7e952ed78af58e7c5f52541a3507796"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class P, class L &gt; </td></tr>
<tr class="memitem:ab7e952ed78af58e7c5f52541a3507796"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ab7e952ed78af58e7c5f52541a3507796">Map</a> = typename <a class="el" href="structutil_1_1detail_1_1Map__.html">detail::Map_</a>&lt; P, L &gt;::type</td></tr>
<tr class="memdesc:ab7e952ed78af58e7c5f52541a3507796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structutil_1_1TypeList.html" title="Base template for a holder of entries of different data types.">TypeList</a> of P instantiated with each template parameter of L.  <br /></td></tr>
<tr class="separator:ab7e952ed78af58e7c5f52541a3507796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa593a6a61a4fc92b882d2ea7cc719e73" id="r_aa593a6a61a4fc92b882d2ea7cc719e73"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class P, class L &gt; </td></tr>
<tr class="memitem:aa593a6a61a4fc92b882d2ea7cc719e73"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#aa593a6a61a4fc92b882d2ea7cc719e73">Reduce</a> = typename <a class="el" href="structutil_1_1detail_1_1Reduce__.html">detail::Reduce_</a>&lt; P, L &gt;::type</td></tr>
<tr class="memdesc:aa593a6a61a4fc92b882d2ea7cc719e73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base template for expressing a datatype P templated with all the entries in type list L.  <br /></td></tr>
<tr class="separator:aa593a6a61a4fc92b882d2ea7cc719e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eee3b46dc529ae57d7783254a2302f3" id="r_a0eee3b46dc529ae57d7783254a2302f3"><td class="memTemplParams" colspan="2">template&lt;class... Ls&gt; </td></tr>
<tr class="memitem:a0eee3b46dc529ae57d7783254a2302f3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a0eee3b46dc529ae57d7783254a2302f3">FuseTwo</a> = typename <a class="el" href="structutil_1_1detail_1_1FuseTwo__.html">detail::FuseTwo_</a>&lt; Ls... &gt;::type</td></tr>
<tr class="memdesc:a0eee3b46dc529ae57d7783254a2302f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates template parameters of two variadic templates into a <a class="el" href="structutil_1_1TypeList.html" title="Base template for a holder of entries of different data types.">TypeList</a>.  <br /></td></tr>
<tr class="separator:a0eee3b46dc529ae57d7783254a2302f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260347f146e2617fb25359f2c962d2d2" id="r_a260347f146e2617fb25359f2c962d2d2"><td class="memTemplParams" colspan="2">template&lt;class... Ls&gt; </td></tr>
<tr class="memitem:a260347f146e2617fb25359f2c962d2d2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a260347f146e2617fb25359f2c962d2d2">Fuse</a> = typename <a class="el" href="structutil_1_1detail_1_1Fuse__.html">detail::Fuse_</a>&lt; Ls... &gt;::type</td></tr>
<tr class="memdesc:a260347f146e2617fb25359f2c962d2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This traits concatenates an arbitrary number of variadic templates into a single <a class="el" href="structutil_1_1TypeList.html" title="Base template for a holder of entries of different data types.">TypeList</a>.  <br /></td></tr>
<tr class="separator:a260347f146e2617fb25359f2c962d2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a918e3449905cfdb305cd08daff75ea7d" id="r_a918e3449905cfdb305cd08daff75ea7d"><td class="memTemplParams" colspan="2">template&lt;class L , int N&gt; </td></tr>
<tr class="memitem:a918e3449905cfdb305cd08daff75ea7d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a918e3449905cfdb305cd08daff75ea7d">Repeat</a> = typename <a class="el" href="structutil_1_1detail_1_1Repeat__.html">detail::Repeat_</a>&lt; L, N &gt;::type</td></tr>
<tr class="memdesc:a918e3449905cfdb305cd08daff75ea7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat the template parameters of L N times.  <br /></td></tr>
<tr class="separator:a918e3449905cfdb305cd08daff75ea7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac7e329172dd75f88369a6433cf4a5d3a" id="r_ac7e329172dd75f88369a6433cf4a5d3a"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structutil_1_1StructuralString.html">StructuralString</a> Prefix, size_t N&gt; </td></tr>
<tr class="memitem:ac7e329172dd75f88369a6433cf4a5d3a"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::array&lt; const char *, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ac7e329172dd75f88369a6433cf4a5d3a">enumerateFieldNames</a> ()</td></tr>
<tr class="memdesc:ac7e329172dd75f88369a6433cf4a5d3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a sequence "0", "1", ..., "N-1" of compile-time strings each.  <br /></td></tr>
<tr class="separator:ac7e329172dd75f88369a6433cf4a5d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa767c1e539b3cacedc822a2bdc13caeb" id="r_aa767c1e539b3cacedc822a2bdc13caeb"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa767c1e539b3cacedc822a2bdc13caeb"><td class="memTemplItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#aa767c1e539b3cacedc822a2bdc13caeb">determineAlignment</a> (int n)</td></tr>
<tr class="separator:aa767c1e539b3cacedc822a2bdc13caeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e884d9a8bd1a660309343808ffe087" id="r_ae1e884d9a8bd1a660309343808ffe087"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class T , std::size_t N&gt; </td></tr>
<tr class="memitem:ae1e884d9a8bd1a660309343808ffe087"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ae1e884d9a8bd1a660309343808ffe087">get</a> (<a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;a_)</td></tr>
<tr class="separator:ae1e884d9a8bd1a660309343808ffe087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe16a8435fe2a8700935975651d3cad" id="r_a1fe16a8435fe2a8700935975651d3cad"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a1fe16a8435fe2a8700935975651d3cad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a1fe16a8435fe2a8700935975651d3cad">get</a> (const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;a_)</td></tr>
<tr class="separator:a1fe16a8435fe2a8700935975651d3cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da974871b8cccc6c5dca07f97e4d4a4" id="r_a5da974871b8cccc6c5dca07f97e4d4a4"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a5da974871b8cccc6c5dca07f97e4d4a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a5da974871b8cccc6c5dca07f97e4d4a4">get</a> (<a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&amp;a_)</td></tr>
<tr class="separator:a5da974871b8cccc6c5dca07f97e4d4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd750f1278376f75f3b3249ddfa57073" id="r_abd750f1278376f75f3b3249ddfa57073"><td class="memTemplParams" colspan="2">template&lt;std::size_t I, class T , std::size_t N&gt; </td></tr>
<tr class="memitem:abd750f1278376f75f3b3249ddfa57073"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr const T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#abd750f1278376f75f3b3249ddfa57073">get</a> (const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&amp;a_)</td></tr>
<tr class="separator:abd750f1278376f75f3b3249ddfa57073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89e53ec9d38b695a93b1127cb3094c87" id="r_a89e53ec9d38b695a93b1127cb3094c87"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a89e53ec9d38b695a93b1127cb3094c87"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a89e53ec9d38b695a93b1127cb3094c87">operator+</a> (const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;a, const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;b)</td></tr>
<tr class="separator:a89e53ec9d38b695a93b1127cb3094c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3067923b82e90a736814f7b7a84fcdaf" id="r_a3067923b82e90a736814f7b7a84fcdaf"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a3067923b82e90a736814f7b7a84fcdaf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a3067923b82e90a736814f7b7a84fcdaf">operator-</a> (const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="separator:a3067923b82e90a736814f7b7a84fcdaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3161642b9ee4b663c1dbfea8a1b3314b" id="r_a3161642b9ee4b663c1dbfea8a1b3314b"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a3161642b9ee4b663c1dbfea8a1b3314b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a3161642b9ee4b663c1dbfea8a1b3314b">operator-</a> (const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;a, const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;b)</td></tr>
<tr class="separator:a3161642b9ee4b663c1dbfea8a1b3314b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacfd381c2432d4691f11ae3f19f92dd6" id="r_aacfd381c2432d4691f11ae3f19f92dd6"><td class="memTemplParams" colspan="2">template&lt;class S , class T , std::size_t N&gt; </td></tr>
<tr class="memitem:aacfd381c2432d4691f11ae3f19f92dd6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#aacfd381c2432d4691f11ae3f19f92dd6">operator*</a> (const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;a, const S &amp;b)</td></tr>
<tr class="separator:aacfd381c2432d4691f11ae3f19f92dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fb526cff8cfbc50e74dbf36ca97dc5" id="r_a44fb526cff8cfbc50e74dbf36ca97dc5"><td class="memTemplParams" colspan="2">template&lt;class S , class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a44fb526cff8cfbc50e74dbf36ca97dc5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a44fb526cff8cfbc50e74dbf36ca97dc5">operator*</a> (const S &amp;a, const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;b)</td></tr>
<tr class="separator:a44fb526cff8cfbc50e74dbf36ca97dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a70645d4e7bcb0892d4afbc145af12" id="r_a03a70645d4e7bcb0892d4afbc145af12"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a03a70645d4e7bcb0892d4afbc145af12"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a03a70645d4e7bcb0892d4afbc145af12">operator==</a> (const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;a, const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;b)</td></tr>
<tr class="separator:a03a70645d4e7bcb0892d4afbc145af12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa79fee5ea8278f35906412fd8bcf31a" id="r_afa79fee5ea8278f35906412fd8bcf31a"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:afa79fee5ea8278f35906412fd8bcf31a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#afa79fee5ea8278f35906412fd8bcf31a">operator!=</a> (const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;a, const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;b)</td></tr>
<tr class="separator:afa79fee5ea8278f35906412fd8bcf31a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511901687edc82df3fc37ea7190ac9c0" id="r_a511901687edc82df3fc37ea7190ac9c0"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a511901687edc82df3fc37ea7190ac9c0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a511901687edc82df3fc37ea7190ac9c0">operator&lt;</a> (const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;a, const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;b)</td></tr>
<tr class="separator:a511901687edc82df3fc37ea7190ac9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41130aec2552cf410b6bac94e2ba6a4c" id="r_a41130aec2552cf410b6bac94e2ba6a4c"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a41130aec2552cf410b6bac94e2ba6a4c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a41130aec2552cf410b6bac94e2ba6a4c">operator&gt;</a> (const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;a, const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;b)</td></tr>
<tr class="separator:a41130aec2552cf410b6bac94e2ba6a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0483a1eef1c26d6843fb9d2f8d711ed4" id="r_a0483a1eef1c26d6843fb9d2f8d711ed4"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a0483a1eef1c26d6843fb9d2f8d711ed4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a0483a1eef1c26d6843fb9d2f8d711ed4">dot</a> (const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;a, const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;b)</td></tr>
<tr class="separator:a0483a1eef1c26d6843fb9d2f8d711ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bed9b96ba44afef5bd382bac7eccef6" id="r_a7bed9b96ba44afef5bd382bac7eccef6"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a7bed9b96ba44afef5bd382bac7eccef6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a7bed9b96ba44afef5bd382bac7eccef6">norm2</a> (const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="separator:a7bed9b96ba44afef5bd382bac7eccef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5a5420dd4b951e29677e638d726cbb" id="r_abd5a5420dd4b951e29677e638d726cbb"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:abd5a5420dd4b951e29677e638d726cbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#abd5a5420dd4b951e29677e638d726cbb">abs</a> (const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="separator:abd5a5420dd4b951e29677e638d726cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739fc2fcd66fe500c4110a7fb3ed0678" id="r_a739fc2fcd66fe500c4110a7fb3ed0678"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a739fc2fcd66fe500c4110a7fb3ed0678"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a739fc2fcd66fe500c4110a7fb3ed0678">min</a> (const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;a, const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;b)</td></tr>
<tr class="memdesc:a739fc2fcd66fe500c4110a7fb3ed0678"><td class="mdescLeft">&#160;</td><td class="mdescRight">element-wise min between two arrays  <br /></td></tr>
<tr class="separator:a739fc2fcd66fe500c4110a7fb3ed0678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f32d54a6e6dce3da56300c9cc05855" id="r_a40f32d54a6e6dce3da56300c9cc05855"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a40f32d54a6e6dce3da56300c9cc05855"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a40f32d54a6e6dce3da56300c9cc05855">max</a> (const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;a, const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;b)</td></tr>
<tr class="memdesc:a40f32d54a6e6dce3da56300c9cc05855"><td class="mdescLeft">&#160;</td><td class="mdescRight">element-wise max between two arrays  <br /></td></tr>
<tr class="separator:a40f32d54a6e6dce3da56300c9cc05855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460513aaaeb888c058e37e543880ec20" id="r_a460513aaaeb888c058e37e543880ec20"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a460513aaaeb888c058e37e543880ec20"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a460513aaaeb888c058e37e543880ec20">min</a> (const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:a460513aaaeb888c058e37e543880ec20"><td class="mdescLeft">&#160;</td><td class="mdescRight">min reduction of a single array  <br /></td></tr>
<tr class="separator:a460513aaaeb888c058e37e543880ec20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1befcf6c26d4bab8b67cb035206aa392" id="r_a1befcf6c26d4bab8b67cb035206aa392"><td class="memTemplParams" colspan="2">template&lt;class T , std::size_t N&gt; </td></tr>
<tr class="memitem:a1befcf6c26d4bab8b67cb035206aa392"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a1befcf6c26d4bab8b67cb035206aa392">max</a> (const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:a1befcf6c26d4bab8b67cb035206aa392"><td class="mdescLeft">&#160;</td><td class="mdescRight">max reduction of a single array  <br /></td></tr>
<tr class="separator:a1befcf6c26d4bab8b67cb035206aa392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620a1fd21759e40ab162a13770b9cd2a" id="r_a620a1fd21759e40ab162a13770b9cd2a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a620a1fd21759e40ab162a13770b9cd2a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="structutil_1_1array.html">array</a>&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a620a1fd21759e40ab162a13770b9cd2a">cross</a> (const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, 3 &gt; &amp;a, const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, 3 &gt; &amp;b)</td></tr>
<tr class="separator:a620a1fd21759e40ab162a13770b9cd2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23adedd716e1ecb76de96315428429ea" id="r_a23adedd716e1ecb76de96315428429ea"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a23adedd716e1ecb76de96315428429ea"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="structutil_1_1array.html">array</a>&lt; T, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a23adedd716e1ecb76de96315428429ea">makeVec3</a> (<a class="el" href="structutil_1_1array.html">array</a>&lt; T, 4 &gt; v)</td></tr>
<tr class="separator:a23adedd716e1ecb76de96315428429ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f59f5097a51d23c006cfdaa19abb07" id="r_a59f59f5097a51d23c006cfdaa19abb07"><td class="memTemplParams" colspan="2">template&lt;size_t N1, size_t N2&gt; </td></tr>
<tr class="memitem:a59f59f5097a51d23c006cfdaa19abb07"><td class="memTemplItemLeft" align="right" valign="top">constexpr bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a59f59f5097a51d23c006cfdaa19abb07">operator==</a> (const <a class="el" href="structutil_1_1StructuralString.html">StructuralString</a>&lt; N1 &gt; &amp;a, const <a class="el" href="structutil_1_1StructuralString.html">StructuralString</a>&lt; N2 &gt; &amp;b)</td></tr>
<tr class="separator:a59f59f5097a51d23c006cfdaa19abb07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac711c32ba6b704e0e7bbd9a53a58ea1f" id="r_ac711c32ba6b704e0e7bbd9a53a58ea1f"><td class="memTemplParams" colspan="2">template&lt;size_t N1, size_t N2&gt; </td></tr>
<tr class="memitem:ac711c32ba6b704e0e7bbd9a53a58ea1f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structutil_1_1StructuralString.html">StructuralString</a>&lt; N1+N2 - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ac711c32ba6b704e0e7bbd9a53a58ea1f">operator+</a> (const <a class="el" href="structutil_1_1StructuralString.html">StructuralString</a>&lt; N1 &gt; &amp;a, const <a class="el" href="structutil_1_1StructuralString.html">StructuralString</a>&lt; N2 &gt; &amp;b)</td></tr>
<tr class="separator:ac711c32ba6b704e0e7bbd9a53a58ea1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c5c2fef1e68f7f98d385ade63b4eed" id="r_aa2c5c2fef1e68f7f98d385ade63b4eed"><td class="memTemplParams" colspan="2">template&lt;StructuralString... F1, StructuralString... F2&gt; </td></tr>
<tr class="memitem:aa2c5c2fef1e68f7f98d385ade63b4eed"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#aa2c5c2fef1e68f7f98d385ade63b4eed">operator+</a> (<a class="el" href="structutil_1_1FieldList.html">FieldList</a>&lt; F1... &gt;, <a class="el" href="structutil_1_1FieldList.html">FieldList</a>&lt; F2... &gt;)</td></tr>
<tr class="separator:aa2c5c2fef1e68f7f98d385ade63b4eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7348551de5d9c6a02c3cfc810683f0" id="r_aca7348551de5d9c6a02c3cfc810683f0"><td class="memTemplParams" colspan="2">template&lt;StructuralString... Fields&gt; </td></tr>
<tr class="memitem:aca7348551de5d9c6a02c3cfc810683f0"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#aca7348551de5d9c6a02c3cfc810683f0">make_tuple</a> (<a class="el" href="structutil_1_1FieldList.html">FieldList</a>&lt; Fields... &gt;)</td></tr>
<tr class="separator:aca7348551de5d9c6a02c3cfc810683f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3473f842c64f19fca1c8501c0daf477" id="r_ac3473f842c64f19fca1c8501c0daf477"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, class T &gt; </td></tr>
<tr class="memitem:ac3473f842c64f19fca1c8501c0daf477"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ac3473f842c64f19fca1c8501c0daf477">get</a> (T &amp;&amp;tup) noexcept</td></tr>
<tr class="separator:ac3473f842c64f19fca1c8501c0daf477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b6fe98113e3b7fa9b07113a69a0d1a" id="r_a67b6fe98113e3b7fa9b07113a69a0d1a"><td class="memTemplParams" colspan="2">template&lt;class... Ts&gt; </td></tr>
<tr class="memitem:a67b6fe98113e3b7fa9b07113a69a0d1a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">tuple</a>&lt; Ts &amp;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a67b6fe98113e3b7fa9b07113a69a0d1a">tie</a> (Ts &amp;... args) noexcept</td></tr>
<tr class="separator:a67b6fe98113e3b7fa9b07113a69a0d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6de727ec09c883fa51ed0e2c66beb7b" id="r_aa6de727ec09c883fa51ed0e2c66beb7b"><td class="memTemplParams" colspan="2">template&lt;class F , class Tuple &gt; </td></tr>
<tr class="memitem:aa6de727ec09c883fa51ed0e2c66beb7b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#aa6de727ec09c883fa51ed0e2c66beb7b">for_each_tuple</a> (F &amp;&amp;func, Tuple &amp;&amp;tuple_)</td></tr>
<tr class="memdesc:aa6de727ec09c883fa51ed0e2c66beb7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to call function with each element in tuple_.  <br /></td></tr>
<tr class="separator:aa6de727ec09c883fa51ed0e2c66beb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ac66ddf87f64e04671db2841676f2b" id="r_a74ac66ddf87f64e04671db2841676f2b"><td class="memTemplParams" colspan="2">template&lt;size_t... Is&gt; </td></tr>
<tr class="memitem:a74ac66ddf87f64e04671db2841676f2b"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a74ac66ddf87f64e04671db2841676f2b">makeIntegralTuple</a> (std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:a74ac66ddf87f64e04671db2841676f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert an index_sequence into a tuple of integral constants (e.g. for use with for_each_tuple)  <br /></td></tr>
<tr class="separator:a74ac66ddf87f64e04671db2841676f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a013aa68e8cfbb0345643e3e5d27122de" id="r_a013aa68e8cfbb0345643e3e5d27122de"><td class="memTemplParams" colspan="2">template&lt;class Tuple , size_t... Is&gt; </td></tr>
<tr class="memitem:a013aa68e8cfbb0345643e3e5d27122de"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a013aa68e8cfbb0345643e3e5d27122de">discardLastImpl</a> (const Tuple &amp;<a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">tuple</a>, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="separator:a013aa68e8cfbb0345643e3e5d27122de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a734b142100b0f1a68e21fb3ec742dd" id="r_a0a734b142100b0f1a68e21fb3ec742dd"><td class="memTemplParams" colspan="2">template&lt;class Tuple &gt; </td></tr>
<tr class="memitem:a0a734b142100b0f1a68e21fb3ec742dd"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a0a734b142100b0f1a68e21fb3ec742dd">discardLastElement</a> (const Tuple &amp;<a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">tuple</a>)</td></tr>
<tr class="separator:a0a734b142100b0f1a68e21fb3ec742dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd880dcecec32bde6fed2b259b7a6d5c" id="r_acd880dcecec32bde6fed2b259b7a6d5c"><td class="memTemplParams" colspan="2">template&lt;class Tuple , std::size_t... Ints&gt; </td></tr>
<tr class="memitem:acd880dcecec32bde6fed2b259b7a6d5c"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; std::tuple_element_t&lt; Ints, std::decay_t&lt; Tuple &gt; &gt;... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#acd880dcecec32bde6fed2b259b7a6d5c">selectTuple</a> (Tuple &amp;&amp;<a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">tuple</a>, std::index_sequence&lt; Ints... &gt;)</td></tr>
<tr class="separator:acd880dcecec32bde6fed2b259b7a6d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4c3755082fb42208664b0fef271c27" id="r_a8b4c3755082fb42208664b0fef271c27"><td class="memTemplParams" colspan="2">template&lt;std::size_t... Is&gt; </td></tr>
<tr class="memitem:a8b4c3755082fb42208664b0fef271c27"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a8b4c3755082fb42208664b0fef271c27">indexSequenceReverse</a> (std::index_sequence&lt; Is... &gt; const &amp;) -&gt; decltype(std::index_sequence&lt; sizeof...(Is) - 1U - Is... &gt;{})</td></tr>
<tr class="separator:a8b4c3755082fb42208664b0fef271c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc601fd454823cc351f5dbfd6c6d8c88" id="r_afc601fd454823cc351f5dbfd6c6d8c88"><td class="memTemplParams" colspan="2">template&lt;class Tuple &gt; </td></tr>
<tr class="memitem:afc601fd454823cc351f5dbfd6c6d8c88"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#afc601fd454823cc351f5dbfd6c6d8c88">reverse</a> (Tuple &amp;&amp;<a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">tuple</a>)</td></tr>
<tr class="separator:afc601fd454823cc351f5dbfd6c6d8c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b32b539ae6294b7e1d47c3d4d13ab23" id="r_a7b32b539ae6294b7e1d47c3d4d13ab23"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Tuple &gt; </td></tr>
<tr class="memitem:a7b32b539ae6294b7e1d47c3d4d13ab23"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a7b32b539ae6294b7e1d47c3d4d13ab23">pickType</a> (Tuple &amp;tup)</td></tr>
<tr class="memdesc:a7b32b539ae6294b7e1d47c3d4d13ab23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Meta function to return the element in Tuple whose type matches T.  <br /></td></tr>
<tr class="separator:a7b32b539ae6294b7e1d47c3d4d13ab23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ad7309e712d76b3ab13632c3efa59d" id="r_ad5ad7309e712d76b3ab13632c3efa59d"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="structutil_1_1StructuralString.html">StructuralString</a> F, class FieldNames , class Tuple &gt; </td></tr>
<tr class="memitem:ad5ad7309e712d76b3ab13632c3efa59d"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ad5ad7309e712d76b3ab13632c3efa59d">get</a> (Tuple &amp;&amp;<a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">tuple</a>)</td></tr>
<tr class="memdesc:ad5ad7309e712d76b3ab13632c3efa59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access a field of a tuple with named fields.  <br /></td></tr>
<tr class="separator:ad5ad7309e712d76b3ab13632c3efa59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a260347f146e2617fb25359f2c962d2d2" name="a260347f146e2617fb25359f2c962d2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260347f146e2617fb25359f2c962d2d2">&#9670;&#160;</a></span>Fuse</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ls&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceutil.html#a260347f146e2617fb25359f2c962d2d2">util::Fuse</a> = typedef typename <a class="el" href="structutil_1_1detail_1_1Fuse__.html">detail::Fuse_</a>&lt;Ls...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This traits concatenates an arbitrary number of variadic templates into a single <a class="el" href="structutil_1_1TypeList.html" title="Base template for a holder of entries of different data types.">TypeList</a>. </p>
<p>For clarity reasons, the fuse operation to fuse two lists into one has been decoupled into a separate trait from the handling of the recursion over the variadic arguments. </p>

</div>
</div>
<a id="a0eee3b46dc529ae57d7783254a2302f3" name="a0eee3b46dc529ae57d7783254a2302f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eee3b46dc529ae57d7783254a2302f3">&#9670;&#160;</a></span>FuseTwo</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ls&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceutil.html#a0eee3b46dc529ae57d7783254a2302f3">util::FuseTwo</a> = typedef typename <a class="el" href="structutil_1_1detail_1_1FuseTwo__.html">detail::FuseTwo_</a>&lt;Ls...&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates template parameters of two variadic templates into a <a class="el" href="structutil_1_1TypeList.html" title="Base template for a holder of entries of different data types.">TypeList</a>. </p>

</div>
</div>
<a id="a5e3dc849812f624c673b62f04fcaa002" name="a5e3dc849812f624c673b62f04fcaa002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3dc849812f624c673b62f04fcaa002">&#9670;&#160;</a></span>makeIndexSequenceReverse</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceutil.html#a5e3dc849812f624c673b62f04fcaa002">util::makeIndexSequenceReverse</a> = typedef decltype(<a class="el" href="namespaceutil.html#a8b4c3755082fb42208664b0fef271c27">indexSequenceReverse</a>(std::make_index_sequence&lt;N&gt;{}))</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7e952ed78af58e7c5f52541a3507796" name="ab7e952ed78af58e7c5f52541a3507796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e952ed78af58e7c5f52541a3507796">&#9670;&#160;</a></span>Map</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class... &gt; class P, class L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceutil.html#ab7e952ed78af58e7c5f52541a3507796">util::Map</a> = typedef typename <a class="el" href="structutil_1_1detail_1_1Map__.html">detail::Map_</a>&lt;P, L&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="structutil_1_1TypeList.html" title="Base template for a holder of entries of different data types.">TypeList</a> of P instantiated with each template parameter of L. </p>
<p>returns <a class="el" href="structutil_1_1TypeList.html" title="Base template for a holder of entries of different data types.">TypeList</a>&lt;P&lt;Ts&gt;...&gt;, with Ts... = template parameters of L does not compile if L has no template parameters </p>

</div>
</div>
<a id="aa593a6a61a4fc92b882d2ea7cc719e73" name="aa593a6a61a4fc92b882d2ea7cc719e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa593a6a61a4fc92b882d2ea7cc719e73">&#9670;&#160;</a></span>Reduce</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class... &gt; class P, class L &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceutil.html#aa593a6a61a4fc92b882d2ea7cc719e73">util::Reduce</a> = typedef typename <a class="el" href="structutil_1_1detail_1_1Reduce__.html">detail::Reduce_</a>&lt;P, L&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Base template for expressing a datatype P templated with all the entries in type list L. </p>
<p>The result is P instantiated with all the template parameters of L </p>

</div>
</div>
<a id="a918e3449905cfdb305cd08daff75ea7d" name="a918e3449905cfdb305cd08daff75ea7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a918e3449905cfdb305cd08daff75ea7d">&#9670;&#160;</a></span>Repeat</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class L , int N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceutil.html#a918e3449905cfdb305cd08daff75ea7d">util::Repeat</a> = typedef typename <a class="el" href="structutil_1_1detail_1_1Repeat__.html">detail::Repeat_</a>&lt;L, N&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repeat the template parameters of L N times. </p>
<p>L must have template parameters N must be bigger than 0 Repeated types are put in a <a class="el" href="structutil_1_1TypeList.html" title="Base template for a holder of entries of different data types.">TypeList</a> </p>

</div>
</div>
<a id="a14a8bcf81422d42715866547b59565cf" name="a14a8bcf81422d42715866547b59565cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14a8bcf81422d42715866547b59565cf">&#9670;&#160;</a></span>tuple</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">util::tuple</a> = typedef std::tuple&lt;Ts...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6e41c154c3642236d4daacdaf6dbcae" name="ae6e41c154c3642236d4daacdaf6dbcae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6e41c154c3642236d4daacdaf6dbcae">&#9670;&#160;</a></span>TypeListElement_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t I, class TL &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceutil.html#ae6e41c154c3642236d4daacdaf6dbcae">util::TypeListElement_t</a> = typedef typename <a class="el" href="structutil_1_1TypeListElement.html">TypeListElement</a>&lt;I, TL&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Element type retrieval: convenience alias. </p>

</div>
</div>
<a id="a3673b879f42d462272525a91b4eec1e2" name="a3673b879f42d462272525a91b4eec1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3673b879f42d462272525a91b4eec1e2">&#9670;&#160;</a></span>void_value_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;auto... &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceutil.html#a3673b879f42d462272525a91b4eec1e2">util::void_value_t</a> = typedef void</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="abd5a5420dd4b951e29677e638d726cbb" name="abd5a5420dd4b951e29677e638d726cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5a5420dd4b951e29677e638d726cbb">&#9670;&#160;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; util::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a620a1fd21759e40ab162a13770b9cd2a" name="a620a1fd21759e40ab162a13770b9cd2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620a1fd21759e40ab162a13770b9cd2a">&#9670;&#160;</a></span>cross()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="structutil_1_1array.html">array</a>&lt; T, 3 &gt; util::cross </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa767c1e539b3cacedc822a2bdc13caeb" name="aa767c1e539b3cacedc822a2bdc13caeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa767c1e539b3cacedc822a2bdc13caeb">&#9670;&#160;</a></span>determineAlignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int util::determineAlignment </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a734b142100b0f1a68e21fb3ec742dd" name="a0a734b142100b0f1a68e21fb3ec742dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a734b142100b0f1a68e21fb3ec742dd">&#9670;&#160;</a></span>discardLastElement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tuple &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto util::discardLastElement </td>
          <td>(</td>
          <td class="paramtype">const Tuple &amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a013aa68e8cfbb0345643e3e5d27122de" name="a013aa68e8cfbb0345643e3e5d27122de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a013aa68e8cfbb0345643e3e5d27122de">&#9670;&#160;</a></span>discardLastImpl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tuple , size_t... Is&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto util::discardLastImpl </td>
          <td>(</td>
          <td class="paramtype">const Tuple &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0483a1eef1c26d6843fb9d2f8d711ed4" name="a0483a1eef1c26d6843fb9d2f8d711ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0483a1eef1c26d6843fb9d2f8d711ed4">&#9670;&#160;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr T util::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7e329172dd75f88369a6433cf4a5d3a" name="ac7e329172dd75f88369a6433cf4a5d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e329172dd75f88369a6433cf4a5d3a">&#9670;&#160;</a></span>enumerateFieldNames()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structutil_1_1StructuralString.html">StructuralString</a> Prefix, size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::array&lt; const char *, N &gt; util::enumerateFieldNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a sequence "0", "1", ..., "N-1" of compile-time strings each. </p>

</div>
</div>
<a id="aa6de727ec09c883fa51ed0e2c66beb7b" name="aa6de727ec09c883fa51ed0e2c66beb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6de727ec09c883fa51ed0e2c66beb7b">&#9670;&#160;</a></span>for_each_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class F , class Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void util::for_each_tuple </td>
          <td>(</td>
          <td class="paramtype">F &amp;&amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to call function with each element in tuple_. </p>

</div>
</div>
<a id="a5da974871b8cccc6c5dca07f97e4d4a4" name="a5da974871b8cccc6c5dca07f97e4d4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da974871b8cccc6c5dca07f97e4d4a4">&#9670;&#160;</a></span>get() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr T &amp;&amp; util::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>a_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1e884d9a8bd1a660309343808ffe087" name="ae1e884d9a8bd1a660309343808ffe087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e884d9a8bd1a660309343808ffe087">&#9670;&#160;</a></span>get() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr T &amp; util::get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abd750f1278376f75f3b3249ddfa57073" name="abd750f1278376f75f3b3249ddfa57073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd750f1278376f75f3b3249ddfa57073">&#9670;&#160;</a></span>get() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr const T &amp;&amp; util::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>a_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1fe16a8435fe2a8700935975651d3cad" name="a1fe16a8435fe2a8700935975651d3cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe16a8435fe2a8700935975651d3cad">&#9670;&#160;</a></span>get() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t I, class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr const T &amp; util::get </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3473f842c64f19fca1c8501c0daf477" name="ac3473f842c64f19fca1c8501c0daf477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3473f842c64f19fca1c8501c0daf477">&#9670;&#160;</a></span>get() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto util::get </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>tup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5ad7309e712d76b3ab13632c3efa59d" name="ad5ad7309e712d76b3ab13632c3efa59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ad7309e712d76b3ab13632c3efa59d">&#9670;&#160;</a></span>get() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;<a class="el" href="structutil_1_1StructuralString.html">StructuralString</a> F, class FieldNames , class Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) util::get </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access a field of a tuple with named fields. </p>

</div>
</div>
<a id="a8b4c3755082fb42208664b0fef271c27" name="a8b4c3755082fb42208664b0fef271c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4c3755082fb42208664b0fef271c27">&#9670;&#160;</a></span>indexSequenceReverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... Is&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto util::indexSequenceReverse </td>
          <td>(</td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt; const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> -&gt;  decltype(std::index_sequence&lt; sizeof...(Is) - 1U - Is... &gt;{})</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca7348551de5d9c6a02c3cfc810683f0" name="aca7348551de5d9c6a02c3cfc810683f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7348551de5d9c6a02c3cfc810683f0">&#9670;&#160;</a></span>make_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StructuralString... Fields&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto util::make_tuple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structutil_1_1FieldList.html">FieldList</a>&lt; Fields... &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a74ac66ddf87f64e04671db2841676f2b" name="a74ac66ddf87f64e04671db2841676f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ac66ddf87f64e04671db2841676f2b">&#9670;&#160;</a></span>makeIntegralTuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t... Is&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto util::makeIntegralTuple </td>
          <td>(</td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>convert an index_sequence into a tuple of integral constants (e.g. for use with for_each_tuple) </p>

</div>
</div>
<a id="a23adedd716e1ecb76de96315428429ea" name="a23adedd716e1ecb76de96315428429ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23adedd716e1ecb76de96315428429ea">&#9670;&#160;</a></span>makeVec3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> <a class="el" href="structutil_1_1array.html">array</a>&lt; T, 3 &gt; util::makeVec3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structutil_1_1array.html">array</a>&lt; T, 4 &gt;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1befcf6c26d4bab8b67cb035206aa392" name="a1befcf6c26d4bab8b67cb035206aa392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1befcf6c26d4bab8b67cb035206aa392">&#9670;&#160;</a></span>max() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr T util::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>max reduction of a single array </p>

</div>
</div>
<a id="a40f32d54a6e6dce3da56300c9cc05855" name="a40f32d54a6e6dce3da56300c9cc05855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f32d54a6e6dce3da56300c9cc05855">&#9670;&#160;</a></span>max() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; util::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>element-wise max between two arrays </p>

</div>
</div>
<a id="a460513aaaeb888c058e37e543880ec20" name="a460513aaaeb888c058e37e543880ec20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460513aaaeb888c058e37e543880ec20">&#9670;&#160;</a></span>min() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr T util::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>min reduction of a single array </p>

</div>
</div>
<a id="a739fc2fcd66fe500c4110a7fb3ed0678" name="a739fc2fcd66fe500c4110a7fb3ed0678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739fc2fcd66fe500c4110a7fb3ed0678">&#9670;&#160;</a></span>min() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; util::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>element-wise min between two arrays </p>

</div>
</div>
<a id="a7bed9b96ba44afef5bd382bac7eccef6" name="a7bed9b96ba44afef5bd382bac7eccef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bed9b96ba44afef5bd382bac7eccef6">&#9670;&#160;</a></span>norm2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr T util::norm2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa79fee5ea8278f35906412fd8bcf31a" name="afa79fee5ea8278f35906412fd8bcf31a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa79fee5ea8278f35906412fd8bcf31a">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr bool util::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aacfd381c2432d4691f11ae3f19f92dd6" name="aacfd381c2432d4691f11ae3f19f92dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacfd381c2432d4691f11ae3f19f92dd6">&#9670;&#160;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S , class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; util::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44fb526cff8cfbc50e74dbf36ca97dc5" name="a44fb526cff8cfbc50e74dbf36ca97dc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fb526cff8cfbc50e74dbf36ca97dc5">&#9670;&#160;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class S , class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; util::operator* </td>
          <td>(</td>
          <td class="paramtype">const S &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a89e53ec9d38b695a93b1127cb3094c87" name="a89e53ec9d38b695a93b1127cb3094c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89e53ec9d38b695a93b1127cb3094c87">&#9670;&#160;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; util::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac711c32ba6b704e0e7bbd9a53a58ea1f" name="ac711c32ba6b704e0e7bbd9a53a58ea1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac711c32ba6b704e0e7bbd9a53a58ea1f">&#9670;&#160;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N1, size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structutil_1_1StructuralString.html">StructuralString</a>&lt; N1+N2 - 1 &gt; util::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structutil_1_1StructuralString.html">StructuralString</a>&lt; N1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structutil_1_1StructuralString.html">StructuralString</a>&lt; N2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2c5c2fef1e68f7f98d385ade63b4eed" name="aa2c5c2fef1e68f7f98d385ade63b4eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c5c2fef1e68f7f98d385ade63b4eed">&#9670;&#160;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;StructuralString... F1, StructuralString... F2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto util::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structutil_1_1FieldList.html">FieldList</a>&lt; F1... &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structutil_1_1FieldList.html">FieldList</a>&lt; F2... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3067923b82e90a736814f7b7a84fcdaf" name="a3067923b82e90a736814f7b7a84fcdaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3067923b82e90a736814f7b7a84fcdaf">&#9670;&#160;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; util::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3161642b9ee4b663c1dbfea8a1b3314b" name="a3161642b9ee4b663c1dbfea8a1b3314b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3161642b9ee4b663c1dbfea8a1b3314b">&#9670;&#160;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; util::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a511901687edc82df3fc37ea7190ac9c0" name="a511901687edc82df3fc37ea7190ac9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511901687edc82df3fc37ea7190ac9c0">&#9670;&#160;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr bool util::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a03a70645d4e7bcb0892d4afbc145af12" name="a03a70645d4e7bcb0892d4afbc145af12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a70645d4e7bcb0892d4afbc145af12">&#9670;&#160;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr bool util::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a59f59f5097a51d23c006cfdaa19abb07" name="a59f59f5097a51d23c006cfdaa19abb07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f59f5097a51d23c006cfdaa19abb07">&#9670;&#160;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t N1, size_t N2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool util::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structutil_1_1StructuralString.html">StructuralString</a>&lt; N1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structutil_1_1StructuralString.html">StructuralString</a>&lt; N2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a41130aec2552cf410b6bac94e2ba6a4c" name="a41130aec2552cf410b6bac94e2ba6a4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41130aec2552cf410b6bac94e2ba6a4c">&#9670;&#160;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , std::size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="annotation_8hpp.html#ae00f3eca79281b4503d41fc4872505e7">HOST_DEVICE_FUN</a> constexpr bool util::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structutil_1_1array.html">array</a>&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b32b539ae6294b7e1d47c3d4d13ab23" name="a7b32b539ae6294b7e1d47c3d4d13ab23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b32b539ae6294b7e1d47c3d4d13ab23">&#9670;&#160;</a></span>pickType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) util::pickType </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&#160;</td>
          <td class="paramname"><em>tup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Meta function to return the element in Tuple whose type matches T. </p>
<p>If there are more than one, the first occurrence will be returned If there is no such that, a compiler error is generated due to accessing the tuple out of bounds </p>

</div>
</div>
<a id="afc601fd454823cc351f5dbfd6c6d8c88" name="afc601fd454823cc351f5dbfd6c6d8c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc601fd454823cc351f5dbfd6c6d8c88">&#9670;&#160;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) util::reverse </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd880dcecec32bde6fed2b259b7a6d5c" name="acd880dcecec32bde6fed2b259b7a6d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd880dcecec32bde6fed2b259b7a6d5c">&#9670;&#160;</a></span>selectTuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Tuple , std::size_t... Ints&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::tuple_element_t&lt; Ints, std::decay_t&lt; Tuple &gt; &gt;... &gt; util::selectTuple </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Ints... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67b6fe98113e3b7fa9b07113a69a0d1a" name="a67b6fe98113e3b7fa9b07113a69a0d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b6fe98113e3b7fa9b07113a69a0d1a">&#9670;&#160;</a></span>tie()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class... Ts&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="namespaceutil.html#a14a8bcf81422d42715866547b59565cf">tuple</a>&lt; Ts &amp;... &gt; util::tie </td>
          <td>(</td>
          <td class="paramtype">Ts &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceutil.html">util</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
